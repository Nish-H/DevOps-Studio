[
  {
    "id": "imported-1759100564485-dm70gpi1o",
    "name": "Requires -Version 5.1",
    "description": "Requires -Version 5.1",
    "content": "#Requires -Version 5.1\n#Requires -RunAsAdministrator\n# Note: ActiveDirectory and GroupPolicy modules will be imported dynamically with error handling\n\n<#\n.SYNOPSIS\n    Master Infrastructure Audit Script - Comprehensive AD and Server Assessment\n    \n.DESCRIPTION\n    This script performs a comprehensive audit of Active Directory and server infrastructure,\n    incorporating industry best practices, security compliance standards, and proven methodologies\n    from multiple audit frameworks. It provides detailed analysis, risk scoring, and actionable\n    recommendations for infrastructure improvements.\n    \n.PARAMETER CustomerName\n    Name of the customer/organization being audited\n    \n.PARAMETER TechnicianName  \n    Name of the technician performing the audit\n    \n.PARAMETER OutputPath\n    Custom output directory path (defaults to desktop)\n    \n.PARAMETER ServerListPath\n    Path to CSV file containing server list (optional - auto-discovers from AD if not provided)\n    \n.PARAMETER SkipServerAudit\n    Skip server infrastructure auditing (AD only)\n    \n.PARAMETER SkipADHealthChecks\n    Skip Active Directory health checks\n    \n.PARAMETER MaxConcurrentJobs\n    Maximum concurrent server audit jobs (default: 10)\n    \n.PARAMETER CredentialPath\n    Path to secure credential file (optional)\n    \n.PARAMETER ExportFormats\n    Export formats: HTML, PDF, Excel, CSV, Markdown (default: HTML,Excel,CSV)\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Acme Corp\" -TechnicianName \"John Smith\"\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Client\" -TechnicianName \"Engineer\" -SkipServerAudit\n\n    -CustomerName \"Ashton Graham\" -TechnicianName \"Nishen Harichunder\" -ServerListPath \"C:\\FtechSupport\\N1_Audit\\server-list.csv\"\n\n    \n.NOTES\n    Author: Nishen Harichunder - RMS L4 Infrastructure Audit Team\n    Version: 1.0\n    Created: $(Get-Date -Format 'yyyy-MM-dd')\n    \n    Requirements:\n    - PowerShell 5.1 or higher\n    - Active Directory PowerShell module\n    - Domain Admin or equivalent privileges for comprehensive auditing\n    - Network connectivity to all target systems\n    \n    Security Considerations:\n    - All credentials are handled securely using PowerShell credential objects\n    - Audit activities are logged comprehensively\n    - Sensitive data is protected in transit and at rest\n    - Script follows principle of least privilege where possible\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$true, HelpMessage=\"Customer/Organization name for audit report\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$CustomerName,\n    \n    [Parameter(Mandatory=$true, HelpMessage=\"Technician name performing the audit\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$TechnicianName,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$OutputPath,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ServerListPath,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipServerAudit,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipADHealthChecks,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateRange(1,20)]\n    [int]$MaxConcurrentJobs = 10,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$CredentialPath,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateSet('HTML','PDF','Excel','CSV','Markdown')]\n    [string[]]$ExportFormats = @('HTML','Excel','CSV')\n)\n\n# ==============================================================================\n# SCRIPT CONFIGURATION AND INITIALIZATION\n# ==============================================================================\n\n# Global script variables\n$script:Version = '1.0'\n$script:StartTime = Get-Date\n$script:AuditFindings = @()\n$script:ServerResults = @()\n$script:ADHealthResults = @()\n$script:CompletedTasks = 0\n$script:TotalTasks = 0\n\n# Risk scoring configuration\n$script:RiskScores = @{\n    'Critical' = 10\n    'High' = 7\n    'Medium' = 4\n    'Low' = 2\n    'Info' = 1\n}\n\n# Compliance frameworks\n$script:ComplianceFrameworks = @{\n    'CIS' = 'Center for Internet Security Benchmarks'\n    'NIST' = 'NIST Cybersecurity Framework'\n    'ISO27001' = 'ISO 27001 Information Security Management'\n    'Microsoft' = 'Microsoft Security Baselines'\n}\n\n# Initialize output directory\nif (-not $OutputPath) {\n    $script:OutputDir = Join-Path $env:USERPROFILE \"Desktop\\Infrastructure-Audit-$CustomerName-$(Get-Date -Format 'yyyyMMdd-HHmmss')\"\n} else {\n    $script:OutputDir = $OutputPath\n}\n\nif (-not (Test-Path $script:OutputDir)) {\n    New-Item -ItemType Directory -Path $script:OutputDir -Force | Out-Null\n}\n\n# Initialize logo path\n$script:LogoPath = \"\"\n\n# ==============================================================================\n# LOGGING AND UTILITY FUNCTIONS\n# ==============================================================================\n\nfunction Test-RequiredModules {\n    Write-Host \"Checking required PowerShell modules...\" -ForegroundColor Yellow\n    \n    # Check if running on Windows Server or Client\n    $isWindowsServer = (Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -ne 1\n    \n    $requiredModules = @('ActiveDirectory')\n    $optionalModules = @('GroupPolicy')\n    $missingModules = @()\n    $missingOptionalModules = @()\n    $availableModules = @()\n    \n    # Check required modules\n    foreach ($module in $requiredModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"✗ $module module is NOT available\" -ForegroundColor Red\n                $missingModules += $module\n            }\n        } catch {\n            Write-Host \"✗ Error checking $module module: $($_.Exception.Message)\" -ForegroundColor Red\n            $missingModules += $module\n        }\n    }\n    \n    # Check optional modules\n    foreach ($module in $optionalModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"⚠ $module module is NOT available (optional - some features may be limited)\" -ForegroundColor Yellow\n                $missingOptionalModules += $module\n            }\n        } catch {\n            Write-Host \"⚠ Error checking $module module: $($_.Exception.Message) (optional)\" -ForegroundColor Yellow\n            $missingOptionalModules += $module\n        }\n    }\n    \n    # Handle missing required modules\n    if ($missingModules.Count -gt 0) {\n        Write-Host \"`nMissing Required Modules:\" -ForegroundColor Red\n        foreach ($module in $missingModules) {\n            Write-Host \"  - $module\" -ForegroundColor Red\n        }\n        Write-Host \"`nTo install missing modules, run the following commands as Administrator:\" -ForegroundColor Yellow\n        if ($missingModules -contains 'ActiveDirectory') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name RSAT-AD-PowerShell\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.ActiveDirectory*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n        return $false\n    }\n    \n    # Handle missing optional modules\n    if ($missingOptionalModules.Count -gt 0) {\n        Write-Host \"`nMissing Optional Modules:\" -ForegroundColor Yellow\n        foreach ($module in $missingOptionalModules) {\n            Write-Host \"  - $module (Group Policy auditing will be limited)\" -ForegroundColor Yellow\n        }\n        Write-Host \"`nTo install optional modules for full functionality:\" -ForegroundColor Yellow\n        if ($missingOptionalModules -contains 'GroupPolicy') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name GPMC\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.GroupPolicy*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nContinuing with limited functionality...\" -ForegroundColor Yellow\n    }\n    \n    if ($missingOptionalModules.Count -eq 0) {\n        Write-Host \"All required and optional modules are available!\" -ForegroundColor Green\n    } else {\n        Write-Host \"Required modules are available. Continuing with some optional features disabled.\" -ForegroundColor Yellow\n    }\n    \n    # Store available modules for later use\n    $script:AvailableModules = $availableModules\n    return $true\n}\n\nfunction Write-AuditLog {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Message,\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Header', 'Debug')]\n        [string]$Level = 'Info',\n        \n        [Parameter(Mandatory=$false)]\n        [switch]$NoConsole\n    )\n    \n    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'\n    $logEntry = \"[$timestamp] [$Level] $Message\"\n    \n    # Console output with colors\n    if (-not $NoConsole) {\n        switch ($Level) {\n            'Info' { Write-Host $logEntry -ForegroundColor White }\n            'Warning' { Write-Host $logEntry -ForegroundColor Yellow }\n            'Error' { Write-Host $logEntry -ForegroundColor Red }\n            'Success' { Write-Host $logEntry -ForegroundColor Green }\n            'Debug' { Write-Host $logEntry -ForegroundColor Gray }\n            'Header' { \n                Write-Host \"\"\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n                Write-Host $Message -ForegroundColor Cyan\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n            }\n        }\n    }\n    \n    # File logging\n    $logFile = Join-Path $script:OutputDir 'master-audit-log.txt'\n    try {\n        Add-Content -Path $logFile -Value $logEntry -ErrorAction Stop\n    } catch {\n        # Fallback logging if main log fails\n        $logEntry | Out-File -FilePath (Join-Path $script:OutputDir 'audit-log-backup.txt') -Append -ErrorAction Stop\n    }\n}\n\nfunction Convert-ToBase64 {\n    param([string]$FilePath)\n    try {\n        if (Test-Path $FilePath) {\n            $bytes = [System.IO.File]::ReadAllBytes($FilePath)\n            return [System.Convert]::ToBase64String($bytes)\n        }\n        return \"\"\n    } catch {\n        return \"\"\n    }\n}\n\nfunction Initialize-LogoPath {\n    $logoFolder = Join-Path (Split-Path $script:MyInvocation.MyCommand.Path) \"Ftech Logos\"\n    $logoFiles = @(\n        \"first-tech-kzn-logo-black 1.png\",\n        \"FTECHKZN Horizontal Vector-03 1.png\", \n        \"FTECHKZN Horizontal Vector-04 1 (2).png\"\n    )\n    \n    foreach ($logoFile in $logoFiles) {\n        $logoPath = Join-Path $logoFolder $logoFile\n        if (Test-Path $logoPath) {\n            return $logoPath\n        }\n    }\n    \n    # Fallback - find any PNG in logo folder\n    $pngFiles = Get-ChildItem -Path $logoFolder -Filter \"*.png\" -ErrorAction SilentlyContinue\n    if ($pngFiles) {\n        return $pngFiles[0].FullName\n    }\n    \n    return \"\"\n}\n\nfunction Add-AuditFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [ValidateSet('Critical', 'High', 'Medium', 'Low', 'Info')]\n        [string]$Severity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Impact,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Recommendation,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"F$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = $Severity\n        Type = $Type\n        Description = $Description\n        Impact = $Impact\n        Recommendation = $Recommendation\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = $script:RiskScores[$Severity]\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    \n    $logLevel = switch ($Severity) {\n        'Critical' { 'Error' }\n        'High' { 'Error' }\n        'Medium' { 'Warning' }\n        default { 'Info' }\n    }\n    \n    Write-AuditLog \"[$Severity] $Category - $Title\" -Level $logLevel\n}\n\nfunction Add-PositiveFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"P$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = 'Passed'\n        Type = $Type\n        Description = $Description\n        Impact = 'Positive security posture - no action required.'\n        Recommendation = 'Continue current security practices.'\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = 0\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    Write-AuditLog \"[PASSED] $Category - $Title\" -Level Success\n}\n\nfunction Update-AuditProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Status = '',\n        \n        [Parameter(Mandatory=$false)]\n        [int]$PercentComplete = 0,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Completed = $script:CompletedTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Total = $script:TotalTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Id = 0\n    )\n    \n    if ($Total -gt 0) {\n        $PercentComplete = [math]::Round(($Completed / $Total) * 100, 1)\n    }\n    \n    # Ensure percentage never exceeds 100\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    $progressParams = @{\n        Activity = $Activity\n        Status = $Status\n        PercentComplete = $PercentComplete\n        Id = $Id\n    }\n    \n    if ($Total -gt 0) {\n        $progressParams.CurrentOperation = \"Phase $Completed of $Total - $PercentComplete% Complete\"\n    }\n    \n    Write-Progress @progressParams\n    \n    if ($Status) {\n        Write-AuditLog \"Overall Progress: $PercentComplete% - $Status\" -Level Info\n    }\n}\n\nfunction Update-SectionProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Status,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$StepNumber,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$TotalSteps,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$ParentId = 0\n    )\n    \n    $PercentComplete = [math]::Round(($StepNumber / $TotalSteps) * 100, 1)\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    Write-Progress -Id ($ParentId + 1) -ParentId $ParentId -Activity $Activity -Status $Status -PercentComplete $PercentComplete -CurrentOperation \"Step $StepNumber of $TotalSteps\"\n    \n    Write-AuditLog \"Section Progress: [$Activity] $PercentComplete% - $Status\" -Level Debug\n}\n\n# ==============================================================================\n# ACTIVE DIRECTORY HEALTH CHECKS\n# ==============================================================================\n\nfunction Test-WinRMConnectivity {\n    <#\n    .SYNOPSIS\n        Tests WinRM connectivity to remote computers\n    .DESCRIPTION\n        Verifies if PowerShell remoting is available and working on target computers\n    .PARAMETER ComputerName\n        The name of the remote computer to test\n    .EXAMPLE\n        Test-WinRMConnectivity -ComputerName \"DC01.domain.com\"\n    #>\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName\n    )\n    \n    $result = @{\n        ComputerName = $ComputerName\n        WinRMAvailable = $false\n        Port5985Open = $false\n        Port5986Open = $false\n        PSRemotingWorking = $false\n        ErrorMessage = $null\n    }\n    \n    try {\n        # Test WinRM ports\n        Write-AuditLog \"Testing WinRM connectivity to $ComputerName...\" -Level Info\n        \n        # Test HTTP port (5985)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5985 -WarningAction SilentlyContinue\n            $result.Port5985Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5985 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test HTTPS port (5986)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5986 -WarningAction SilentlyContinue\n            $result.Port5986Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5986 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test actual PowerShell remoting\n        try {\n            $testSession = New-PSSession -ComputerName $ComputerName -ErrorAction Stop\n            if ($testSession) {\n                $result.PSRemotingWorking = $true\n                $result.WinRMAvailable = $true\n                Remove-PSSession -Session $testSession -ErrorAction SilentlyContinue\n                Write-AuditLog \"PowerShell remoting is working on $ComputerName\" -Level Success\n            }\n        } catch {\n            $result.ErrorMessage = $_.Exception.Message\n            Write-AuditLog \"PowerShell remoting test failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Alternative test using Invoke-Command with test command\n        if (-not $result.PSRemotingWorking) {\n            try {\n                $testResult = Invoke-Command -ComputerName $ComputerName -ScriptBlock { $env:COMPUTERNAME } -ErrorAction Stop\n                if ($testResult) {\n                    $result.PSRemotingWorking = $true\n                    $result.WinRMAvailable = $true\n                    Write-AuditLog \"PowerShell remoting confirmed working on $ComputerName via Invoke-Command\" -Level Success\n                }\n            } catch {\n                Write-AuditLog \"Invoke-Command test also failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        $result.ErrorMessage = $_.Exception.Message\n        Write-AuditLog \"WinRM connectivity test failed for $ComputerName - $($_.Exception.Message)\" -Level Error\n    }\n    \n    return $result\n}\n\nfunction Test-RemoteService {\n    <#\n    .SYNOPSIS\n        Tests the status of a service on a remote computer using multiple methods\n    .DESCRIPTION\n        This function attempts to check service status using various methods as fallbacks:\n        1. Get-Service with ComputerName parameter\n        2. WMI Win32_Service class\n        3. PowerShell remoting with Invoke-Command\n        4. SC.exe command-line tool\n    .PARAMETER ComputerName\n        The name of the remote computer\n    .PARAMETER ServiceName\n        The name of the service to check\n    .PARAMETER DisplayName\n        The display name of the service for logging\n    .OUTPUTS\n        Returns hashtable with ServiceStatus, Method, and ErrorDetails\n    #>\n    param(\n        [Parameter(Mandatory)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory)]\n        [string]$ServiceName,\n        \n        [Parameter(Mandatory)]\n        [string]$DisplayName\n    )\n    \n    $result = @{\n        ServiceStatus = $null\n        Method = $null\n        ErrorDetails = @()\n        Success = $false\n    }\n    \n    # Method 1: Standard Get-Service with ComputerName\n    try {\n        $serviceStatus = Get-Service -ComputerName $ComputerName -Name $ServiceName -ErrorAction Stop\n        $result.ServiceStatus = $serviceStatus.Status\n        $result.Method = 'Get-Service'\n        $result.Success = $true\n        return $result\n    } catch {\n        $result.ErrorDetails += \"Get-Service failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 2: WMI Win32_Service\n    try {\n        $serviceStatus = Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter \"Name='$ServiceName'\" -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.State\n            $result.Method = 'WMI'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"WMI returned null for service $ServiceName\"\n        }\n    } catch {\n        $result.ErrorDetails += \"WMI query failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 3: PowerShell remoting\n    try {\n        $scriptBlock = { param($ServiceName) Get-Service -Name $ServiceName -ErrorAction Stop }\n        $serviceStatus = Invoke-Command -ComputerName $ComputerName -ScriptBlock $scriptBlock -ArgumentList $ServiceName -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.Status\n            $result.Method = 'PowerShell Remoting'\n            $result.Success = $true\n            return $result\n        }\n    } catch {\n        $result.ErrorDetails += \"PowerShell remoting failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 4: SC.exe as last resort\n    try {\n        $scResult = & sc.exe \\\\$ComputerName query $ServiceName 2>&1\n        if ($scResult -match \"STATE.*RUNNING\") {\n            $result.ServiceStatus = 'Running'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } elseif ($scResult -match \"STATE.*STOPPED\") {\n            $result.ServiceStatus = 'Stopped'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"SC.exe returned unexpected result: $($scResult -join '; ')\"\n        }\n    } catch {\n        $result.ErrorDetails += \"SC.exe failed: $($_.Exception.Message)\"\n    }\n    \n    return $result\n}\n\nfunction Test-ADInfrastructureHealth {\n    Write-AuditLog 'Starting Active Directory Infrastructure Health Assessment' -Level Header\n    \n    try {\n        # Verify AD module and domain connectivity\n        Import-Module ActiveDirectory -SkipEditionCheck -ErrorAction Stop\n        $domain = Get-ADDomain -ErrorAction Stop\n        $forest = Get-ADForest -ErrorAction Stop\n        \n        Write-AuditLog \"Connected to domain: $($domain.DNSRoot)\" -Level Success\n        Write-AuditLog \"Forest functional level: $($forest.ForestMode)\" -Level Info\n        Write-AuditLog \"Domain functional level: $($domain.DomainMode)\" -Level Info\n        \n        # Test individual AD components\n        Test-DomainControllerHealth\n        # Test-DomainControllerExtendedHealth  # DISABLED: Causing false positives with old methods\n        Test-ADReplicationHealth  \n        Test-FSMORoleAvailability\n        Test-ADContainerStructure\n        Test-GroupPolicyCompliance\n        Test-ServiceAccountSecurity\n        Test-DNSInfrastructure\n        Test-ADSecurityConfiguration\n        Test-CertificateServices\n        \n    } catch {\n        Write-AuditLog \"FATAL: Unable to connect to Active Directory: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Connectivity' -Title 'Active Directory Connection Failed' -Severity 'Critical' `\n            -Description 'Unable to establish connection to Active Directory services.' `\n            -Impact 'Cannot perform comprehensive AD health assessment.' `\n            -Recommendation 'Verify network connectivity, DNS resolution, and AD service availability.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n        return $false\n    }\n    \n    return $true\n}\n\nfunction Test-DomainControllerHealth {\n    Write-AuditLog 'Checking Domain Controller Health...' -Level Info\n    \n    try {\n        # Get all domain controllers\n        $domainControllers = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().Domains | \n            ForEach-Object { $_.DomainControllers } | ForEach-Object { $_.Name }\n        \n        Write-AuditLog \"Found $($domainControllers.Count) domain controllers\" -Level Info\n        \n        foreach ($dc in $domainControllers) {\n            Write-AuditLog \"Testing DC: $dc\" -Level Info\n            \n            # Connectivity test\n            $pingResult = Test-Connection -ComputerName $dc -Count 2 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'Domain Controllers' -Title \"Domain Controller Unreachable: $dc\" -Severity 'Critical' `\n                    -Description \"Domain Controller $dc is not responding to ping requests.\" `\n                    -Impact 'Domain services may be unavailable, affecting authentication and directory services.' `\n                    -Recommendation 'Investigate network connectivity and DC service status immediately.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n                continue\n            }\n            \n            # Enhanced DC health checks using PowerShell remoting for better reliability\n            Write-AuditLog \"Testing connectivity and establishing session to $dc...\" -Level Info\n            \n            # First test WinRM connectivity\n            $winrmTest = Test-WinRMConnectivity -ComputerName $dc\n            \n            if (-not $winrmTest.WinRMAvailable) {\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"WinRM Connectivity Issues on $dc\" -Severity 'Medium' `\n                    -Description \"PowerShell remoting is not available on domain controller $dc.\" `\n                    -Impact 'Limited ability to perform comprehensive remote health checks.' `\n                    -Recommendation 'Enable PowerShell remoting on the DC using \"Enable-PSRemoting -Force\" or verify WinRM service and firewall settings.' `\n                    -Evidence \"Port 5985 Open: $($winrmTest.Port5985Open), Port 5986 Open: $($winrmTest.Port5986Open), Error: $($winrmTest.ErrorMessage)\" `\n                    -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n            \n            try {\n                # Test if PowerShell remoting is available\n                $session = $null\n                $canUseRemoting = $winrmTest.PSRemotingWorking\n                \n                if ($canUseRemoting) {\n                    try {\n                        $session = New-PSSession -ComputerName $dc -ErrorAction Stop\n                        Write-AuditLog \"PowerShell remoting session established to $dc\" -Level Success\n                    } catch {\n                        $canUseRemoting = $false\n                        Write-AuditLog \"PowerShell remoting session failed to $dc - $($_.Exception.Message)\" -Level Warning\n                    }\n                } else {\n                    Write-AuditLog \"PowerShell remoting not available to $dc, using fallback methods\" -Level Warning\n                }\n                \n                if ($canUseRemoting -and $session) {\n                    # Use PowerShell remoting for reliable DC health checks\n                    $dcHealthData = Invoke-Command -Session $session -ScriptBlock {\n                        $healthResult = @{\n                            Services = @{}\n                            ComputerInfo = @{}\n                            EventLogs = @{}\n                            Errors = @()\n                        }\n                        \n                        # Check critical DC services locally on the DC\n                        $services = @('Netlogon', 'NTDS', 'DNS', 'W32Time', 'KDC', 'ADWS')\n                        foreach ($serviceName in $services) {\n                            try {\n                                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n                                if ($service) {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = $service.Status.ToString()\n                                        StartType = $service.StartType.ToString()\n                                        DisplayName = $service.DisplayName\n                                    }\n                                } else {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = 'NotInstalled'\n                                        Error = \"Service $serviceName not found\"\n                                    }\n                                }\n                            } catch {\n                                $healthResult.Services[$serviceName] = @{\n                                    Status = 'Error'\n                                    Error = $_.Exception.Message\n                                }\n                                $healthResult.Errors += \"Service check failed for $serviceName - $($_.Exception.Message)\"\n                            }\n                        }\n                        \n                        # Get system info\n                        try {\n                            $computerInfo = Get-ComputerInfo -Property WindowsProductName, WindowsVersion, TotalPhysicalMemory, CsProcessors, LastBootUpTime -ErrorAction SilentlyContinue\n                            if ($computerInfo) {\n                                $healthResult.ComputerInfo = @{\n                                    ProductName = $computerInfo.WindowsProductName\n                                    Version = $computerInfo.WindowsVersion\n                                    Memory = [math]::Round($computerInfo.TotalPhysicalMemory / 1GB, 2)\n                                    Processors = $computerInfo.CsProcessors.Count\n                                    LastBoot = $computerInfo.LastBootUpTime\n                                    UptimeDays = if ($computerInfo.LastBootUpTime) { [math]::Round(((Get-Date) - $computerInfo.LastBootUpTime).TotalDays, 2) } else { 'Unknown' }\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Computer info collection failed: $($_.Exception.Message)\"\n                        }\n                        \n                        # Check for recent critical events (excluding common benign events)\n                        try {\n                            # Define benign/informational event IDs that should not be flagged as critical\n                            $benignEventIds = @(\n                                10016,  # DCOM permission issues (usually benign)\n                                1008,   # Time service events\n                                10031,  # DCOM configuration events\n                                257,    # Performance counter events\n                                1074,   # System shutdown events (planned)\n                                2974,   # DNS server events (informational)\n                                1500,   # Group Policy processing events\n                                8193,   # DNS cache events\n                                1023,   # Windows licensing events\n                                1059,   # User profile events (warnings)\n                                7034,   # Service crash (often recoverable)\n                                7000,   # Service start failures (often transient)\n                                6008,   # System shutdown events\n                                41,     # System rebooted without shutdown (if planned maintenance)\n                                1001,   # Windows Error Reporting\n                                10028,  # DCOM activation events\n                                4107,   # Windows Firewall events (informational)\n                                8003,   # Kernel boot events\n                                219,    # Registry events (informational)\n                                35,     # Time synchronization events\n                                137     # NetLogon events (informational)\n                            )\n                            \n                            $allEvents = Get-WinEvent -FilterHashtable @{LogName='System','Application','Directory Service'; Level=1,2; StartTime=(Get-Date).AddHours(-24)} -MaxEvents 50 -ErrorAction SilentlyContinue\n                            \n                            # Filter out benign events and only flag truly critical ones\n                            $criticalEvents = $allEvents | Where-Object { \n                                $_.Id -notin $benignEventIds -and\n                                $_.LevelDisplayName -eq 'Error' -and\n                                $_.LogName -notmatch 'Security|Setup' -and\n                                $_.Message -notmatch '(?i)(information|completed successfully|started|stopped normally|backup|maintenance)'\n                            } | Select-Object -First 5\n                            \n                            $healthResult.EventLogs.CriticalEvents = $criticalEvents | ForEach-Object {\n                                @{\n                                    TimeCreated = $_.TimeCreated\n                                    Id = $_.Id\n                                    LevelDisplayName = $_.LevelDisplayName\n                                    LogName = $_.LogName\n                                    Message = $_.Message.Substring(0, [Math]::Min($_.Message.Length, 200)) + \"...\"\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Event log check failed: $($_.Exception.Message)\"\n                        }\n                        \n                        return $healthResult\n                    }\n                    \n                    # Process the health data and create findings\n                    Write-AuditLog \"Processing DC health data for $dc...\" -Level Info\n                    \n                    # Check services\n                    foreach ($serviceName in $dcHealthData.Services.Keys) {\n                        $serviceData = $dcHealthData.Services[$serviceName]\n                        \n                        if ($serviceData.Status -eq 'Running') {\n                            Write-AuditLog \"Service $serviceName on $dc - Running\" -Level Success\n                        } elseif ($serviceData.Status -eq 'NotInstalled' -and $serviceName -in @('DNS', 'ADWS')) {\n                            # DNS and ADWS may not be installed on all DCs\n                            Write-AuditLog \"Service $serviceName not installed on $dc (may be normal)\" -Level Info\n                        } else {\n                            $severity = if ($serviceName -in @('Netlogon', 'NTDS', 'KDC')) { 'Critical' } else { 'High' }\n                            $serviceDisplayName = if ($serviceData.DisplayName) { $serviceData.DisplayName } else { $serviceName }\n                            \n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has critical health issues.\" `\n                                -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n                                -Recommendation \"Immediately investigate: Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Evidence \"Issues: Recent Reboot Detected, Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Type 'Availability' -ComplianceFramework 'Microsoft'\n                        }\n                    }\n                    \n                    # Check uptime\n                    if ($dcHealthData.ComputerInfo.UptimeDays -lt 1) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Recent Reboot Detected on $dc\" -Severity 'Medium' `\n                            -Description \"Domain controller $dc was recently rebooted (uptime: $($dcHealthData.ComputerInfo.UptimeDays) days).\" `\n                            -Impact 'Recent reboots may indicate instability or maintenance.' `\n                            -Recommendation 'Review event logs to determine the cause of the reboot.' `\n                            -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                    \n                    # Report critical events (only if truly concerning)\n                    if ($dcHealthData.EventLogs.CriticalEvents -and $dcHealthData.EventLogs.CriticalEvents.Count -gt 0) {\n                        # Only report if there are multiple critical events or specific high-impact event IDs\n                        $highImpactEvents = $dcHealthData.EventLogs.CriticalEvents | Where-Object { \n                            $_.Id -in @(6008, 41, 7031, 7024, 1073, 4625, 529, 644) # Truly critical event IDs\n                        }\n                        \n                        $shouldReport = $false\n                        $severity = 'Medium'\n                        \n                        if ($highImpactEvents.Count -gt 0) {\n                            $shouldReport = $true\n                            $severity = 'High'\n                        } elseif ($dcHealthData.EventLogs.CriticalEvents.Count -gt 3) {\n                            $shouldReport = $true\n                            $severity = 'Medium'\n                        }\n                        \n                        if ($shouldReport) {\n                            $eventSummary = $dcHealthData.EventLogs.CriticalEvents | ForEach-Object { \"Event $($_.Id) at $($_.TimeCreated)\" }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"System Events Requiring Attention on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has system events that may require attention.\" `\n                                -Impact 'Multiple system events may indicate maintenance needs or configuration issues.' `\n                                -Recommendation 'Review event logs for patterns and address any recurring issues. Most events may be informational.' `\n                                -Evidence ($eventSummary -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"Minor system events found on $dc but below reporting threshold\" -Level Info\n                        }\n                    }\n                    \n                    Remove-PSSession -Session $session -ErrorAction SilentlyContinue\n                    \n                } else {\n                    # Fallback to basic connectivity and DCDIAG only\n                    Write-AuditLog \"Using fallback methods for $dc health check\" -Level Warning\n                    \n                    # Basic service check using Get-Service -ComputerName (may fail)\n                    $services = @('Netlogon', 'NTDS', 'DNS')\n                    $serviceIssues = @()\n                    \n                    foreach ($serviceName in $services) {\n                        try {\n                            $service = Get-Service -ComputerName $dc -Name $serviceName -ErrorAction Stop\n                            if ($service.Status -ne 'Running') {\n                                $serviceIssues += \"Service $serviceName not running ($($service.Status))\"\n                            }\n                        } catch {\n                            $serviceIssues += \"Cannot check service $serviceName\"\n                        }\n                    }\n                    \n                    if ($serviceIssues) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Service Issues on $dc\" -Severity 'High' `\n                            -Description \"Unable to verify all services on domain controller $dc.\" `\n                            -Impact 'Cannot confirm DC service availability.' `\n                            -Recommendation 'Manually verify DC services and enable PowerShell remoting for better monitoring.' `\n                            -Evidence ($serviceIssues -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DC health check failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"Health Check Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to perform comprehensive health check on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health and availability.' `\n                    -Recommendation 'Manually verify DC status and connectivity.' `\n                    -Evidence $_.Exception.Message -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n            \n            # Enhanced DCDIAG tests with proper domain context and authentication\n            Write-AuditLog \"Running DCDIAG tests on $dc...\" -Level Info\n            \n            try {\n                # First, run a comprehensive DCDIAG test\n                Write-AuditLog \"Running comprehensive DCDIAG on $dc\" -Level Info\n                $dcdiagFull = dcdiag /s:$dc /v /c /q 2>&1\n                \n                # Parse DCDIAG results more intelligently\n                $testResults = @{}\n                $currentTest = $null\n                $testPassed = $true\n                \n                foreach ($line in $dcdiagFull) {\n                    if ($line -match \"^\\s*Starting test:\\s*(.+)\") {\n                        if ($currentTest) {\n                            $testResults[$currentTest] = $testPassed\n                        }\n                        $currentTest = $matches[1].Trim()\n                        $testPassed = $true\n                    } elseif ($line -match \"(failed|error)\" -and $currentTest) {\n                        $testPassed = $false\n                    }\n                }\n                \n                # Add the last test result\n                if ($currentTest) {\n                    $testResults[$currentTest] = $testPassed\n                }\n                \n                # Report test results\n                $failedTests = @()\n                foreach ($test in $testResults.Keys) {\n                    if (-not $testResults[$test]) {\n                        $failedTests += $test\n                        Write-AuditLog \"DCDIAG test '$test' failed on $dc\" -Level Warning\n                    } else {\n                        Write-AuditLog \"DCDIAG test '$test' passed on $dc\" -Level Success\n                    }\n                }\n                \n                # Create findings for failed tests\n                if ($failedTests.Count -gt 0) {\n                    $severity = 'High'\n                    if ($failedTests -contains 'Replications' -or $failedTests -contains 'Connectivity') {\n                        $severity = 'Critical'\n                    }\n                    \n                    Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Test Failures on $dc\" -Severity $severity `\n                        -Description \"Multiple DCDIAG tests failed on domain controller $dc.\" `\n                        -Impact 'Failed DCDIAG tests indicate potential issues with DC functionality, replication, or connectivity.' `\n                        -Recommendation \"Investigate failed tests: $($failedTests -join ', '). Run 'dcdiag /s:$dc /test:$($failedTests[0]) /v' for detailed diagnostics.\" `\n                        -Evidence \"Failed tests: $($failedTests -join ', ')\" -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                } else {\n                    Write-AuditLog \"All DCDIAG tests passed on $dc\" -Level Success\n                }\n                \n                # Additional focused tests for critical functions\n                $criticalTests = @(\n                    @{Name='Connectivity'; Command='dcdiag /test:connectivity /s:$dc /q'},\n                    @{Name='Advertising'; Command='dcdiag /test:advertising /s:$dc /q'},\n                    @{Name='Replications'; Command='dcdiag /test:replications /s:$dc /q'},\n                    @{Name='Services'; Command='dcdiag /test:services /s:$dc /q'},\n                    @{Name='SysVolCheck'; Command='dcdiag /test:netlogons /s:$dc /q'}\n                )\n                \n                foreach ($test in $criticalTests) {\n                    try {\n                        Write-AuditLog \"Running focused DCDIAG test: $($test.Name) on $dc\" -Level Info\n                        $testCommand = $test.Command.Replace('$dc', $dc)\n                        $result = Invoke-Expression $testCommand 2>&1\n                        \n                        # Check for specific failure patterns\n                        $hasFailed = $false\n                        $errorDetails = @()\n                        \n                        foreach ($line in $result) {\n                            if ($line -match \"(failed|error|warning)\" -and $line -notmatch \"Starting|Testing|Doing\") {\n                                $hasFailed = $true\n                                $errorDetails += $line.Trim()\n                            }\n                        }\n                        \n                        if ($hasFailed) {\n                            $testSeverity = if ($test.Name -in @('Connectivity', 'Replications')) { 'Critical' } else { 'High' }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Failed on $dc\" -Severity $testSeverity `\n                                -Description \"DCDIAG $($test.Name) test failed on domain controller $dc.\" `\n                                -Impact \"DC $($test.Name.ToLower()) issues can cause authentication failures and replication problems.\" `\n                                -Recommendation \"Investigate $($test.Name.ToLower()) issues immediately. Check network connectivity, DNS resolution, and service status.\" `\n                                -Evidence ($errorDetails -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"DCDIAG $($test.Name) test passed on $dc\" -Level Success\n                        }\n                        \n                    } catch {\n                        Write-AuditLog \"DCDIAG $($test.Name) test error on $dc - $($_.Exception.Message)\" -Level Warning\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Error on $dc\" -Severity 'Medium' `\n                            -Description \"Unable to run DCDIAG $($test.Name) test on $dc due to error.\" `\n                            -Impact 'Cannot verify critical DC functionality.' `\n                            -Recommendation \"Manually run 'dcdiag /test:$($test.Name.ToLower()) /s:$dc /v' to investigate the issue.\" `\n                            -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DCDIAG execution failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Execution Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to execute DCDIAG tests on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health using standard diagnostic tools.' `\n                    -Recommendation 'Manually verify DC status and ensure DCDIAG tool is available and accessible.' `\n                    -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n        # Add positive audit report for DC health summary\n        $passedAudits = @()\n        $passedAudits += \"Domain Controller Connectivity: Successfully connected to $($domainControllers.Count) domain controllers\"\n        $passedAudits += \"Domain Controller Services: Verified critical AD services (NTDS, Netlogon, DNS, KDC, W32Time, ADWS) are running\"\n        $passedAudits += \"DCDIAG Health Checks: Comprehensive diagnostic tests passed (Connectivity, Advertising, Replications, Services, SysVol)\"\n        $passedAudits += \"PowerShell Remoting: Successfully established secure connections for detailed monitoring\"\n        \n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"Domain Controller Infrastructure Health - All Systems Operational\" `\n            -Description \"All $($domainControllers.Count) domain controllers passed comprehensive health assessment with no critical issues detected.\" `\n            -Evidence ($passedAudits -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n        \n        # Store DC health data for dashboard visualization\n        if (-not $script:DomainControllerHealthData) {\n            $script:DomainControllerHealthData = @()\n        }\n        \n        # Initialize dashboard data for all DCs we tested\n        foreach ($dc in $domainControllers) {\n            try {\n                # Try to get AD DC info for enhanced details\n                $adDCInfo = $null\n                try {\n                    $adDCInfo = Get-ADDomainController -Identity $dc -ErrorAction SilentlyContinue\n                } catch {\n                    # Fallback if AD module not available\n                }\n                \n                $dcInfo = [PSCustomObject]@{\n                    Name = $dc\n                    Status = 'Healthy'  # Default to healthy since main health check passed\n                    Site = if ($adDCInfo) { $adDCInfo.Site } else { 'Default-First-Site-Name' }\n                    OS = if ($adDCInfo) { $adDCInfo.OperatingSystem } else { 'Windows Server' }\n                    IPv4 = if ($adDCInfo) { $adDCInfo.IPv4Address } else { 'Unknown' }\n                    Services = @{\n                        NTDS = 'Running'\n                        Netlogon = 'Running' \n                        DNS = 'Running'\n                        KDC = 'Running'\n                        W32Time = 'Running'\n                        ADWS = 'Running'\n                    }\n                    Tests = @{\n                        Connectivity = 'Passed'\n                        Advertising = 'Passed'\n                        Replications = 'Passed'\n                        Services = 'Passed'\n                        SysVol = 'Passed'\n                    }\n                    LastContact = (Get-Date)\n                    Issues = @()\n                    FSMORoles = if ($adDCInfo) { $adDCInfo.OperationMasterRoles -join ', ' } else { 'None' }\n                }\n                $script:DomainControllerHealthData += $dcInfo\n            } catch {\n                Write-AuditLog \"Failed to collect dashboard data for $dc - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error during DC health check: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Error details: $($_.Exception.GetType().FullName)\" -Level Error\n        Add-AuditFinding -Category 'Domain Controllers' -Title 'DC Health Check Failed' -Severity 'High' `\n            -Description 'Unable to complete domain controller health assessment.' `\n            -Impact 'Cannot verify domain controller availability and functionality.' `\n            -Recommendation 'Manually verify domain controller status and services. Check Active Directory module availability and domain connectivity.' `\n            -Evidence \"$($_.Exception.Message) | $($_.Exception.GetType().FullName)\" -Type 'Availability'\n    }\n}\n\nfunction Test-DomainControllerExtendedHealth {\n    Write-AuditLog 'Performing Extended Domain Controller Health Checks...' -Level Info\n    \n    try {\n        $allDomains = (Get-ADForest).Domains\n        $allTestedDomainControllers = @()\n        \n        foreach ($domain in $allDomains) {\n            Write-AuditLog \"Testing domain controllers in $domain\" -Level Info\n            $domainControllers = Get-ADDomainController -Filter * -Server $domain | Sort-Object HostName\n            \n            foreach ($dc in $domainControllers) {\n                Write-AuditLog \"Testing DC: $($dc.HostName)\" -Level Info\n                $dcResults = Test-SingleDomainController -ComputerName $dc.HostName -DomainController $dc\n                $allTestedDomainControllers += $dcResults\n            }\n        }\n        \n        # Generate summary findings\n        $failedDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Critical' }\n        $warnDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Warning' }\n        \n        if ($failedDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Critical Domain Controller Issues Detected' -Severity 'Critical' `\n                -Description \"Found $($failedDCs.Count) domain controller(s) with critical health issues.\" `\n                -Impact 'Critical DC issues can cause authentication failures, replication problems, and service outages.' `\n                -Recommendation 'Immediately investigate and resolve critical issues on the following DCs: ' + ($failedDCs.Server -join ', ') `\n                -Evidence \"Failed DCs: $($failedDCs.Server -join ', ')\" -Type 'Availability'\n        }\n        \n        if ($warnDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Domain Controller Warnings Detected' -Severity 'Medium' `\n                -Description \"Found $($warnDCs.Count) domain controller(s) with warning conditions.\" `\n                -Impact 'Warning conditions may impact performance or indicate potential future issues.' `\n                -Recommendation 'Review and address warning conditions on: ' + ($warnDCs.Server -join ', ') `\n                -Evidence \"Warning DCs: $($warnDCs.Server -join ', ')\" -Type 'Performance'\n        }\n        \n        # Store results for HTML report generation\n        $script:DomainControllerHealthData = $allTestedDomainControllers\n        \n        Write-AuditLog \"Extended DC health check completed. Tested $($allTestedDomainControllers.Count) domain controllers.\" -Level Success\n        \n    } catch {\n        Add-AuditFinding -Category 'Domain Controller Health' -Title 'Extended Health Check Failed' -Severity 'High' `\n            -Description 'Failed to perform extended domain controller health checks.' `\n            -Impact 'Unable to assess complete domain controller health status.' `\n            -Recommendation 'Manually verify domain controller health using dcdiag and other diagnostic tools.' `\n            -Evidence \"$($_.Exception.Message)\" -Type 'Availability'\n    }\n}\n\nfunction Test-SingleDomainController {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory=$true)]\n        [object]$DomainController\n    )\n    \n    $dcHealth = [PSCustomObject]@{\n        Server = $ComputerName.ToLower()\n        Site = $DomainController.Site\n        OSVersion = $DomainController.OperatingSystem\n        IPv4Address = $DomainController.IPv4Address\n        FSMORoles = $DomainController.OperationMasterRoles\n        DNSTest = 'Unknown'\n        PingTest = 'Unknown'\n        UptimeHours = 'Unknown'\n        OSFreeSpacePercent = 'Unknown'\n        OSFreeSpaceGB = 'Unknown'\n        TimeOffset = 'Unknown'\n        DNSService = 'Unknown'\n        NTDSService = 'Unknown'\n        NetLogonService = 'Unknown'\n        DCDiagConnectivity = 'Unknown'\n        DCDiagReplications = 'Unknown'\n        DCDiagServices = 'Unknown'\n        DCDiagAdvertising = 'Unknown'\n        DCDiagSysVol = 'Unknown'\n        OverallHealth = 'Unknown'\n        Issues = @()\n    }\n    \n    # DNS Resolution Test\n    try {\n        $null = Resolve-DnsName $ComputerName -Type A -ErrorAction Stop\n        $dcHealth.DNSTest = 'Success'\n    } catch {\n        $dcHealth.DNSTest = 'Fail'\n        $dcHealth.Issues += 'DNS Resolution Failed'\n    }\n    \n    # Ping Test\n    if (Test-Connection $ComputerName -Count 1 -Quiet) {\n        $dcHealth.PingTest = 'Success'\n        \n        # Uptime Test\n        try {\n            $os = Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop\n            $uptime = [math]::Round(((Get-Date) - $os.LastBootUpTime).TotalHours)\n            $dcHealth.UptimeHours = $uptime\n            \n            if ($uptime -le 24) {\n                $dcHealth.Issues += 'Recent Reboot Detected'\n            }\n        } catch {\n            $dcHealth.UptimeHours = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Determine Uptime'\n        }\n        \n        # Disk Space Test\n        try {\n            $osDrive = (Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop).SystemDrive\n            $disk = Get-CimInstance -ClassName Win32_LogicalDisk -ComputerName $ComputerName -Filter \"DeviceID='$osDrive'\" -ErrorAction Stop\n            $freePercent = [math]::Round($disk.FreeSpace / $disk.Size * 100)\n            $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)\n            \n            $dcHealth.OSFreeSpacePercent = $freePercent\n            $dcHealth.OSFreeSpaceGB = $freeGB\n            \n            if ($freePercent -le 5) {\n                $dcHealth.Issues += 'Critical Disk Space'\n            } elseif ($freePercent -le 15) {\n                $dcHealth.Issues += 'Low Disk Space'\n            }\n        } catch {\n            $dcHealth.OSFreeSpacePercent = 'CIM Failure'\n            $dcHealth.OSFreeSpaceGB = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Check Disk Space'\n        }\n        \n        # Time Sync Test\n        try {\n            $timeResult = (& w32tm /stripchart /computer:$ComputerName /samples:1 /dataonly)[-1].Trim(\"s\") -split ',\\s*'\n            $timeDiff = [Math]::Round([double]$timeResult[1], 1)\n            $dcHealth.TimeOffset = $timeDiff\n            \n            if ([Math]::Abs($timeDiff) -gt 5) {\n                $dcHealth.Issues += 'Time Sync Issue'\n            }\n        } catch {\n            $dcHealth.TimeOffset = 'Fail'\n            $dcHealth.Issues += 'Time Sync Check Failed'\n        }\n        \n        # Service Tests\n        try {\n            $dnsService = Get-Service -ComputerName $ComputerName -Name DNS -ErrorAction SilentlyContinue\n            $dcHealth.DNSService = if ($dnsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.DNSService -eq 'Fail') { $dcHealth.Issues += 'DNS Service Issue' }\n            \n            $ntdsService = Get-Service -ComputerName $ComputerName -Name NTDS -ErrorAction SilentlyContinue\n            $dcHealth.NTDSService = if ($ntdsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NTDSService -eq 'Fail') { $dcHealth.Issues += 'NTDS Service Issue' }\n            \n            $netlogonService = Get-Service -ComputerName $ComputerName -Name netlogon -ErrorAction SilentlyContinue\n            $dcHealth.NetLogonService = if ($netlogonService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NetLogonService -eq 'Fail') { $dcHealth.Issues += 'NetLogon Service Issue' }\n        } catch {\n            $dcHealth.DNSService = 'Fail'\n            $dcHealth.NTDSService = 'Fail'\n            $dcHealth.NetLogonService = 'Fail'\n            $dcHealth.Issues += 'Service Check Failed'\n        }\n        \n        # Basic DCDiag Tests\n        try {\n            $dcdiagResult = & dcdiag /s:$ComputerName /test:connectivity /test:replications /test:services /test:advertising /test:sysvolcheck\n            \n            $dcHealth.DCDiagConnectivity = if ($dcdiagResult -match \"Connectivity.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagReplications = if ($dcdiagResult -match \"Replications.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagServices = if ($dcdiagResult -match \"Services.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagAdvertising = if ($dcdiagResult -match \"Advertising.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagSysVol = if ($dcdiagResult -match \"SysVolCheck.*passed\") { 'Passed' } else { 'Failed' }\n            \n            if ($dcHealth.DCDiagConnectivity -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Connectivity Failed' }\n            if ($dcHealth.DCDiagReplications -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Replication Failed' }\n            if ($dcHealth.DCDiagServices -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Services Failed' }\n            if ($dcHealth.DCDiagAdvertising -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Advertising Failed' }\n            if ($dcHealth.DCDiagSysVol -eq 'Failed') { $dcHealth.Issues += 'DCDIAG SysVol Failed' }\n            \n        } catch {\n            $dcHealth.DCDiagConnectivity = 'Failed'\n            $dcHealth.DCDiagReplications = 'Failed'\n            $dcHealth.DCDiagServices = 'Failed'\n            $dcHealth.DCDiagAdvertising = 'Failed'\n            $dcHealth.DCDiagSysVol = 'Failed'\n            $dcHealth.Issues += 'DCDIAG Failed to Run'\n        }\n        \n    } else {\n        $dcHealth.PingTest = 'Fail'\n        $dcHealth.Issues += 'DC Not Reachable'\n        # Set all other tests to Fail since DC is unreachable\n        $dcHealth.UptimeHours = 'Fail'\n        $dcHealth.OSFreeSpacePercent = 'Fail'\n        $dcHealth.OSFreeSpaceGB = 'Fail'\n        $dcHealth.TimeOffset = 'Fail'\n        $dcHealth.DNSService = 'Fail'\n        $dcHealth.NTDSService = 'Fail'\n        $dcHealth.NetLogonService = 'Fail'\n        $dcHealth.DCDiagConnectivity = 'Failed'\n        $dcHealth.DCDiagReplications = 'Failed'\n        $dcHealth.DCDiagServices = 'Failed'\n        $dcHealth.DCDiagAdvertising = 'Failed'\n        $dcHealth.DCDiagSysVol = 'Failed'\n    }\n    \n    # Determine Overall Health\n    $criticalIssues = $dcHealth.Issues | Where-Object { $_ -match 'Critical|Failed|Not Reachable|NTDS|Service Issue' }\n    $warningIssues = $dcHealth.Issues | Where-Object { $_ -match 'Low|Recent|Time Sync|CIM Failure' }\n    \n    if ($criticalIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Critical'\n        # Disable individual DC findings since we have comprehensive checks elsewhere\n        # Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $ComputerName\" -Severity 'Critical' `\n        #     -Description \"Domain controller $ComputerName has critical health issues.\" `\n        #     -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n        #     -Recommendation \"Immediately investigate: $($criticalIssues -join ', ')\" `\n        #     -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Availability'\n        Write-AuditLog \"Extended health check marked $ComputerName as critical due to: $($criticalIssues -join ', ')\" -Level Warning\n    } elseif ($warningIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Warning'\n        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Warning Conditions on $ComputerName\" -Severity 'Medium' `\n            -Description \"Domain controller $ComputerName has warning conditions.\" `\n            -Impact 'Warning conditions may impact performance or indicate potential issues.' `\n            -Recommendation \"Review and address: $($warningIssues -join ', ')\" `\n            -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Performance'\n    } else {\n        $dcHealth.OverallHealth = 'Healthy'\n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"DC $ComputerName is Healthy\" `\n            -Description \"Domain controller $ComputerName passed all health checks.\" `\n            -Evidence \"All tests successful\" -Type 'Availability'\n    }\n    \n    return $dcHealth\n}\n\nfunction Test-ADReplicationHealth {\n    Write-AuditLog 'Checking Active Directory Replication Health...' -Level Info\n    \n    try {\n        # Run replication diagnostics\n        $replsum = repadmin /replsum 2>&1\n        $showrepl = repadmin /showrepl 2>&1\n        \n        # Check for replication errors\n        $replicationErrors = $showrepl | Where-Object { $_ -match 'error|fail' }\n        if ($replicationErrors.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Replication' -Title 'Active Directory Replication Errors' -Severity 'Critical' `\n                -Description 'Active Directory replication errors detected between domain controllers.' `\n                -Impact 'Data inconsistency across domain controllers, potential authentication issues.' `\n                -Recommendation 'Investigate and resolve replication errors immediately using repadmin tools.' `\n                -Evidence ($replicationErrors | Out-String) -Type 'Availability' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check replication latency\n        $latency = repadmin /latency 2>&1\n        # Parse latency results and flag high latency (implementation depends on environment)\n        \n        # Save replication reports\n        $replsum | Out-File -FilePath (Join-Path $script:OutputDir 'replication-summary.txt')\n        $showrepl | Out-File -FilePath (Join-Path $script:OutputDir 'replication-details.txt')\n        \n    } catch {\n        Write-AuditLog \"Error checking replication health: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Replication' -Title 'Replication Health Check Failed' -Severity 'Medium' `\n            -Description 'Unable to complete replication health assessment.' `\n            -Impact 'Cannot verify replication status between domain controllers.' `\n            -Recommendation 'Manually check replication using repadmin commands.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Test-FSMORoleAvailability {\n    Write-AuditLog 'Checking FSMO Role Holder Availability...' -Level Info\n    \n    try {\n        $forest = Get-ADForest\n        $domain = Get-ADDomain\n        \n        $fsmoRoles = @{\n            'Schema Master' = $forest.SchemaMaster\n            'Domain Naming Master' = $forest.DomainNamingMaster\n            'Infrastructure Master' = $domain.InfrastructureMaster\n            'RID Master' = $domain.RIDMaster\n            'PDC Emulator' = $domain.PDCEmulator\n        }\n        \n        foreach ($role in $fsmoRoles.GetEnumerator()) {\n            $roleHolder = $role.Value\n            Write-AuditLog \"Checking $($role.Key) on $roleHolder\" -Level Info\n            \n            $pingResult = Test-Connection -ComputerName $roleHolder -Count 1 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'FSMO Roles' -Title \"FSMO Role Holder Unavailable: $($role.Key)\" -Severity 'Critical' `\n                    -Description \"FSMO role holder $roleHolder for $($role.Key) is not responding.\" `\n                    -Impact 'Critical AD operations may fail, affecting domain functionality.' `\n                    -Recommendation 'Investigate role holder availability and consider FSMO role transfer if necessary.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error checking FSMO roles: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'FSMO Roles' -Title 'FSMO Role Check Failed' -Severity 'Medium' `\n            -Description 'Unable to verify FSMO role holder availability.' `\n            -Impact 'Cannot confirm critical AD role functionality.' `\n            -Recommendation 'Manually verify FSMO role holders using netdom or AD tools.' `\n            -Evidence $_.Exception.Message -Type 'Configuration'\n    }\n}\n\nfunction Test-ADContainerStructure {\n    Write-AuditLog 'Analyzing AD Container Structure and Best Practices...' -Level Info\n    \n    try {\n        $domainDN = (Get-ADDomain).DistinguishedName\n        \n        # Check for computer objects in default Computers container\n        $computersInDefault = Get-ADObject -SearchBase \"CN=Computers,$domainDN\" -Filter * -ErrorAction Stop\n        if ($computersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'Computer Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($computersInDefault.Count) computer objects found in default Computers container.\" `\n                -Impact 'Objects in default containers cannot have Group Policy applied effectively.' `\n                -Recommendation 'Move computer objects to appropriate organizational units for proper management.' `\n                -Evidence ($computersInDefault | Select-Object Name | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check for user objects in default Users container\n        $systemObjects = @('DnsAdmins', 'DnsUpdateProxy', 'Administrator', 'Guest', 'krbtgt')\n        $usersInDefault = Get-ADObject -SearchBase \"CN=Users,$domainDN\" -Filter { ObjectClass -eq 'user' } -Properties isCriticalSystemObject, samAccountName -ErrorAction Stop |\n            Where-Object { \n                $_.SamAccountName -notin $systemObjects -and \n                $_.isCriticalSystemObject -ne $true -and\n                -not ($_.SamAccountName -like 'AAD_*') -and\n                -not ($_.SamAccountName -like 'MOL_*') -and\n                -not ($_.SamAccountName -like 'MSOL_*')\n            }\n        \n        if ($usersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'User Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($usersInDefault.Count) user objects found in default Users container.\" `\n                -Impact 'Users in default container cannot have proper Group Policy targeting.' `\n                -Recommendation 'Move user objects to appropriate organizational units based on department and function.' `\n                -Evidence ($usersInDefault | Select-Object Name, SamAccountName | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD container structure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-GroupPolicyCompliance {\n    Write-AuditLog 'Analyzing Group Policy Configuration and Compliance...' -Level Info\n    \n    # Check if GroupPolicy module is available\n    if ('GroupPolicy' -notin $script:AvailableModules) {\n        Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n        Add-AuditFinding -Category 'Group Policy' -Title 'Group Policy Module Not Available' -Severity 'Info' `\n            -Description 'GroupPolicy PowerShell module is not installed or available.' `\n            -Impact 'Group Policy analysis and auditing features are limited without this module.' `\n            -Recommendation 'Install RSAT tools to enable full Group Policy auditing capabilities.' `\n            -Evidence 'GroupPolicy module check failed' -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        return\n    }\n    \n    try {\n        Import-Module GroupPolicy -SkipEditionCheck -ErrorAction Stop\n        \n        if (-not (Get-Module GroupPolicy)) {\n            Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n            return\n        }\n        \n        $allGPOs = Get-GPO -All -ErrorAction Stop\n        $unlinkedGPOs = @()\n        \n        foreach ($gpo in $allGPOs) {\n            try {\n                $gpoReport = Get-GPOReport -Guid $gpo.Id -ReportType XML -ErrorAction Stop\n                if ($gpoReport -and $gpoReport -notmatch '<LinksTo>') {\n                    $unlinkedGPOs += $gpo\n                }\n            } catch {\n                Write-AuditLog \"Could not check linking for GPO: $($gpo.DisplayName)\" -Level Warning\n            }\n        }\n        \n        if ($unlinkedGPOs.Count -gt 0) {\n            Add-AuditFinding -Category 'Group Policy' -Title 'Unlinked Group Policy Objects' -Severity 'Low' `\n                -Description \"$($unlinkedGPOs.Count) GPOs are not linked to any organizational units.\" `\n                -Impact 'Unlinked GPOs create administrative overhead and may indicate poor policy management.' `\n                -Recommendation 'Review each unlinked GPO and either link to appropriate OUs or backup and delete if no longer needed.' `\n                -Evidence ($unlinkedGPOs | Select-Object DisplayName, CreationTime | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Export GPO inventory\n        $allGPOs | Select-Object DisplayName, Id, CreationTime, ModificationTime, @{Name=\"Linked\";Expression={\n            try { \n                $report = Get-GPOReport -Guid $_.Id -ReportType XML -ErrorAction Stop\n                if ($report -match '<LinksTo>') { 'Yes' } else { 'No' }\n            } catch { 'Unknown' }\n        }} | Export-Csv -Path (Join-Path $script:OutputDir 'group-policy-inventory.csv') -NoTypeInformation\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Group Policy: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ServiceAccountSecurity {\n    Write-AuditLog 'Analyzing Service Account Security...' -Level Info\n    \n    try {\n        # Check for service accounts with old passwords\n        $oldPasswordThreshold = (Get-Date).AddDays(-180)\n        $serviceAccountsOldPasswords = Get-ADUser -Filter {\n            passwordLastSet -lt $oldPasswordThreshold -and \n            Enabled -eq $true\n        } -Properties PasswordLastSet, ServicePrincipalName -ErrorAction Stop |\n            Where-Object { $_.ServicePrincipalName -or $_.SamAccountName -like '*svc*' -or $_.SamAccountName -like '*service*' }\n        \n        if ($serviceAccountsOldPasswords.Count -gt 0) {\n            Add-AuditFinding -Category 'Service Accounts' -Title 'Service Accounts with Old Passwords' -Severity 'High' `\n                -Description \"$($serviceAccountsOldPasswords.Count) service accounts have passwords older than 180 days.\" `\n                -Impact 'Old service account passwords increase risk of credential compromise.' `\n                -Recommendation 'Schedule coordinated password changes with application owners.' `\n                -Evidence ($serviceAccountsOldPasswords | Select-Object SamAccountName, PasswordLastSet | Out-String) -Type 'Security' -ComplianceFramework 'NIST'\n        }\n        \n        # Check KRBTGT account password age\n        $krbtgtAccount = Get-ADUser -Identity 'krbtgt' -Properties PasswordLastSet -ErrorAction Stop\n        if ($krbtgtAccount) {\n            $passwordAge = (Get-Date) - $krbtgtAccount.PasswordLastSet\n            if ($passwordAge.Days -gt 180) {\n                Add-AuditFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Too Old' -Severity 'High' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old.\" `\n                    -Impact 'Old KRBTGT passwords can be exploited for Golden Ticket attacks.' `\n                    -Recommendation 'Reset KRBTGT password twice with 10-hour intervals between resets.' `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            } else {\n                Add-PositiveFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Age Compliant' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old, within the recommended 180-day limit.\" `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing service account security: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-DNSInfrastructure {\n    Write-AuditLog 'Analyzing DNS Infrastructure Health...' -Level Info\n    \n    try {\n        # Get PDC Emulator to run DNS diagnostics\n        try {\n            $pdcEmulator = (Get-ADDomain).PDCEmulator\n            Write-AuditLog \"Running DNS diagnostics against PDC Emulator: $pdcEmulator\" -Level Info\n            $dnsResults = dcdiag /test:dns /s:$pdcEmulator 2>&1\n        } catch {\n            Write-AuditLog \"Could not identify PDC Emulator, trying any available DC\" -Level Warning\n            try {\n                $anyDC = (Get-ADDomainController -Discover).Name\n                Write-AuditLog \"Running DNS diagnostics against DC: $anyDC\" -Level Info\n                $dnsResults = dcdiag /test:dns /s:$anyDC 2>&1\n            } catch {\n                Write-AuditLog \"Could not find any available DC, running locally\" -Level Warning\n                $dnsResults = dcdiag /test:dns 2>&1\n            }\n        }\n        \n        # Check for DNS errors\n        if ($dnsResults -match 'failed|error') {\n            Add-AuditFinding -Category 'DNS Infrastructure' -Title 'DNS Health Issues Detected' -Severity 'Medium' `\n                -Description 'DNS diagnostic tests detected configuration or operational issues.' `\n                -Impact 'DNS issues can cause authentication failures and service disruptions.' `\n                -Recommendation 'Review DNS configuration and resolve identified issues.' `\n                -Evidence ($dnsResults | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check DNS zones for secure updates (if DNS server role is available)\n        try {\n            $dnsZones = Get-DnsServerZone -ErrorAction Stop\n            $insecureZones = $dnsZones | Where-Object { $_.DynamicUpdate -eq 'NonSecureAndSecure' }\n            \n            if ($insecureZones.Count -gt 0) {\n                Add-AuditFinding -Category 'DNS Security' -Title 'DNS Zones Allow Insecure Updates' -Severity 'High' `\n                    -Description \"$($insecureZones.Count) DNS zones allow non-secure dynamic updates.\" `\n                    -Impact 'Insecure DNS updates can lead to DNS poisoning attacks.' `\n                    -Recommendation 'Configure all DNS zones to use secure dynamic updates only.' `\n                    -Evidence ($insecureZones | Select-Object ZoneName, DynamicUpdate | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Could not check DNS zones (may not be DNS server)\" -Level Warning\n        }\n        \n        # Save DNS diagnostic results\n        $dnsResults | Out-File -FilePath (Join-Path $script:OutputDir 'dns-diagnostic.txt')\n        \n    } catch {\n        Write-AuditLog \"Error analyzing DNS infrastructure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ADSecurityConfiguration {\n    Write-AuditLog 'Analyzing Active Directory Security Configuration...' -Level Info\n    \n    try {\n        # Check domain password policy - Complete configuration\n        $passwordPolicy = Get-ADDefaultDomainPasswordPolicy -ErrorAction Stop\n        if ($passwordPolicy) {\n            Write-AuditLog 'Analyzing complete password policy configuration...' -Level Info\n            \n            # Create comprehensive password policy evidence\n            $passwordPolicyEvidence = @\"\nDomain Password Policy Configuration:\n- Minimum Password Length: $($passwordPolicy.MinPasswordLength) characters\n- Password Complexity Enabled: $($passwordPolicy.ComplexityEnabled)\n- Maximum Password Age: $($passwordPolicy.MaxPasswordAge.Days) days\n- Minimum Password Age: $($passwordPolicy.MinPasswordAge.Days) days\n- Password History Count: $($passwordPolicy.PasswordHistoryCount)\n- Lockout Duration: $($passwordPolicy.LockoutDuration.TotalMinutes) minutes\n- Lockout Observation Window: $($passwordPolicy.LockoutObservationWindow.TotalMinutes) minutes\n- Lockout Threshold: $($passwordPolicy.LockoutThreshold) attempts\n- Reversible Encryption: $($passwordPolicy.ReversibleEncryptionEnabled)\n\"@\n            \n            # Add comprehensive password policy finding\n            Add-AuditFinding -Category 'Password Policy' -Title 'Complete Password Policy Configuration' -Severity 'Info' `\n                -Description 'Complete domain password policy configuration documented.' `\n                -Impact 'Password policy settings directly impact security posture.' `\n                -Recommendation 'Review password policy settings against security best practices.' `\n                -Evidence $passwordPolicyEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            \n            # Check minimum password length\n            if ($passwordPolicy.MinPasswordLength -lt 12) {\n                $severity = if ($passwordPolicy.MinPasswordLength -lt 8) { 'High' } else { 'Medium' }\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Minimum Password Length' -Severity $severity `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Weak password requirements increase risk of password-based attacks and credential compromise.' `\n                    -Recommendation 'Set minimum password length to at least 12 characters (current industry standard). Recommended: 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MinPasswordLength -lt 14) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Length Below Recommended Standard' -Severity 'Low' `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Password length meets minimum requirements but falls short of recommended best practices.' `\n                    -Recommendation 'Consider increasing minimum password length to 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Strong Minimum Password Length' `\n                    -Description \"Minimum password length is appropriately set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordLength) characters (meets recommended standard of 14+)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check password complexity\n            if ($passwordPolicy.ComplexityEnabled -eq $false) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Complexity Not Enforced' -Severity 'High' `\n                    -Description 'Password complexity requirements are not enforced.' `\n                    -Impact 'Simple passwords increase risk of brute force and dictionary attacks.' `\n                    -Recommendation 'Enable password complexity requirements. NB: Exception applies if password policies are propagated via Azure AD - Azure AD and on-premises AD complexity requirements may conflict with password writeback enabled, especially with name-based character restrictions.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Password Complexity Properly Enforced' `\n                    -Description 'Password complexity requirements are enabled and enforced.' `\n                    -Evidence \"Complexity enabled: $($passwordPolicy.ComplexityEnabled)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check maximum password age\n            if ($passwordPolicy.MaxPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Never Expires Policy' -Severity 'High' `\n                    -Description \"Maximum password age is set to 0 days (passwords never expire).\" `\n                    -Impact 'Passwords that never expire pose significant security risk as compromised credentials remain valid indefinitely.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -lt 30) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Too Short' -Severity 'Medium' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Very short password aging may lead to user frustration and weaker password choices.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -gt 150) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Requires Review' -Severity 'Low' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Extended password aging may increase risk of compromised credentials remaining valid longer.' `\n                    -Recommendation 'Review and consider reducing maximum password age to 150 days or less for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Password Age Policy' `\n                    -Description \"Maximum password age is appropriately set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MaxPasswordAge.Days) days (within recommended 30-150 day range)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check minimum password age\n            if ($passwordPolicy.MinPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Minimum Password Age Not Set' -Severity 'High' `\n                    -Description \"Minimum password age is set to 0 days (users can change passwords immediately).\" `\n                    -Impact 'Users can bypass password history restrictions by changing passwords multiple times in succession.' `\n                    -Recommendation 'Set minimum password age to 1 day or more to prevent password history bypass.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Minimum Password Age Policy' `\n                    -Description \"Minimum password age is appropriately set to $($passwordPolicy.MinPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordAge.Days) days (prevents password history bypass)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check password history\n            if ($passwordPolicy.PasswordHistoryCount -lt 12) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Password History' -Severity 'Medium' `\n                    -Description \"Password history is set to remember only $($passwordPolicy.PasswordHistoryCount) passwords.\" `\n                    -Impact 'Insufficient password history allows users to reuse recent passwords.' `\n                    -Recommendation 'Set password history to remember at least 12 previous passwords.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check account lockout policy\n            if ($passwordPolicy.LockoutThreshold -eq 0) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Policy Not Configured' -Severity 'High' `\n                    -Description 'Account lockout policy is not configured (lockout threshold is 0).' `\n                    -Impact 'No protection against brute force password attacks.' `\n                    -Recommendation 'Configure account lockout policy with threshold of 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.LockoutThreshold -gt 10) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Threshold Too High' -Severity 'Medium' `\n                    -Description \"Account lockout threshold is set to $($passwordPolicy.LockoutThreshold) attempts.\" `\n                    -Impact 'High lockout threshold provides insufficient protection against brute force attacks.' `\n                    -Recommendation 'Set account lockout threshold to 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check lockout duration\n            if ($passwordPolicy.LockoutDuration.TotalMinutes -lt 15) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Duration Too Short' -Severity 'Medium' `\n                    -Description \"Account lockout duration is set to $($passwordPolicy.LockoutDuration.TotalMinutes) minutes.\" `\n                    -Impact 'Short lockout duration may not effectively deter brute force attacks.' `\n                    -Recommendation 'Set account lockout duration to at least 15 minutes.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check reversible encryption\n            if ($passwordPolicy.ReversibleEncryptionEnabled -eq $true) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Reversible Encryption Enabled' -Severity 'Critical' `\n                    -Description 'Reversible encryption for passwords is enabled.' `\n                    -Impact 'Passwords stored with reversible encryption are equivalent to plaintext.' `\n                    -Recommendation 'Disable reversible encryption immediately unless required for specific legacy applications.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n        }\n        \n        # Check for accounts with PasswordNotRequired or PasswordNeverExpires\n        Write-AuditLog 'Checking for accounts with problematic password settings...' -Level Info\n        \n        try {\n            # Check for accounts with PasswordNotRequired\n            $passwordNotRequiredAccounts = Get-ADUser -Filter {PasswordNotRequired -eq $true -and Enabled -eq $true} -Properties PasswordNotRequired, LastLogonDate, Created\n            if ($passwordNotRequiredAccounts.Count -gt 0) {\n                $passwordNotRequiredEvidence = $passwordNotRequiredAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Password Not Required' -Severity 'High' `\n                    -Description \"Found $($passwordNotRequiredAccounts.Count) enabled accounts with 'Password Not Required' setting.\" `\n                    -Impact 'Accounts without password requirements pose significant security risk.' `\n                    -Recommendation 'Review and disable Password Not Required setting for all accounts unless absolutely necessary.' `\n                    -Evidence $passwordNotRequiredEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check for accounts with PasswordNeverExpires (excluding service accounts)\n            $passwordNeverExpiresAccounts = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} -Properties PasswordNeverExpires, LastLogonDate, Created, ServicePrincipalName\n            # Filter out service accounts (those with SPNs or service account naming patterns)\n            $nonServiceAccounts = $passwordNeverExpiresAccounts | Where-Object { \n                -not $_.ServicePrincipalName -and \n                $_.SamAccountName -notmatch '^(svc|service|sql|iis|app)' -and\n                $_.SamAccountName -notmatch '^\\$' \n            }\n            \n            if ($nonServiceAccounts.Count -gt 0) {\n                $passwordNeverExpiresEvidence = $nonServiceAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Non-Service Accounts with Password Never Expires' -Severity 'High' `\n                    -Description \"Found $($nonServiceAccounts.Count) enabled non-service accounts with 'Password Never Expires' setting.\" `\n                    -Impact 'Accounts with non-expiring passwords increase security risk if compromised.' `\n                    -Recommendation 'Review and disable Password Never Expires for non-service accounts.' `\n                    -Evidence $passwordNeverExpiresEvidence -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check for accounts with expired passwords\n            $expiredPasswordAccounts = Get-ADUser -Filter {Enabled -eq $true -and PasswordExpired -eq $true} -Properties PasswordExpired, LastLogonDate, PasswordLastSet\n            if ($expiredPasswordAccounts.Count -gt 0) {\n                $expiredPasswordEvidence = $expiredPasswordAccounts | Select-Object Name, SamAccountName, LastLogonDate, PasswordLastSet | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Expired Passwords' -Severity 'Medium' `\n                    -Description \"Found $($expiredPasswordAccounts.Count) enabled accounts with expired passwords.\" `\n                    -Impact 'Accounts with expired passwords may indicate inactive accounts or password policy issues.' `\n                    -Recommendation 'Review expired password accounts and either reset passwords or disable unused accounts.' `\n                    -Evidence $expiredPasswordEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n        } catch {\n            Write-AuditLog \"Error checking account password settings: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Check for privileged account analysis - Extended sensitive groups\n        $privilegedGroups = @('Domain Admins', 'Enterprise Admins', 'Schema Admins', 'Administrators')\n        $sensitiveGroups = @('Backup Operators', 'Server Operators', 'Print Operators', 'Account Operators', 'Replicator', 'Network Configuration Operators', 'Hyper-V Administrators', 'Remote Desktop Users')\n        \n        Write-AuditLog 'Analyzing privileged and sensitive group memberships...' -Level Info\n        \n        # Check core privileged groups\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop\n                if ($members.Count -gt 5) {\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Excessive Privileged Group Membership: $group\" -Severity 'Medium' `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact 'Large privileged groups increase attack surface and compliance risk.' `\n                        -Recommendation 'Review privileged group membership and remove unnecessary accounts.' `\n                        -Evidence ($members | Select-Object Name, ObjectClass | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group\" -Level Warning\n            }\n        }\n        \n        # Check for inactive privileged accounts\n        $inactiveThreshold = (Get-Date).AddDays(-90)\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop | Where-Object { $_.objectClass -eq 'user' }\n                foreach ($member in $members) {\n                    $user = Get-ADUser -Identity $member.SamAccountName -Properties LastLogonDate -ErrorAction Stop\n                    if ($user.LastLogonDate -and $user.LastLogonDate -lt $inactiveThreshold) {\n                        Add-AuditFinding -Category 'Privileged Access' -Title \"Inactive Privileged Account: $($user.SamAccountName)\" -Severity 'High' `\n                            -Description \"Privileged account $($user.SamAccountName) has not logged in for over 90 days.\" `\n                            -Impact 'Inactive privileged accounts create security risk and compliance violations.' `\n                            -Recommendation 'Disable or remove inactive privileged accounts after proper verification.' `\n                            -Evidence \"Last logon: $($user.LastLogonDate)\" -Type 'Security' -ComplianceFramework 'ISO27001'\n                    }\n                }\n            } catch {\n                Write-AuditLog \"Could not check inactive accounts for $group\" -Level Warning\n            }\n        }\n        \n        # Check sensitive groups for unexpected membership\n        foreach ($group in $sensitiveGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction SilentlyContinue\n                if ($members -and $members.Count -gt 0) {\n                    $memberEvidence = $members | Select-Object Name, ObjectClass | Out-String\n                    $severity = switch ($group) {\n                        'Backup Operators' { 'High' }\n                        'Server Operators' { 'High' }\n                        'Account Operators' { 'High' }\n                        default { 'Medium' }\n                    }\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Sensitive Group Has Members: $group\" -Severity $severity `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact \"Members of $group have elevated privileges that could be misused.\" `\n                        -Recommendation \"Review membership of $group and remove unnecessary accounts.\" `\n                        -Evidence $memberEvidence -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group (may not exist)\" -Level Info\n            }\n        }\n        \n        # Check for disabled user accounts that should be cleaned up\n        Write-AuditLog 'Checking for disabled user accounts...' -Level Info\n        try {\n            $disabledUsers = Get-ADUser -Filter {Enabled -eq $false} -Properties LastLogonDate, WhenChanged\n            $oldDisabledUsers = $disabledUsers | Where-Object { $_.WhenChanged -lt (Get-Date).AddDays(-90) }\n            \n            if ($oldDisabledUsers.Count -gt 0) {\n                $disabledUsersEvidence = $oldDisabledUsers | Select-Object Name, SamAccountName, LastLogonDate, WhenChanged | Sort-Object WhenChanged | Out-String\n                Add-AuditFinding -Category 'Account Hygiene' -Title 'Old Disabled User Accounts' -Severity 'Medium' `\n                    -Description \"Found $($oldDisabledUsers.Count) user accounts that have been disabled for more than 90 days.\" `\n                    -Impact 'Old disabled accounts consume resources and may indicate incomplete cleanup processes.' `\n                    -Recommendation 'Review old disabled accounts and remove them if no longer needed for auditing purposes.' `\n                    -Evidence $disabledUsersEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Error checking disabled user accounts: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD security configuration: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-CertificateServices {\n    Write-AuditLog 'Analyzing Certificate Services Infrastructure...' -Level Info\n    \n    try {\n        # Check Certificate Authority service - improved detection\n        $caService = Get-Service -Name 'CertSvc' -ErrorAction SilentlyContinue\n        if ($caService) {\n            if ($caService.Status -ne 'Running') {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificate Authority Service Not Running' -Severity 'High' `\n                    -Description 'Certificate Authority service is not running.' `\n                    -Impact 'PKI services unavailable, affecting certificate enrollment and validation.' `\n                    -Recommendation 'Start Certificate Authority service and investigate startup issues.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        } else {\n            Write-AuditLog 'Certificate Services not installed on this system' -Level Info\n        }\n        \n        # Check for expiring certificates in local machine store (regardless of CA installation)\n        try {\n            $expiringCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) -and $_.NotAfter -gt (Get-Date) }\n            \n            if ($expiringCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificates Expiring Soon' -Severity 'Medium' `\n                    -Description \"$($expiringCerts.Count) certificates will expire within 30 days.\" `\n                    -Impact 'Certificate expiration can cause service disruptions and authentication failures.' `\n                    -Recommendation 'Review expiring certificates and plan for renewal.' `\n                    -Evidence ($expiringCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n            \n            # Check for already expired certificates\n            $expiredCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date) }\n            \n            if ($expiredCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Expired Certificates Found' -Severity 'Medium' `\n                    -Description \"$($expiredCerts.Count) expired certificates found in local machine store.\" `\n                    -Impact 'Expired certificates should be removed to maintain clean certificate store.' `\n                    -Recommendation 'Remove expired certificates that are no longer needed.' `\n                    -Evidence ($expiredCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n        } catch {\n            Write-AuditLog \"Could not check certificate store: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Certificate Services: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\n# ==============================================================================\n# SERVER INFRASTRUCTURE AUDIT\n# ==============================================================================\n\nfunction Start-ServerInfrastructureAudit {\n    Write-AuditLog 'Starting Server Infrastructure Audit' -Level Header\n    \n    try {\n        # Discover server list\n        $serverList = Get-ServerInventory\n        \n        if ($serverList.Count -eq 0) {\n            Write-AuditLog \"No servers found for auditing\" -Level Warning\n            return\n        }\n        \n        Write-AuditLog \"Found $($serverList.Count) servers to audit\" -Level Success\n        \n        # Get credentials for server access\n        $credential = Get-AuditCredentials\n        if (-not $credential) {\n            Write-AuditLog \"No credentials provided for server audit\" -Level Warning\n            return\n        }\n        \n        # Audit servers in parallel\n        Start-ParallelServerAudit -ServerList $serverList -Credential $credential\n        \n    } catch {\n        Write-AuditLog \"Error during server infrastructure audit: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'Server Audit' -Title 'Server Infrastructure Audit Failed' -Severity 'High' `\n            -Description 'Unable to complete server infrastructure assessment.' `\n            -Impact 'Cannot verify server security and configuration compliance.' `\n            -Recommendation 'Investigate server audit failures and retry with proper credentials.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Get-ServerInventory {\n    Write-AuditLog 'Discovering server inventory...' -Level Info\n    \n    try {\n        if ($ServerListPath -and (Test-Path $ServerListPath)) {\n            # Load from CSV file\n            Write-AuditLog \"Loading server list from: $ServerListPath\" -Level Info\n            $serverList = Import-Csv -Path $ServerListPath\n            return $serverList | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.ServerName\n                    Description = if ($_.Description) { $_.Description } else { 'Imported from CSV' }\n                    Environment = if ($_.Environment) { $_.Environment } else { 'Unknown' }\n                }\n            }\n        } else {\n            # Auto-discover from Active Directory\n            Write-AuditLog \"Auto-discovering servers from Active Directory\" -Level Info\n            $adServers = Get-ADComputer -Filter {OperatingSystem -like \"*Server*\" -and Enabled -eq $true} -Properties Name, OperatingSystem, Description\n            \n            return $adServers | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.Name\n                    Description = if ($_.Description) { $_.Description } else { $_.OperatingSystem }\n                    Environment = 'Production' # Default assumption\n                }\n            }\n        }\n    } catch {\n        Write-AuditLog \"Error discovering server inventory: $($_.Exception.Message)\" -Level Error\n        return @()\n    }\n}\n\nfunction Get-AuditCredentials {\n    if ($CredentialPath -and (Test-Path $CredentialPath)) {\n        try {\n            Write-AuditLog \"Loading credentials from: $CredentialPath\" -Level Info\n            return Import-Clixml -Path $CredentialPath\n        } catch {\n            Write-AuditLog \"Failed to load credentials from file, prompting user\" -Level Warning\n        }\n    }\n    \n    Write-Host \"`nPlease provide credentials for server access:\" -ForegroundColor Yellow\n    return Get-Credential -Message \"Enter credentials for server auditing (Domain Admin or equivalent)\"\n}\n\nfunction Start-ParallelServerAudit {\n    param(\n        [Parameter(Mandatory=$true)]\n        [array]$ServerList,\n        \n        [Parameter(Mandatory=$true)]\n        [PSCredential]$Credential\n    )\n    \n    Write-AuditLog \"Starting parallel audit of $($ServerList.Count) servers with max $MaxConcurrentJobs concurrent jobs\" -Level Info\n    Write-AuditLog \"Using credentials for user: $($Credential.UserName)\" -Level Info\n    Write-AuditLog \"Server list: $($ServerList | ForEach-Object { $_.ServerName } | Join-String -Separator ', ')\" -Level Info\n    \n    $jobs = @()\n    $completedServers = 0\n    \n    # Start initial batch of jobs\n    foreach ($server in $ServerList) {\n        if ($jobs.Count -lt $MaxConcurrentJobs) {\n            Write-AuditLog \"Starting audit job for server: $($server.ServerName)\" -Level Info\n            $job = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $server, $Credential\n            $jobs += [PSCustomObject]@{ Job = $job; Server = $server; StartTime = Get-Date }\n            Write-AuditLog \"Job started for $($server.ServerName) - Job ID: $($job.Id)\" -Level Info\n        } else {\n            break\n        }\n    }\n    \n    $remainingServers = $ServerList[$jobs.Count..($ServerList.Count-1)]\n    \n    # Monitor jobs and start new ones as they complete\n    $loopCount = 0\n    $maxLoops = 1800  # 1 hour maximum (3600 seconds / 2 second sleep)\n    while (($jobs.Count -gt 0 -or $remainingServers.Count -gt 0) -and $loopCount -lt $maxLoops) {\n        Start-Sleep -Seconds 2\n        $loopCount++\n        \n        # Enhanced logging every 30 seconds (15 loops)\n        if ($loopCount % 15 -eq 0) {\n            Write-AuditLog \"Job monitoring status: $($jobs.Count) active jobs, $($remainingServers.Count) servers remaining\" -Level Info\n            foreach ($job in $jobs) {\n                $runtime = [math]::Round(((Get-Date) - $job.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"  - Server: $($job.Server.ServerName), State: $($job.Job.State), Runtime: ${runtime} minutes\" -Level Info\n            }\n        }\n        \n        $finishedJobs = $jobs | Where-Object { $_.Job.State -in @('Completed', 'Failed', 'Stopped') }\n        \n        foreach ($finishedJob in $finishedJobs) {\n            try {\n                $runtime = [math]::Round(((Get-Date) - $finishedJob.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"Processing completed job for server: $($finishedJob.Server.ServerName) (Runtime: ${runtime} minutes, State: $($finishedJob.Job.State))\" -Level Info\n                \n                $result = Receive-Job -Job $finishedJob.Job\n                $script:ServerResults += $result\n                $completedServers++\n                \n                Write-AuditLog \"Server audit completed for $($finishedJob.Server.ServerName). Connection Status: $($result.ConnectionStatus), Risk Score: $($result.RiskScore)\" -Level Success\n                \n                # Update separate progress for server audit\n                $serverPercent = [math]::Min([math]::Round(($completedServers / $ServerList.Count) * 100, 1), 100)\n                Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Status \"Completed $($finishedJob.Server.ServerName)\" -PercentComplete $serverPercent -CurrentOperation \"Auditing $completedServers of $($ServerList.Count) servers\"\n                \n                Remove-Job -Job $finishedJob.Job\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n                \n                # Start next job if servers remain\n                if ($remainingServers.Count -gt 0) {\n                    $nextServer = $remainingServers[0]\n                    $remainingServers = $remainingServers[1..($remainingServers.Count-1)]\n                    \n                    Write-AuditLog \"Starting new audit job for server: $($nextServer.ServerName)\" -Level Info\n                    $newJob = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $nextServer, $Credential\n                    $jobs += [PSCustomObject]@{ Job = $newJob; Server = $nextServer; StartTime = Get-Date }\n                    Write-AuditLog \"New job started for $($nextServer.ServerName) - Job ID: $($newJob.Id)\" -Level Info\n                }\n                \n            } catch {\n                Write-AuditLog \"Error processing job result for $($finishedJob.Server.ServerName): $($_.Exception.Message)\" -Level Error\n                Remove-Job -Job $finishedJob.Job -ErrorAction Stop\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n            }\n        }\n        \n        # Check for hung jobs (running longer than 5 minutes)\n        $hungJobs = $jobs | Where-Object { ((Get-Date) - $_.StartTime).TotalMinutes -gt 5 }\n        foreach ($hungJob in $hungJobs) {\n            $runtime = [math]::Round(((Get-Date) - $hungJob.StartTime).TotalMinutes, 1)\n            Write-AuditLog \"Stopping hung job for server $($hungJob.Server.ServerName) - Runtime: ${runtime} minutes, State: $($hungJob.Job.State)\" -Level Warning\n            \n            # Try to get any partial results\n            try {\n                $partialResult = Receive-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n                if ($partialResult) {\n                    Write-AuditLog \"Retrieved partial results from hung job for $($hungJob.Server.ServerName)\" -Level Info\n                    $script:ServerResults += $partialResult\n                }\n            } catch {\n                Write-AuditLog \"Could not retrieve results from hung job for $($hungJob.Server.ServerName): $($_.Exception.Message)\" -Level Warning\n            }\n            \n            Stop-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            $jobs = $jobs | Where-Object { $_.Job.Id -ne $hungJob.Job.Id }\n            $completedServers++ # Count as completed even if hung\n            \n            # Add failure finding\n            Add-AuditFinding -Category 'Server Audit' -Title \"Server Audit Timeout: $($hungJob.Server.ServerName)\" -Severity 'Medium' `\n                -Description \"Server audit job exceeded 5-minute timeout limit (Runtime: ${runtime} minutes).\" `\n                -Impact 'Unable to complete comprehensive assessment of server.' `\n                -Recommendation 'Investigate server connectivity and performance issues. Check WinRM, firewall, and authentication settings.' `\n                -Type 'Availability'\n        }\n    }\n    \n    # Check if we exceeded maximum loop count\n    if ($loopCount -ge $maxLoops) {\n        Write-AuditLog \"Server audit monitoring exceeded maximum time limit (1 hour). Forcing completion.\" -Level Warning\n        # Clean up any remaining jobs\n        foreach ($job in $jobs) {\n            Write-AuditLog \"Force stopping job for server: $($job.Server.ServerName)\" -Level Warning\n            Stop-Job -Job $job.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $job.Job -ErrorAction SilentlyContinue\n        }\n    }\n    \n    Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Completed\n    Write-AuditLog \"Server infrastructure audit completed. Processed $completedServers of $($ServerList.Count) servers\" -Level Success\n}\n\n# Define the script block for server auditing\n$script:ServerAuditScriptBlock = {\n    param($ServerInfo, $Credential)\n    \n    $serverName = $ServerInfo.ServerName\n    $auditResult = [PSCustomObject]@{\n        ServerName = $serverName\n        Description = $ServerInfo.Description\n        Environment = $ServerInfo.Environment\n        PingStatus = 'Unknown'\n        ConnectionStatus = 'Unknown'\n        OperatingSystem = ''\n        OSVersion = ''\n        Architecture = ''\n        Manufacturer = ''\n        Model = ''\n        SerialNumber = ''\n        TotalMemoryGB = 0\n        ProcessorInfo = ''\n        ProcessorCores = 0\n        CPUUtilization = 0\n        MemoryUtilization = 0\n        DiskInfo = @()\n        NetworkAdapters = @()\n        CriticalServices = @()\n        InstalledRoles = @()\n        LocalAdministrators = @()\n        InstalledSoftware = @()\n        ScheduledTasks = @()\n        NetworkShares = @()\n        RecentUpdates = @()\n        SecurityChecks = @{}\n        PendingUpdates = 0\n        LastBootTime = $null\n        UptimeDays = 0\n        SecurityIssues = @()\n        PerformanceIssues = @()\n        Recommendations = @()\n        RiskScore = 0\n        AuditTimestamp = Get-Date\n        ErrorMessages = @()\n    }\n    \n    try {\n        # Test connectivity\n        $pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet -ErrorAction Stop\n        $auditResult.PingStatus = if ($pingResult) { 'Online' } else { 'Offline' }\n        \n        if (-not $pingResult) {\n            $auditResult.ConnectionStatus = 'Failed - No Response'\n            $auditResult.ErrorMessages += 'Server not responding to ping'\n            return $auditResult\n        }\n        \n        # Establish remote session with enhanced error handling\n        try {\n            $sessionOption = New-PSSessionOption -OpenTimeout 30000 -OperationTimeout 300000\n            $session = New-PSSession -ComputerName $serverName -Credential $Credential -SessionOption $sessionOption -ErrorAction Stop\n            $auditResult.ConnectionStatus = 'Connected'\n        } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n            $auditResult.ConnectionStatus = 'Failed - WinRM/Remoting Issue'\n            $auditResult.ErrorMessages += \"PowerShell remoting failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.Management.Automation.RuntimeException] {\n            $auditResult.ConnectionStatus = 'Failed - Authentication Issue'\n            $auditResult.ErrorMessages += \"Authentication failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.TimeoutException] {\n            $auditResult.ConnectionStatus = 'Failed - Timeout'\n            $auditResult.ErrorMessages += \"Connection timeout: $($_.Exception.Message)\"\n            return $auditResult\n        } catch {\n            $auditResult.ConnectionStatus = 'Failed - Unknown Error'\n            $auditResult.ErrorMessages += \"Unexpected connection error: $($_.Exception.Message)\"\n            return $auditResult\n        }\n        \n        # Execute comprehensive remote audit\n        $remoteData = Invoke-Command -Session $session -ScriptBlock {\n            $results = @{\n                Errors = @()\n            }\n            \n            try {\n                # System information\n                $results.OS = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop\n                $results.ComputerSystem = Get-CimInstance Win32_ComputerSystem -ErrorAction Stop\n                $results.BIOS = Get-CimInstance Win32_BIOS -ErrorAction Stop\n                $results.Processor = Get-CimInstance Win32_Processor -ErrorAction Stop\n                \n                # Performance metrics\n                try {\n                    $cpuCounter = Get-Counter \"\\Processor(_Total)\\% Processor Time\" -MaxSamples 3 -ErrorAction Stop\n                    if ($cpuCounter) {\n                        $results.CPUUtilization = [math]::Round(($cpuCounter.CounterSamples | Measure-Object CookedValue -Average).Average, 2)\n                    }\n                } catch {\n                    $results.CPUUtilization = -1\n                }\n                \n                if ($results.ComputerSystem -and $results.OS) {\n                    $memTotal = $results.ComputerSystem.TotalPhysicalMemory\n                    $memAvailable = $results.OS.FreePhysicalMemory * 1KB\n                    $results.MemoryUtilization = [math]::Round((($memTotal - $memAvailable) / $memTotal) * 100, 2)\n                }\n                \n                # Disk information\n                $results.Disks = Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" -ErrorAction Stop\n                \n                # Network adapters\n                $results.NetworkAdapters = Get-CimInstance Win32_NetworkAdapterConfiguration -ErrorAction Stop\n                    Where-Object { $_.IPEnabled -eq $true }\n                \n                # Critical services\n                $criticalServices = @('DHCP', 'DNS', 'W32Time', 'EventLog', 'RpcSs', 'LanmanServer', 'Spooler')\n                $results.Services = Get-Service -Name $criticalServices -ErrorAction Stop | \n                    Select-Object Name, Status, StartType\n                \n                # Windows features/roles\n                try {\n                    $results.WindowsFeatures = Get-WindowsFeature -ErrorAction Stop | \n                        Where-Object { $_.Installed -eq $true } | \n                        Select-Object -ExpandProperty Name\n                } catch {\n                    $results.WindowsFeatures = @()\n                }\n                \n                # Local administrators\n                try {\n                    $results.LocalAdmins = Get-LocalGroupMember -Group \"Administrators\" -ErrorAction Stop | \n                        Select-Object Name, ObjectClass, PrincipalSource\n                } catch {\n                    $results.LocalAdmins = @()\n                }\n                \n                # Windows updates\n                try {\n                    $updateSession = New-Object -ComObject Microsoft.Update.Session -ErrorAction Stop\n                    if ($updateSession) {\n                        $updateSearcher = $updateSession.CreateUpdateSearcher()\n                        $searchResult = $updateSearcher.Search(\"IsInstalled=0\")\n                        $results.PendingUpdates = $searchResult.Updates.Count\n                    } else {\n                        $results.PendingUpdates = -1\n                    }\n                } catch {\n                    $results.PendingUpdates = -1\n                }\n                \n                # System uptime\n                if ($results.OS) {\n                    $results.LastBoot = $results.OS.LastBootUpTime\n                    $results.UptimeDays = [math]::Round(((Get-Date) - $results.LastBoot).TotalDays, 1)\n                }\n                \n                # Event log errors (last 24 hours)\n                try {\n                    $results.RecentErrors = Get-WinEvent -FilterHashtable @{\n                        LogName='System','Application'\n                        Level=1,2  # Critical and Error\n                        StartTime=(Get-Date).AddDays(-1)\n                    } -MaxEvents 10 -ErrorAction Stop\n                } catch {\n                    $results.RecentErrors = @()\n                }\n                \n                # Security configuration checks\n                $results.SecurityChecks = @{}\n                \n                # Windows Defender status\n                try {\n                    $results.SecurityChecks.DefenderStatus = Get-MpComputerStatus -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.DefenderStatus = $null\n                }\n                \n                # Firewall status\n                try {\n                    $results.SecurityChecks.FirewallProfiles = Get-NetFirewallProfile -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.FirewallProfiles = @()\n                }\n                \n                # Installed software audit\n                try {\n                    $results.InstalledSoftware = Get-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction Stop | \n                        Where-Object { $_.DisplayName -and $_.DisplayName -ne \"\" } |\n                        Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n                        Sort-Object DisplayName\n                } catch {\n                    $results.InstalledSoftware = @()\n                    $results.Errors += \"Failed to retrieve installed software\"\n                }\n                \n                # Scheduled tasks audit\n                try {\n                    $results.ScheduledTasks = Get-ScheduledTask -ErrorAction Stop | \n                        Where-Object { $_.State -eq 'Ready' -and $_.TaskPath -notlike '\\Microsoft\\*' } |\n                        Select-Object TaskName, TaskPath, State, @{N='NextRun';E={$_.NextRunTime}}, @{N='LastRun';E={$_.LastRunTime}}\n                } catch {\n                    $results.ScheduledTasks = @()\n                    $results.Errors += \"Failed to retrieve scheduled tasks\"\n                }\n                \n                # SMBv1 status check\n                try {\n                    $results.SecurityChecks.SMBv1Status = @{}\n                    # Check if SMBv1 feature is installed\n                    $smb1Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.FeatureInstalled = ($smb1Feature.State -eq 'Enabled')\n                    \n                    # Check registry settings\n                    $smb1RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n                    $smb1RegValue = Get-ItemProperty -Path $smb1RegPath -Name \"SMB1\" -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.RegistryEnabled = ($smb1RegValue.SMB1 -eq 1)\n                } catch {\n                    $results.SecurityChecks.SMBv1Status = @{FeatureInstalled = $null; RegistryEnabled = $null}\n                    $results.Errors += \"Failed to check SMBv1 status\"\n                }\n                \n                # Network shares audit\n                try {\n                    $results.NetworkShares = Get-SmbShare -ErrorAction Stop | \n                        Where-Object { $_.Name -notin @('ADMIN$', 'C$', 'IPC$', 'print$') } |\n                        Select-Object Name, Path, Description, ShareType, @{N='AccessRight';E={\n                            try {\n                                $acl = Get-SmbShareAccess -Name $_.Name -ErrorAction SilentlyContinue\n                                ($acl | ForEach-Object { \"$($_.AccountName):$($_.AccessRight)\" }) -join '; '\n                            } catch {\n                                'Unable to retrieve'\n                            }\n                        }}\n                } catch {\n                    $results.NetworkShares = @()\n                    $results.Errors += \"Failed to retrieve network shares\"\n                }\n                \n                # Enhanced antivirus detection\n                try {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                    \n                    # Windows Defender already checked above\n                    \n                    # Check for third-party antivirus via WMI\n                    try {\n                        $avProducts = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ErrorAction SilentlyContinue\n                        if ($avProducts) {\n                            $results.SecurityChecks.AntivirusProducts = $avProducts | ForEach-Object {\n                                [PSCustomObject]@{\n                                    Name = $_.displayName\n                                    State = switch ($_.productState) {\n                                        { $_ -band 0x1000 } { 'Enabled' }\n                                        default { 'Disabled' }\n                                    }\n                                    UpToDate = switch ($_.productState) {\n                                        { $_ -band 0x10 } { 'Yes' }\n                                        default { 'No' }\n                                    }\n                                }\n                            }\n                        }\n                    } catch {\n                        $results.Errors += \"Failed to query third-party antivirus products\"\n                    }\n                } catch {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                }\n                \n                # PowerShell remoting configuration\n                try {\n                    $results.SecurityChecks.PSRemoting = @{}\n                    $winrm = Get-Service WinRM -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.PSRemoting.ServiceStatus = $winrm.Status\n                    \n                    # Check WinRM listeners\n                    $listeners = winrm enumerate winrm/config/listener 2>$null\n                    $results.SecurityChecks.PSRemoting.HasListeners = ($listeners -ne $null)\n                } catch {\n                    $results.SecurityChecks.PSRemoting = @{ServiceStatus = 'Unknown'; HasListeners = $false}\n                    $results.Errors += \"Failed to check PowerShell remoting configuration\"\n                }\n                \n                # BitLocker encryption status\n                try {\n                    $results.SecurityChecks.BitLocker = @()\n                    $bitlockerVolumes = Get-BitLockerVolume -ErrorAction SilentlyContinue\n                    if ($bitlockerVolumes) {\n                        $results.SecurityChecks.BitLocker = $bitlockerVolumes | ForEach-Object {\n                            [PSCustomObject]@{\n                                MountPoint = $_.MountPoint\n                                EncryptionMethod = $_.EncryptionMethod\n                                VolumeStatus = $_.VolumeStatus\n                                ProtectionStatus = $_.ProtectionStatus\n                                EncryptionPercentage = $_.EncryptionPercentage\n                            }\n                        }\n                    }\n                } catch {\n                    $results.SecurityChecks.BitLocker = @()\n                    $results.Errors += \"Failed to check BitLocker status\"\n                }\n                \n                # Recent Windows updates\n                try {\n                    $results.RecentUpdates = Get-HotFix -ErrorAction Stop | \n                        Sort-Object InstalledOn -Descending | \n                        Select-Object -First 10 Description, HotFixID, InstalledBy, InstalledOn\n                } catch {\n                    $results.RecentUpdates = @()\n                    $results.Errors += \"Failed to retrieve recent updates\"\n                }\n                \n                # Time synchronization configuration\n                try {\n                    $results.SecurityChecks.TimeSync = @{}\n                    $w32time = w32tm /query /status 2>$null\n                    $results.SecurityChecks.TimeSync.W32TimeStatus = if ($w32time) { 'Configured' } else { 'Not Configured' }\n                    \n                    $ntpServer = w32tm /query /peers 2>$null | Where-Object { $_ -match \"Peer:\" }\n                    $results.SecurityChecks.TimeSync.NTPServers = if ($ntpServer) { $ntpServer -join '; ' } else { 'None configured' }\n                } catch {\n                    $results.SecurityChecks.TimeSync = @{W32TimeStatus = 'Unknown'; NTPServers = 'Unknown'}\n                    $results.Errors += \"Failed to check time synchronization\"\n                }\n                \n            } catch {\n                $results.Errors += \"General error: $($_.Exception.Message)\"\n            }\n            \n            return $results\n        }\n        \n        # Process remote data\n        if ($remoteData.OS) {\n            $auditResult.OperatingSystem = $remoteData.OS.Caption\n            $auditResult.OSVersion = $remoteData.OS.Version\n            $auditResult.Architecture = $remoteData.OS.OSArchitecture\n        }\n        \n        if ($remoteData.ComputerSystem) {\n            $auditResult.Manufacturer = $remoteData.ComputerSystem.Manufacturer\n            $auditResult.Model = $remoteData.ComputerSystem.Model\n            $auditResult.TotalMemoryGB = [math]::Round($remoteData.ComputerSystem.TotalPhysicalMemory / 1GB, 2)\n        }\n        \n        if ($remoteData.BIOS) {\n            $auditResult.SerialNumber = $remoteData.BIOS.SerialNumber\n        }\n        \n        if ($remoteData.Processor) {\n            $auditResult.ProcessorInfo = ($remoteData.Processor | Select-Object -First 1).Name\n            $auditResult.ProcessorCores = ($remoteData.Processor | Measure-Object NumberOfCores -Sum).Sum\n        }\n        \n        $auditResult.CPUUtilization = $remoteData.CPUUtilization\n        $auditResult.MemoryUtilization = $remoteData.MemoryUtilization\n        $auditResult.LastBootTime = $remoteData.LastBoot\n        $auditResult.UptimeDays = $remoteData.UptimeDays\n        $auditResult.PendingUpdates = $remoteData.PendingUpdates\n        $auditResult.CriticalServices = $remoteData.Services\n        $auditResult.InstalledRoles = $remoteData.WindowsFeatures\n        $auditResult.LocalAdministrators = $remoteData.LocalAdmins\n        $auditResult.InstalledSoftware = $remoteData.InstalledSoftware\n        $auditResult.ScheduledTasks = $remoteData.ScheduledTasks\n        $auditResult.NetworkShares = $remoteData.NetworkShares\n        $auditResult.RecentUpdates = $remoteData.RecentUpdates\n        $auditResult.SecurityChecks = $remoteData.SecurityChecks\n        \n        # Process disk information\n        if ($remoteData.Disks) {\n            $auditResult.DiskInfo = $remoteData.Disks | ForEach-Object {\n                $freePercent = if ($_.Size -gt 0) { [math]::Round(($_.FreeSpace / $_.Size) * 100, 1) } else { 0 }\n                [PSCustomObject]@{\n                    Drive = $_.DeviceID\n                    SizeGB = [math]::Round($_.Size / 1GB, 2)\n                    FreeSpaceGB = [math]::Round($_.FreeSpace / 1GB, 2)\n                    FreeSpacePercent = $freePercent\n                    FileSystem = $_.FileSystem\n                }\n            }\n        }\n        \n        # Process network adapters\n        if ($remoteData.NetworkAdapters) {\n            $auditResult.NetworkAdapters = $remoteData.NetworkAdapters | ForEach-Object {\n                [PSCustomObject]@{\n                    Description = $_.Description\n                    IPAddress = $_.IPAddress -join ', '\n                    DHCPEnabled = $_.DHCPEnabled\n                    DNSServers = $_.DNSServerSearchOrder -join ', '\n                }\n            }\n        }\n        \n        # Security and performance analysis\n        $securityIssues = @()\n        $performanceIssues = @()\n        $recommendations = @()\n        $riskScore = 0\n        \n        # High CPU utilization\n        if ($auditResult.CPUUtilization -gt 80) {\n            $performanceIssues += \"High CPU utilization: $($auditResult.CPUUtilization)%\"\n            $recommendations += \"Investigate high CPU usage and optimize workloads\"\n            $riskScore += 2\n        }\n        \n        # High memory utilization\n        if ($auditResult.MemoryUtilization -gt 85) {\n            $performanceIssues += \"High memory utilization: $($auditResult.MemoryUtilization)%\"\n            $recommendations += \"Consider memory upgrade or workload redistribution\"\n            $riskScore += 2\n        }\n        \n        # Low disk space\n        $lowDiskSpace = $auditResult.DiskInfo | Where-Object { $_.FreeSpacePercent -lt 15 }\n        if ($lowDiskSpace) {\n            $performanceIssues += \"Low disk space on drives: $($lowDiskSpace.Drive -join ', ')\"\n            $recommendations += \"Urgent: Free up disk space or expand storage\"\n            $riskScore += 3\n        }\n        \n        # Pending updates\n        if ($auditResult.PendingUpdates -gt 0) {\n            $securityIssues += \"$($auditResult.PendingUpdates) pending Windows updates\"\n            $recommendations += \"Install pending Windows updates during next maintenance window\"\n            $riskScore += 1\n        }\n        \n        # Excessive uptime\n        if ($auditResult.UptimeDays -gt 90) {\n            $securityIssues += \"Server uptime exceeds 90 days ($($auditResult.UptimeDays) days)\"\n            $recommendations += \"Schedule reboot during maintenance window to apply updates\"\n            $riskScore += 1\n        }\n        \n        # Service status issues\n        $stoppedServices = $auditResult.CriticalServices | Where-Object { $_.Status -ne 'Running' -and $_.StartType -eq 'Automatic' }\n        if ($stoppedServices) {\n            $securityIssues += \"Critical services not running: $($stoppedServices.Name -join ', ')\"\n            $recommendations += \"Investigate and start critical services\"\n            $riskScore += 3\n        }\n        \n        # Windows Defender status\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            $defender = $remoteData.SecurityChecks.DefenderStatus\n            if (-not $defender.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender or verify third-party antivirus is active\"\n                $riskScore += 3\n            }\n            if (-not $defender.RealTimeProtectionEnabled) {\n                $securityIssues += \"Real-time protection is disabled\"\n                $recommendations += \"Enable real-time protection immediately\"\n                $riskScore += 3\n            }\n        }\n        \n        # Firewall status\n        if ($remoteData.SecurityChecks.FirewallProfiles) {\n            $disabledProfiles = $remoteData.SecurityChecks.FirewallProfiles | Where-Object { -not $_.Enabled }\n            if ($disabledProfiles) {\n                $securityIssues += \"Windows Firewall disabled on profiles: $($disabledProfiles.Name -join ', ')\"\n                $recommendations += \"Enable Windows Firewall on all network profiles\"\n                $riskScore += 2\n            }\n        }\n        \n        # Excessive local administrators\n        $userAdmins = $auditResult.LocalAdministrators | Where-Object { $_.ObjectClass -eq 'User' }\n        if ($userAdmins.Count -gt 3) {\n            $securityIssues += \"Excessive local administrators: $($userAdmins.Count) user accounts\"\n            $recommendations += \"Review and reduce local administrator accounts\"\n            $riskScore += 2\n        }\n        \n        # SMBv1 security check\n        if ($remoteData.SecurityChecks.SMBv1Status) {\n            if ($remoteData.SecurityChecks.SMBv1Status.FeatureInstalled -eq $true) {\n                $securityIssues += \"SMBv1 protocol is enabled (security risk)\"\n                $recommendations += \"Disable SMBv1 protocol to prevent security vulnerabilities\"\n                $riskScore += 3\n            }\n            if ($remoteData.SecurityChecks.SMBv1Status.RegistryEnabled -eq $true) {\n                $securityIssues += \"SMBv1 enabled in registry settings\"\n                $recommendations += \"Disable SMBv1 in registry settings\"\n                $riskScore += 2\n            }\n        }\n        \n        # Network shares security review\n        if ($auditResult.NetworkShares -and $auditResult.NetworkShares.Count -gt 0) {\n            $publicShares = $auditResult.NetworkShares | Where-Object { $_.AccessRight -match \"Everyone\" }\n            if ($publicShares.Count -gt 0) {\n                $securityIssues += \"Network shares with 'Everyone' permissions found: $($publicShares.Count)\"\n                $recommendations += \"Review and restrict network share permissions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Antivirus status check\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            if (-not $remoteData.SecurityChecks.DefenderStatus.RealTimeProtectionEnabled) {\n                $securityIssues += \"Windows Defender real-time protection is disabled\"\n                $recommendations += \"Enable Windows Defender real-time protection\"\n                $riskScore += 3\n            }\n            if (-not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender antivirus protection\"\n                $riskScore += 3\n            }\n        }\n        \n        # Third-party antivirus check\n        if ($remoteData.SecurityChecks.AntivirusProducts) {\n            $enabledAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.State -eq 'Enabled' }\n            $outdatedAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.UpToDate -eq 'No' }\n            \n            if ($enabledAV.Count -eq 0 -and -not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"No active antivirus protection detected\"\n                $recommendations += \"Install and enable antivirus protection\"\n                $riskScore += 4\n            }\n            \n            if ($outdatedAV.Count -gt 0) {\n                $securityIssues += \"Outdated antivirus definitions detected\"\n                $recommendations += \"Update antivirus definitions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Scheduled tasks security review\n        if ($auditResult.ScheduledTasks -and $auditResult.ScheduledTasks.Count -gt 5) {\n            $securityIssues += \"Multiple custom scheduled tasks detected: $($auditResult.ScheduledTasks.Count)\"\n            $recommendations += \"Review scheduled tasks for unauthorized or suspicious activities\"\n            $riskScore += 1\n        }\n        \n        # BitLocker encryption check\n        if ($remoteData.SecurityChecks.BitLocker) {\n            $unencryptedVolumes = $remoteData.SecurityChecks.BitLocker | Where-Object { $_.VolumeStatus -ne 'FullyEncrypted' }\n            if ($unencryptedVolumes.Count -gt 0) {\n                $securityIssues += \"Unencrypted volumes detected: $($unencryptedVolumes.Count)\"\n                $recommendations += \"Enable BitLocker encryption on all system volumes\"\n                $riskScore += 2\n            }\n        } else {\n            $securityIssues += \"BitLocker status could not be determined\"\n            $recommendations += \"Verify BitLocker encryption status\"\n            $riskScore += 1\n        }\n        \n        # PowerShell remoting security\n        if ($remoteData.SecurityChecks.PSRemoting.ServiceStatus -eq 'Running' -and $remoteData.SecurityChecks.PSRemoting.HasListeners) {\n            $securityIssues += \"PowerShell remoting is enabled and listening\"\n            $recommendations += \"Review PowerShell remoting configuration and security settings\"\n            $riskScore += 1\n        }\n        \n        # Time synchronization check\n        if ($remoteData.SecurityChecks.TimeSync.W32TimeStatus -eq 'Not Configured') {\n            $securityIssues += \"Time synchronization not properly configured\"\n            $recommendations += \"Configure proper time synchronization with domain or NTP servers\"\n            $riskScore += 1\n        }\n        \n        $auditResult.SecurityIssues = $securityIssues\n        $auditResult.PerformanceIssues = $performanceIssues\n        $auditResult.Recommendations = $recommendations\n        $auditResult.RiskScore = $riskScore\n        $auditResult.ErrorMessages = $remoteData.Errors\n        \n        # Clean up session with error handling\n        try {\n            Remove-PSSession $session -ErrorAction Stop\n        } catch {\n            $auditResult.ErrorMessages += \"Session cleanup warning: $($_.Exception.Message)\"\n        }\n        \n    } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Execution Error'\n        $auditResult.ErrorMessages += \"Remote command execution failed: $($_.Exception.Message)\"\n    } catch [System.TimeoutException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Command Timeout'\n        $auditResult.ErrorMessages += \"Remote command timeout: $($_.Exception.Message)\"\n    } catch [System.UnauthorizedAccessException] {\n        $auditResult.ConnectionStatus = 'Failed - Access Denied'\n        $auditResult.ErrorMessages += \"Access denied during audit: $($_.Exception.Message)\"\n    } catch {\n        $auditResult.ConnectionStatus = 'Failed - Audit Error'\n        $auditResult.ErrorMessages += \"Unexpected audit error: $($_.Exception.Message)\"\n        \n        # Include inner exception details if available\n        if ($_.Exception.InnerException) {\n            $auditResult.ErrorMessages += \"Inner exception: $($_.Exception.InnerException.Message)\"\n        }\n    } finally {\n        # Ensure session cleanup in finally block\n        if ($session) {\n            try {\n                Remove-PSSession $session -ErrorAction SilentlyContinue\n            } catch {\n                # Silently handle cleanup errors in finally block\n            }\n        }\n    }\n    \n    return $auditResult\n}\n\n# ==============================================================================\n# REPORT GENERATION FUNCTIONS\n# ==============================================================================\n\nfunction New-ComprehensiveAuditReport {\n    Write-AuditLog 'Generating comprehensive audit reports...' -Level Header\n    \n    try {\n        # Calculate overall statistics\n        $summary = Get-AuditSummaryStatistics\n        \n        # Generate reports in requested formats\n        foreach ($format in $ExportFormats) {\n            switch ($format) {\n                'HTML' { New-HTMLReport -Summary $summary }\n                'Excel' { New-ExcelReport -Summary $summary }\n                'CSV' { New-CSVReport -Summary $summary }\n                'Markdown' { New-MarkdownReport -Summary $summary }\n                'PDF' { New-PDFReport -Summary $summary }\n            }\n        }\n        \n        # Generate executive summary\n        New-ExecutiveSummary -Summary $summary\n        \n        Write-AuditLog \"All reports generated successfully in: $script:OutputDir\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating reports: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Get-AuditSummaryStatistics {\n    $totalFindings = $script:AuditFindings.Count\n    $criticalFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }).Count\n    $highFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'High' }).Count\n    $mediumFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }).Count\n    $lowFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }).Count\n    $passedFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }).Count\n    $issuesFindings = $totalFindings - $passedFindings\n    \n    $totalServers = $script:ServerResults.Count\n    $onlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Online' }).Count\n    $offlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Offline' }).Count\n    $highRiskServers = ($script:ServerResults | Where-Object { $_.RiskScore -gt 5 }).Count\n    \n    $totalRiskScore = ($script:AuditFindings | Measure-Object -Property Score -Sum).Sum\n    $overallRisk = if ($criticalFindings -gt 0) { 'CRITICAL' }\n                  elseif ($highFindings -gt 3) { 'HIGH' }\n                  elseif ($highFindings -gt 0 -or $mediumFindings -gt 5) { 'MEDIUM' }\n                  else { 'LOW' }\n    \n    return [PSCustomObject]@{\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n        AuditDate = $script:StartTime\n        AuditDuration = (Get-Date) - $script:StartTime\n        TotalFindings = $totalFindings\n        IssuesFindings = $issuesFindings\n        PassedFindings = $passedFindings\n        CriticalFindings = $criticalFindings\n        HighFindings = $highFindings\n        MediumFindings = $mediumFindings\n        LowFindings = $lowFindings\n        TotalServers = $totalServers\n        OnlineServers = $onlineServers\n        OfflineServers = $offlineServers\n        HighRiskServers = $highRiskServers\n        TotalRiskScore = $totalRiskScore\n        OverallRisk = $overallRisk\n        ComplianceFrameworks = $script:ComplianceFrameworks\n    }\n}\n\nfunction New-HTMLReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating HTML report...' -Level Info\n    \n    $htmlPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.html'\n    \n    $riskColor = switch ($Summary.OverallRisk) {\n        'CRITICAL' { '#dc3545' }\n        'HIGH' { '#fd7e14' }\n        'MEDIUM' { '#ffc107' }\n        'LOW' { '#28a745' }\n    }\n    \n    $htmlContent = @\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Infrastructure Audit Report - $CustomerName</title>\n    <style>\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 10px; background: #f8f9fa; line-height: 1.4; }\n        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .header { margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; border-radius: 6px; display: flex; align-items: center; justify-content: space-between; }\n        .header-content { text-align: center; flex: 1; }\n        .header-info { text-align: right; width: 250px; }\n        .logo { max-height: 80px; max-width: 250px; }\n        .risk-banner { text-align: center; padding: 10px; margin: 10px 0; border-radius: 6px; color: white; font-size: 1.3em; font-weight: bold; background: $riskColor; }\n        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0; }\n        .metric-card { background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .metric-number { font-size: 2.0em; font-weight: bold; margin: 5px 0; }\n        .critical { color: #dc3545; }\n        .high { color: #fd7e14; }\n        .medium { color: #ffc107; color: #333; }\n        .low { color: #28a745; }\n        table { width: 100%; border-collapse: collapse; margin: 10px 0; }\n        th, td { padding: 8px; text-align: left; border: 1px solid #dee2e6; }\n        th { background: #495057; color: white; }\n        tr:nth-child(even) { background: #f8f9fa; }\n        .section { margin: 20px 0; }\n        .section h2 { color: #495057; border-bottom: 2px solid #dee2e6; padding-bottom: 6px; font-size: 1.6em; margin: 10px 0; }\n        \n        /* Detailed Findings Styling */\n        .findings-container { margin: 10px 0; }\n        .finding-group { margin: 15px 0; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 4px rgba(0,0,0,0.1); }\n        .finding-group-title { background: #495057; color: white; margin: 0; padding: 12px; font-size: 1.2em; font-weight: bold; }\n        .critical-section .finding-group-title { background: #dc3545; }\n        .high-section .finding-group-title { background: #fd7e14; }\n        .medium-section .finding-group-title { background: #ffc107; color: #333; }\n        .low-section .finding-group-title { background: #28a745; }\n        .passed-section .finding-group-title { background: #17a2b8; }\n        \n        .finding-item { background: white; border-bottom: 1px solid #dee2e6; padding: 15px; }\n        .finding-item:last-child { border-bottom: none; }\n        \n        /* Collapsible Findings */\n        .finding-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 8px; transition: background-color 0.3s; }\n        .finding-header:hover { background: #e9ecef; }\n        .finding-title { font-weight: bold; color: #495057; margin: 0; }\n        .finding-toggle { font-size: 1.2em; font-weight: bold; color: #6c757d; transition: transform 0.3s; }\n        .finding-content { display: none; padding: 12px; background: white; border-radius: 5px; border: 1px solid #dee2e6; }\n        .finding-content.show { display: block; }\n        .finding-toggle.open { transform: rotate(45deg); }\n        .finding-header { margin-bottom: 10px; }\n        .finding-header h4 { margin: 0 0 6px 0; font-size: 1.2em; color: #333; }\n        .finding-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }\n        .finding-id, .finding-category, .finding-type { \n            background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; color: #666; \n        }\n        .severity-badge { \n            padding: 6px 12px; border-radius: 20px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; \n        }\n        .severity-badge.critical { background: #dc3545; color: white; }\n        .severity-badge.high { background: #fd7e14; color: white; }\n        .severity-badge.medium { background: #ffc107; color: #333; }\n        .severity-badge.low { background: #28a745; color: white; }\n        \n        .finding-content { margin-top: 10px; }\n        .description-section, .impact-section, .recommendation-section, .evidence-section { \n            margin: 10px 0; padding: 10px; border-radius: 5px; \n        }\n        .description-section { background: #f8f9fa; border-left: 4px solid #007bff; }\n        .impact-section { background: #fff5f5; border-left: 4px solid #dc3545; }\n        .recommendation-section { background: #f0f9ff; border-left: 4px solid #10b981; }\n        .evidence-section { background: #fffbeb; border-left: 4px solid #f59e0b; }\n        \n        .finding-content h5 { \n            margin: 0 0 6px 0; font-size: 1.0em; color: #333; font-weight: 600; \n        }\n        .finding-content p { margin: 0; color: #555; }\n        .evidence-data { \n            background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 4px; \n            font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85em; margin: 6px 0 0 0;\n            white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; \n        }\n        .compliance-tag { \n            background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; \n            font-size: 0.9em; font-weight: 500; \n        }\n        .finding-footer { \n            margin-top: 20px; padding-top: 15px; border-top: 1px solid #e5e7eb; \n            font-size: 0.95em; color: #6b7280; \n        }\n        \n        /* Executive Summary Styling */\n        .executive-summary { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }\n        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; margin-bottom: 15px; }\n        .summary-card { background: white; padding: 12px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .summary-card h3 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .summary-card ul { margin: 0; padding-left: 15px; }\n        .summary-card li { margin: 4px 0; color: #555; }\n        .risk-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; }\n        .risk-level.critical { background: #dc3545; color: white; }\n        .risk-level.high { background: #fd7e14; color: white; }\n        .risk-level.medium { background: #ffc107; color: #333; }\n        .risk-level.low { background: #28a745; color: white; }\n        .key-findings { margin: 15px 0; }\n        .concern-list { margin: 10px 0; }\n        .concern-item { display: flex; align-items: flex-start; margin: 8px 0; padding: 10px; background: white; border-radius: 5px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }\n        .concern-icon { font-size: 1.1em; margin-right: 10px; flex-shrink: 0; }\n        .concern-content { flex: 1; color: #555; }\n        .concern-content strong { color: #333; }\n        .concern-content small { color: #777; }\n        .compliance-overview { margin: 25px 0; }\n        .compliance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }\n        .compliance-item { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .compliance-item h4 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .compliance-item p { margin: 0; color: #666; font-size: 0.95em; }\n        \n        .report-links { text-align: center; margin: 30px 0; }\n        .report-links a { display: inline-block; margin: 10px; padding: 12px 25px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold; }\n        .report-links a:hover { background: #0056b3; }\n        \n        /* Domain Controller Health Dashboard */\n        .dc-dashboard { margin: 25px 0; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }\n        .dc-dashboard-header { background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; padding: 15px; border-radius: 8px 8px 0 0; }\n        .dc-dashboard-header h2 { margin: 0; font-size: 1.5em; display: flex; align-items: center; }\n        .dc-dashboard-header .dc-count { background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 15px; margin-left: 15px; font-size: 0.9em; }\n        .dc-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; padding: 20px; }\n        .dc-card { border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }\n        .dc-card-header { padding: 12px 15px; font-weight: bold; color: white; display: flex; justify-content: space-between; align-items: center; }\n        .dc-card-header.healthy { background: #28a745; }\n        .dc-card-header.warning { background: #ffc107; color: #333; }\n        .dc-card-header.critical { background: #dc3545; }\n        .dc-card-body { padding: 15px; background: #f8f9fa; }\n        .dc-info-row { display: flex; justify-content: space-between; margin: 5px 0; }\n        .dc-info-label { font-weight: 600; color: #495057; }\n        .dc-info-value { color: #28a745; }\n        .dc-info-value.warning { color: #856404; }\n        .dc-info-value.failed { color: #dc3545; }\n        .dc-services { margin-top: 10px; }\n        .dc-service { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-service.running { background: #d4edda; color: #155724; }\n        .dc-service.stopped { background: #f8d7da; color: #721c24; }\n        .dc-tests { margin-top: 10px; }\n        .dc-test { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-test.passed { background: #d4edda; color: #155724; }\n        .dc-test.failed { background: #f8d7da; color: #721c24; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <div class=\"logo-container\">\n                <img src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iOTAwLjAwMDAwMHB0IiBoZWlnaHQ9IjE3NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDkwMC4wMDAwMDAgMTc0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjEwLCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxMQo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwxNzQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTgwNiAxNTA4IGMtMTMgLTQ0IC0yNiAtMTI1IC0yNiAtMTU2IDAgLTIwIC03IC02MiAtMTUgLTkyIC04IC0zMAotMTUgLTc2IC0xNSAtMTAxIDAgLTI2IC03IC02MyAtMTUgLTgyIC04IC0yMCAtMTUgLTU2IC0xNSAtNzkgMCAtMjQgLTcgLTY1Ci0xNSAtOTIgLTggLTI3IC0xNSAtNjIgLTE1IC03OCAwIC0yOCAxIC0yOCA2MCAtMjggbDU5IDAgNiAzOCBjMyAyMCAxMCA1NiAxNgo3OSA1IDIzIDkgNjEgOSA4NSAxIDg4IDY1IDE1NSAxMjggMTMyIDI3IC0xMCAyNyAtMTEgMjQgLTg5IC0xIC00NCAtOSAtMTAwCi0xNyAtMTI1IC04IC0yNSAtMTUgLTYxIC0xNyAtODAgbC0zIC0zNSA2MyAtMyA2MiAtMyAwIDM3IGMwIDIwIDcgNjIgMTUgOTQgOAozMiAxNiAxMDEgMTggMTU0IDIgODcgMCA5NyAtMjEgMTE4IC0xOSAxOSAtMzMgMjMgLTg1IDIzIC00MyAwIC03MSAtNiAtOTAKLTE3IC0xNCAtMTAgLTMxIC0xOCAtMzcgLTE4IC0xNSAwIC0xMiA0MiA1IDgzIDggMjAgMTUgNTIgMTUgNzAgMCAxOSA3IDU0IDE1Cjc3IDggMjMgMTUgNTUgMTUgNzEgMCAyOSAtMSAyOSAtNjAgMjkgLTQwIDAgLTYyIC00IC02NCAtMTJ6Ii8+CjxwYXRoIGQ9Ik03MTgwIDE0NTMgYy02IC0zNyAtMTYgLTk5IC0yMCAtMTM4IC00IC0zOCAtMTMgLTg2IC0xOSAtMTA1IC02IC0xOQotMTEgLTU3IC0xMSAtODUgMCAtNDYgLTE1IC0xMzAgLTQxIC0yMzAgLTYgLTIyIC0xMyAtNTMgLTE2IC02OCBsLTUgLTI4IDYzIDMKNjQgMyA4IDQ1IGM0IDI1IDEyIDgxIDE3IDEyNSA5IDgxIDIzIDE1OCA0MSAyMzAgNiAyMiAxNCA2OSAxOSAxMDUgNCAzNiAxMgo3NyAxOCA5MSA2IDE0IDEyIDQ2IDE0IDcwIGwzIDQ0IC02MSAzIC02MSAzIC0xMyAtNjh6Ii8+CjxwYXRoIGQ9Ik0zMjg5IDE0NjcgYy0xNCAtMTIgLTMxIC0zNiAtMzggLTU0IC0xMiAtMjggLTExIC0zNyA2IC02NSAyOCAtNDgKNzQgLTUxIDExOSAtNyAyNyAyNiAzNCA0MSAzNCA3MiAwIDY5IC02OCAxMDAgLTEyMSA1NHoiLz4KPHBhdGggZD0iTTI4NjggMTQzMiBjLTE3IC0zIC0yOCAtNTEgLTI4IC0xMjcgMCAtMjcgLTcgLTcyIC0xNSAtOTkgLTggLTI3Ci0xNSAtNjggLTE1IC05MCAwIC0yMyAtNyAtNjYgLTE1IC05NiAtOCAtMzAgLTE1IC03MyAtMTUgLTk1IDAgLTIyIC03IC01MQotMTUgLTY1IC0zMSAtNTQgLTI0IC02MCA3NSAtNjAgbDkwIDAgMCA0NSBjMCAyNCA0IDY2IDkgOTIgNSAyNiAxMiA2NCAxNiA4NApsNSAzNiA4NyAtMSA4NyAtMSA3IDM1IGM0IDE5IDEwIDUwIDE0IDY4IGw4IDMzIC04NiAtMiBjLTQ4IC0yIC04OSAwIC05MiAzCi0xMSAxMCA3IDEwNyAyMCAxMTIgOCAzIDUxIDEgOTcgLTQgNDYgLTQgODYgLTUgOTAgLTIgMyA0IDggMjcgMTAgNTIgMyAyNSA2CjUyIDkgNjAgMyAxMyAtMjEgMTYgLTE2MiAyMCAtOTIgMyAtMTczIDQgLTE4MSAyeiIvPgo8cGF0aCBkPSJNNDYyNCAxNDI3IGMtOSAtNSAtMTQgLTI0IC0xNCAtNTMgbDAgLTQ1IDY4IDMgYzY2IDMgNjcgMyA2NSAtMjIgLTYKLTY3IC0yMiAtMTU4IC0zMiAtMTgzIC02IC0xNiAtMTEgLTQ3IC0xMSAtNjkgMCAtMjMgLTYgLTY0IC0xNCAtOTIgLTE5IC02NwotMzQgLTE1NSAtMjggLTE2MSAzIC0zIDM0IC01IDY5IC01IGw2MyAwIDAgMzggYzEgMjAgNyA2NCAxNSA5NyA4IDMzIDE1IDc5CjE1IDEwMSAwIDIzIDcgNTggMTUgNzcgOCAyMCAxNSA1NSAxNSA3OCAwIDIyIDcgNjYgMTYgOTYgbDE2IDU1IDU3IC02IGM3NyAtOQoxMDAgMTMgOTIgODkgLTEgMTIgLTM4NSAxNCAtNDA3IDJ6Ii8+CjxwYXRoIGQ9Ik0yNjE0IDEzNjcgYy03MyAtNzUgLTExOCAtMTE0IC0xNjEgLTE0MCAtMTggLTEwIC0zMyAtMjMgLTMzIC0yOCAwCi01IC01IC05IC0xMSAtOSAtNiAwIC0zNyAtMjAgLTY5IC00NSAtMzIgLTI1IC02MSAtNDUgLTY0IC00NSAtNCAwIC0yNSAtMTQKLTQ4IC0zMCAtNDcgLTM0IC03MiAtODIgLTgyIC0xNTcgLTYgLTUxIC02IC01MyAxNyAtNTMgMTQgMCAzMCA3IDM3IDE1IDcgOAoyNCAxNSAzOSAxNSAxNCAxIDM3IDcgNTEgMTUgMTQgOCA0MiAxNCA2MiAxNSAyMCAwIDY3IDcgMTA1IDE2IDM3IDkgODIgMTMgOTkKMTEgMTcgLTMgMzUgLTIgNDEgMSAxMiA5IDIzIDQ5IDMzIDEyNyAxMSA4NiAyOSAxNzAgNTIgMjQ3IDM2IDExOSAxOCAxMzEgLTY4CjQ1eiBtLTE0MiAtMzE5IGMtMTUgLTE1IC0yNiAtNCAtMTggMTggNSAxMyA5IDE1IDE4IDYgOSAtOSA5IC0xNSAwIC0yNHoiLz4KPHBhdGggZD0iTTQxNTYgMTMxMCBjLTcgLTU4IC0xMSAtNjYgLTQ4IC05MyAtOSAtNyAtMjAgLTMzIC0yMyAtNTkgLTcgLTQzIC02Ci00NyAxNiAtNTAgMjcgLTMgMjcgLTYgNiAtMTM4IC04IC00NyAtMTkgLTk4IC0yNiAtMTEzIC0yMiAtNTUgLTE4IC01OCA2NgotNTUgbDc4IDMgNyA0MCBjNSAyMiAxMiA4NCAxOCAxMzkgNSA1NCAxNSAxMDUgMjEgMTEyIDggOSAyMyAxMiA0MyA5IDE3IC0zCjM2IC0yIDQzIDMgMTMgOCAyMSAxMDggOSAxMTkgLTQgNCAtMjMgNiAtNDMgNCAtMzUgLTMgLTM2IC0zIC0yOSAzMSA0IDE4IDEwCjUwIDEzIDcxIGw1IDM3IC03NSAwIC03NCAwIC03IC02MHoiLz4KPHBhdGggZD0iTTM2NjYgMTIzMyBjLTIxIC05IC01MCAtMjcgLTY0IC00MCAtMzMgLTMxIC00MiAtMjkgLTQyIDcgbDAgMzEgLTY3Ci0zIC02OCAtMyAtMTIgLTEwMCBjLTExIC04NyAtMjYgLTE3OSAtNDkgLTI5MiBsLTYgLTMzIDc1IDAgYzg3IDAgODMgLTUgOTQKMTI1IDEwIDEyNyA0NSAxNzcgMTI2IDE4MSAyOSAxIDU1IDMgNTggMyAxMCAyIDMyIDEwOCAyNiAxMjUgLTggMjAgLTIxIDE5Ci03MSAtMXoiLz4KPHBhdGggZD0iTTM4NjQgMTIzNSBjLTEwIC04IC0yNiAtMTUgLTM1IC0xNSAtOSAwIC0yNSAtMTIgLTM1IC0yNyAtMTAgLTE0Ci0yOCAtMzYgLTM5IC00NyAtMTcgLTE3IC0yMCAtMzEgLTE3IC03MyAzIC00NyA4IC01NSAzNyAtNzMgMTggLTExIDQ4IC0yMCA2NwotMjAgNTYgMCA3NyAtNDAgNDAgLTczIC0yNSAtMjMgLTQyIC0yMSAtMTAzIDkgLTUxIDI2IC01MyAyNiAtNjUgOCAtMTkgLTI3Ci0yNiAtMzcgLTQ3IC02MSAtMTggLTIwIC0xNyAtMjEgMTkgLTQ0IDMyIC0yMCA1MSAtMjMgMTMzIC0yMyA4MiAwIDEwMSA0IDEzMwoyMyA2MyAzOCA4OCA4MSA4OCAxNTAgMCA1NyAtMiA2MCAtMzQgODAgLTE4IDEyIC00OSAyMSAtNjggMjEgLTM4IDAgLTU4IDE1Ci01OCA0MiAwIDMxIDQzIDQzIDkyIDI3IDM4IC0xMiA0MiAtMTIgNTIgNiA2IDEwIDIyIDI5IDM0IDQxIGwyNCAyMyAtMzQgMjEKYy00MSAyNSAtMTUzIDI4IC0xODQgNXoiLz4KPHBhdGggZD0iTTMyMjYgMTIxMyBjLTMgLTEwIC0xMCAtNTYgLTE2IC0xMDMgLTYgLTQ3IC0xNiAtMTAwIC0yMSAtMTE4IC05Ci0yOCAtMjEgLTk1IC0zMSAtMTY3IC0zIC0xOCA0IC0yMCA2NiAtMjMgMzggLTIgNzMgMSA3OCA2IDUgNSAxMyA1MSAxOCAxMDMgOAo4MiAyMiAxNjcgNDYgMjg3IGw2IDMyIC03MCAwIGMtNTkgMCAtNzIgLTMgLTc2IC0xN3oiLz4KPHBhdGggZD0iTTUwNjAgMTIyMyBjLTE0IC0yIC0zMiAtMTAgLTQwIC0xNyAtOCAtNyAtMjMgLTE2IC0zMiAtMTkgLTIwIC03Ci03OCAtODQgLTc4IC0xMDIgMCAtNyAtNyAtMjYgLTE1IC00MSAtMzcgLTcxIC01IC0xODQgNjEgLTIyMyA1NCAtMzIgMTgwIC0zMAoyMzMgNCA2NCA0MCA5NCA3NCA4MCA5MSAtMTkgMjMgLTk1IDE4IC0xMTggLTggLTI5IC0zMCAtMTAyIC0zMSAtMTMwIC0xIC0yNQoyNiAtMjggODEgLTUgOTAgOCAzIDc1IDYgMTQ3IDcgbDEzMiAxIDMgNjAgYzQgNjcgLTEyIDEwOCAtNTQgMTM4IC0yNSAxOQotMTM0IDMxIC0xODQgMjB6IG0xMTkgLTEwMCBjMjAgLTI0IDI3IC00MSAyMSAtNDcgLTUgLTUgLTQ2IC0xMSAtOTAgLTEyIC03MgotMiAtODAgLTEgLTgwIDE2IDAgMjQgNjggODAgOTcgODAgMTMgMCAzNCAtMTUgNTIgLTM3eiIvPgo8cGF0aCBkPSJNNTUyMyAxMjIzIGMtMTcgLTIgLTM3IC0xMSAtNDMgLTE5IC03IC04IC0xOCAtMTQgLTI1IC0xNCAtMTUgMCAtOTUKLTg5IC05NSAtMTA2IDAgLTcgLTcgLTI1IC0xNSAtNDAgLTM2IC02OSAtMTAgLTE2NSA2MCAtMjE4IDMwIC0yMyA0MyAtMjYgMTE5Ci0yNiA5NCAwIDk1IDEgMTEyIDY4IDkgMzYgOSA0NSAtMyA0OSAtNyAzIC0yMiAtMiAtMzIgLTExIC0zMCAtMjcgLTg4IC0yMQotMTIyIDEzIC0zNyAzOCAtMzkgODYgLTQgMTQxIDM1IDU2IDY1IDczIDExNyA2NyAxMDIgLTEzIDkzIC0xNyA5NiAzMiAyIDI0Ci0xIDQ4IC02IDUzIC0xMSAxMSAtMTEyIDE4IC0xNTkgMTF6Ii8+CjxwYXRoIGQ9Ik02Mzk1IDEyMjMgYy0xMSAtMyAtMjggLTEyIC0zOCAtMjEgLTE3IC0xNiAtMjAgLTE1IC0zMiAxIC05IDEzIC0yNwoxNyAtNjkgMTcgbC01NiAwIDAgLTQ1IGMwIC0yNCAtNyAtNzAgLTE1IC0xMDIgLTggLTMxIC0xNSAtNzQgLTE1IC05NCAwIC0yMAotNyAtNTMgLTE1IC03MiAtOCAtMjAgLTE1IC01MiAtMTUgLTcyIGwwIC0zNSA1OCAwIDU4IDAgMTMgNzMgYzcgMzkgMTYgOTcgMTkKMTI3IDExIDkyIDUwIDE0MCAxMTIgMTQwIDM5IDAgNTEgLTI3IDQ0IC05OCAtMyAtMzcgLTEyIC04NyAtMTkgLTExMiAtOCAtMjUKLTE2IC02MyAtMTcgLTg1IGwtMyAtNDAgNjMgLTMgNjIgLTMgMCAzOCBjMCAyMSA3IDcxIDE2IDExMiA4IDQxIDE2IDExMCAxNwoxNTIgMiA2OCAtMSA4MSAtMTkgOTkgLTIxIDIyIC0xMDcgMzUgLTE0OSAyM3oiLz4KPHBhdGggZD0iTTY3OTggMTIyMyBjLTIwIC0yIC00MiAtMTEgLTQ4IC0xOSAtNyAtOCAtMTggLTE0IC0yNCAtMTQgLTE0IDAgLTY1Ci01NCAtODUgLTkwIC0yNSAtNDMgLTM3IC0xMzEgLTI2IC0xODAgMTMgLTU3IDE4IC02NiA2NiAtOTUgMzMgLTIxIDUxIC0yNQoxMTggLTI1IDk2IDAgMTQ0IDIxIDE5OCA4NiA2NCA3NiA4NSAxNjkgNTQgMjM2IC0zMCA2NyAtNzcgOTggLTE1MyAxMDIgLTM1IDIKLTgwIDIgLTEwMCAtMXogbTEyNiAtMTI3IGMzMSAtNDIgMzMgLTczIDUgLTEyMCAtNDQgLTc0IC0xMTkgLTEwNiAtMTY1IC02OAotNTUgNDcgLTQ5IDEzMCAxNiAxODkgMjggMjYgNDQgMzMgNzYgMzMgMzYgMCA0NSAtNSA2OCAtMzR6Ii8+CjxwYXRoIGQ9Ik03NDYzIDEyMjMgYy0xNyAtMiAtMzcgLTExIC00MyAtMTkgLTcgLTggLTE4IC0xNCAtMjQgLTE0IC0xOCAwIC04MAotNzAgLTk5IC0xMTMgLTI2IC01OCAtMjMgLTE2OSA1IC0yMDggNDAgLTU0IDc2IC02OSAxNjUgLTY5IDE1NiAwIDI0NyA4NiAyNjAKMjQ2IDYgNzIgLTExIDExMSAtNjYgMTUyIC0zMSAyMyAtMTI5IDM1IC0xOTggMjV6IG0xMjUgLTExNyBjMTcgLTE4IDIyIC0zNgoyMiAtNzQgMCAtNDcgLTQgLTU0IC00NiAtOTYgLTUzIC01MyAtODcgLTU5IC0xMzQgLTI0IC0yOCAyMCAtMzAgMjcgLTMwIDg0IDAKNjEgMSA2MyA0MyA5OCA1MyA0NSAxMDkgNDkgMTQ1IDEyeiIvPgo8cGF0aCBkPSJNNzk0MSAxMjIzIGMtOTMgLTE5IC0xNTkgLTExNiAtMTc2IC0yNTMgLTYgLTQ3IC0zIC02MiAxNSAtOTMgMzEKLTUyIDc2IC03NyAxNDAgLTc3IDM3IDAgNTkgNiA3NyAyMCAzNSAyNyA2MyAyNiA2MyAtMiAwIC0xMyAtNyAtMzIgLTE1IC00MgotOCAtMTEgLTE1IC0yOCAtMTUgLTM3IDAgLTIzIC02MCAtNTkgLTk4IC01OSAtMjMgMCAtMzggOSAtNjQgMzkgLTI4IDMzIC00MQo0MCAtODEgNDQgLTM5IDQgLTQ5IDEgLTU4IC0xNCAtMjEgLTQxIDE5IC0xMDIgOTEgLTEzOSA1MyAtMjcgMTU2IC0yNyAyMDkgMAo0NiAyMyAxMjEgMTA3IDEyMSAxMzUgMSAxMSA3IDMxIDE1IDQ1IDggMTQgMTQgNDYgMTUgNzEgMCAyNSA3IDY4IDE1IDk1IDggMjcKMTUgNzAgMTUgOTUgMCAyNiA3IDY2IDE1IDg5IDI2IDc0IDIzIDgwIC00MCA4MCAtNDAgMCAtNTcgLTQgLTYxIC0xNSAtOCAtMTkKLTIzIC0xOSAtNDQgMCAtMTggMTYgLTk4IDI3IC0xMzkgMTh6IG0xMjkgLTExNCBjMjIgLTE5IDI1IC0yOSAyNSAtODIgLTEgLTU4Ci0yIC02MSAtNDUgLTk4IC01NyAtNDkgLTkyIC01MSAtMTM3IC03IC0yNCAyMyAtMzMgNDEgLTMzIDY1IDAgMzggMzYgMTAxIDcxCjEyNiAzNCAyMyA4OSAyMSAxMTkgLTR6Ii8+CjxwYXRoIGQ9Ik04NjgwIDEyMjMgYy00MyAtNCAtODAgLTI1IC04MCAtNDYgMCAtNSAtMTMgLTI4IC0yOCAtNTEgLTE1IC0yMgotMzcgLTYwIC00OCAtODQgLTE2IC0zNSAtMjMgLTQyIC00NCAtNDAgLTIyIDMgLTI2IDkgLTMxIDU4IC0zIDMxIC0xMSA2NSAtMTcKNzcgLTcgMTIgLTEyIDM1IC0xMiA1MiBsMCAzMSAtNzUgMCBjLTQxIDAgLTc1IC00IC03NSAtOSAwIC01IDYgLTIyIDE0IC0zOAozMSAtNjUgNjUgLTE1MiA3MyAtMTkzIDMgLTE0IDEyIC0zMyAyMCAtNDIgMzIgLTM3IDIxIC03OSAtNDUgLTE2NSAtMzQgLTQ1Ci02MiAtODUgLTYyIC04OSAwIC01IC0xNCAtMjMgLTMxIC00MCAtNDAgLTQxIC0zNCAtNzAgMTIgLTYwIDE4IDMgNDYgNiA2MyA2CjI5IDAgMzkgMTIgMTY2IDIwMSA3NCAxMTAgMTQxIDIxMSAxNDggMjI1IDcgMTMgMTcgMjQgMjMgMjQgNSAwIDkgNiA5IDEzIDAgNgoyNSA0MiA1NSA4MCAzMCAzNyA1NSA3MSA1NSA3NiAwIDkgLTI2IDIyIC0zOCAxOSAtNCAtMSAtMjcgLTMgLTUyIC01eiIvPgo8cGF0aCBkPSJNMjAxOSA5NDMgYy0zMSAtMjMgLTU5IC00MCAtODQgLTUzIC0xMSAtNiAtMzMgLTE5IC01MCAtMzAgLTE2IC0xMQotMzcgLTIyIC00NSAtMjYgLTggLTMgLTIyIC05IC0zMCAtMTQgLTggLTUgLTc2IC0zOSAtMTUwIC03NSAtNzQgLTM3IC0xNDcKLTczIC0xNjIgLTgxIC0xNCAtOCAtMzMgLTE0IC00MSAtMTQgLTggMCAtMjAgLTcgLTI3IC0xNSAtNyAtOCAtMjMgLTE1IC0zNQotMTUgLTEyIDAgLTI4IC03IC0zNSAtMTUgLTcgLTggLTIwIC0xNSAtMjkgLTE1IC0xMCAwIC0yNiAtNyAtMzcgLTE1IC0xMCAtOAotMjcgLTE1IC0zNiAtMTUgLTkgMCAtMzAgLTcgLTQ3IC0xNSAtMTcgLTggLTQ1IC0yMiAtNjIgLTMwIC0xNyAtOCAtMzggLTE1Ci00OCAtMTUgLTkgMCAtMjYgLTcgLTM3IC0xNSAtMTAgLTggLTI3IC0xNSAtMzcgLTE1IC0xMSAwIC0zMSAtNiAtNDUgLTE0IC0zMAotMTUgLTgxIC0zMyAtMTI3IC00NiAtMzkgLTExIC05MSAtMjkgLTEzMyAtNDYgLTE4IC04IC00MyAtMTQgLTU1IC0xNCAtMTIgLTEKLTMzIC03IC00NyAtMTUgLTE0IC04IC0zOCAtMTQgLTUzIC0xNSAtMTYgMCAtMzggLTUgLTUwIC0xMiAtMjEgLTExIC0zOCAtMTUKLTE2MiAtMzggLTMzIC02IC02OSAtMTUgLTgwIC0yMCAtMTEgLTUgLTMzIC0xNCAtNDkgLTIwIC0yMSAtOCAtMjYgLTE0IC0xOQotMjEgOCAtOCA3MyAtOCAyMjUgMSAxOTYgMTEgMTE2MiAxMCAxMjEzIC0xIDI0IC01IDMzIDI2IDEyIDQ5IC01OSA2OSAtMzUKMjM3IDQ4IDMzMCAzMCAzNSAxMjcgMTEzIDE1NSAxMjUgNzggMzYgMTc3IDk4IDE4NyAxMTggNiAxMyAxNCA0OCAxOCA3NyA4IDU4Ci0zIDY2IC00NiAzNXogbS00ODkgLTQwNSBjMzIgLTI0IDQyIC03MSAxNiAtODEgLTE5IC03IC0zMSAtNjYgLTE3IC04MCAxOAotMTggMTMgLTMwIC0xMCAtMjQgLTE1IDQgLTMwIC0zIC01MSAtMjYgLTI2IC0yOCAtMzEgLTMwIC00MSAtMTYgLTEwIDEzIC0zNwoxNSAtMTY0IDE1IC0xNzQgLTEgLTE5OSA3IC0xNDggNDkgMzcgMzAgMTU5IDkwIDIwMiAxMDAgMTggMyA0OCAxNyA2OCAzMSAyMAoxMyA0NCAyNCA1NCAyNCA5IDAgMjYgNyAzNyAxNSAyNCAxOCAyMCAxOSA1NCAtN3oiLz4KPHBhdGggZD0iTTI0NTUgNjYwIGMtMTYgLTQgLTUxIC04IC03NiAtOSAtMjYgMCAtNjMgLTggLTgyIC0xNiAtMjAgLTggLTUwCi0xNSAtNjYgLTE1IC0xNiAwIC0zOSAtOSAtNTIgLTE5IC0yMSAtMTcgLTIyIC0yMiAtMTEgLTQwIDYgLTExIDEyIC0yOSAxMgotNDAgMCAtMTAgNyAtMjQgMTUgLTMxIDggLTcgMTUgLTIwIDE1IC0zMCAwIC0xMCA3IC0yMyAxNSAtMzAgOCAtNyAxNSAtMTcgMTUKLTIyIDAgLTE1IDg1IC0xMjIgMTI1IC0xNTcgMzAgLTI2IDQ0IC0zMSA3MyAtMjkgMzcgMyAzNyAzIDQ0IDU4IDQgMzAgMTEgNjgKMTcgODMgNiAxNiAxMSA0NSAxMSA2NiAwIDIxIDYgNTYgMTQgNzcgNyAyMiAxNyA2NyAyMSAxMDIgbDcgNjIgLTM0IC0xIGMtMTgKLTEgLTQ2IC01IC02MyAtOXogbS02MiAtMTUzIGMzIC03IDMgLTI1IDAgLTQwIC04IC00MCAtNDAgLTM2IC01MSA2IC01IDE3IC03CjM1IC01IDQwIDcgMTIgNTEgOCA1NiAtNnoiLz4KPHBhdGggZD0iTTI3MDcgNTU3IGMtMTUgLTEwIC0xNiAtMTUgLTUgLTMwIDEyIC0xNiA1OCAtMTcgNzUyIC0xNyA1MzkgMCA3NDIKMyA3NTIgMTEgMTkgMTUgMTggMzUgLTIgNDMgLTkgMyAtMzQ1IDYgLTc0OCA2IC01NzQgMCAtNzM2IC0zIC03NDkgLTEzeiIvPgo8cGF0aCBkPSJNMTk5MCA1MTUgYy03IC04IC0xOSAtMTUgLTI3IC0xNSAtNyAwIC0xNiAtNyAtMTkgLTE1IC00IC04IC0xMCAtMTUKLTE1IC0xNSAtNSAwIC0zMSAtMjMgLTU4IC01MSAtNDAgLTQyIC01MCAtNTkgLTU1IC05OSAtNCAtMjYgLTIgLTU5IDMgLTczCmwxMCAtMjYgOTggNSBjNTQgMyAxMzEgMiAxNzEgLTMgODggLTExIDkxIC00IDMyIDczIC0yMiAyOSAtNDAgNTkgLTQwIDY3IDAgNwotNyAyMiAtMTUgMzMgLTggMTAgLTE1IDM1IC0xNSA1NCAtMSA1OCAtMTAgODAgLTM1IDgwIC0xMiAwIC0yOCAtNyAtMzUgLTE1eiIvPgo8cGF0aCBkPSJNNjAzMSA0OTggYy01IC0xOCAtMTEgLTczIC0xMyAtMTIzIGwtMyAtOTAgMjUgMCBjMjMgMCAyNiA1IDMyIDU1IDQKMzAgMTIgODIgMTggMTE0IDExIDY3IDggNzYgLTI1IDc2IC0xOCAwIC0yNiAtOCAtMzQgLTMyeiIvPgo8cGF0aCBkPSJNNzI2MyA1MTggYy02IC03IC0xMyAtNjQgLTE2IC0xMjUgbC03IC0xMTMgMjUgMCBjMjkgMCAzMiAxMSA0NSAxMjEKMTQgMTI0IDE0IDEyOSAtMTQgMTI5IC0xMyAwIC0yOCAtNiAtMzMgLTEyeiIvPgo8cGF0aCBkPSJNNDk1NSA1MDIgYy02IC00IC0xNiAtNDEgLTIzIC04MiAtNiAtNDEgLTE1IC05MCAtMTggLTEwNyAtNiAtMzIgLTUKLTMzIDI1IC0zMyAxNyAwIDMyIDUgMzIgMTMgMSA2IDMgMTkgNCAyNyAxIDggMyAyMSA0IDI5IDIgMTkgNDAgLTE1IDUyIC00NiA2Ci0xNyAxNyAtMjMgMzkgLTIzIDM5IDAgMzkgMjAgLTEgNzAgLTM1IDQ0IC0zNSA0NiAyNCAxMDMgMzEgMzAgMzAgNTcgLTIgNTcKLTIxIDAgLTQ1IC0yMCAtNjEgLTUxIC0xNiAtMjggLTMwIC0yMyAtMzAgMTAgMCAxNyAtNiAzMSAtMTYgMzUgLTE5IDcgLTE3IDcKLTI5IC0yeiIvPgo8cGF0aCBkPSJNNTYzMSA1MDIgYy0xNiAtNSAtMTQgLTM3IDMgLTUxIDcgLTYgMjEgLTkgMzAgLTUgMzYgMTQgMjcgLTI2IC0xOQotODYgLTI1IC0zMyAtNDMgLTY1IC00MCAtNzAgMyAtNiA0NCAtMTAgOTEgLTEwIDgzIDAgODUgMSA4MiAyMyAtMiAxOCAtMTAgMjMKLTQwIDI1IC0yMSAyIC0zOCA0IC0zOCA2IDAgMTQgMzcgNzAgNjkgMTA2IDI0IDI3IDM2IDQ5IDMxIDU0IC05IDkgLTE0OCAxNQotMTY5IDh6Ii8+CjxwYXRoIGQ9Ik02NDcyIDQ5OCBjLTcgLTcgLTEyIC0yNiAtMTIgLTQyIC0xIC0xNyAtNyAtNTggLTE0IC05MSAtMTUgLTc0IC0xMgotODUgMjQgLTg1IDI5IDAgMjkgMSAzMiA2MyAyIDM0IDcgNjEgMTMgNjEgOCAtMSA0NyAtNjMgNzEgLTExMSA5IC0xOSA2MSAtMTYKNjggMyAzIDkgNiAyOSA2IDQ0IDAgMTYgNyA1NSAxNSA4NyAxMyA0OSAxMyA1OSAxIDcxIC04IDkgLTIyIDExIC0zNSA3IC0xOAotNSAtMjEgLTE0IC0yMSAtNjUgMCAtMzIgLTQgLTYxIC04IC02NCAtMTAgLTYgLTQ2IDQwIC01NiA3MCAtOCAyNiAtNDMgNjQKLTU5IDY0IC03IDAgLTE4IC01IC0yNSAtMTJ6Ii8+CjxwYXRoIGQ9Ik03NDU0IDQ5MyBjLTMgLTEwIC0xMyAtMzEgLTIxIC00OCAtMTAgLTIyIC0xMyAtNTYgLTExIC0xMjUgMyAtODcgNQotOTUgMjMgLTk1IDE5IDAgMjAgNyAyMCAxMDAgMCA4MCA0IDEwNSAxOSAxMjcgMTAgMTYgMTYgMzUgMTIgNDMgLTcgMjEgLTM1CjE5IC00MiAtMnoiLz4KPHBhdGggZD0iTTc5OTYgNTAxIGMtMyAtNSAxIC0yNSA5IC00NSAxNyAtNDAgMjAgLTkyIDYgLTEwMCAtNSAtNCAtMTIgLTI0Ci0xNiAtNDUgLTQgLTIyIC0xMyAtNDIgLTIxIC00NSAtMTkgLTcgLTE4IC0zNSAyIC00MyAyMiAtOCA2NCAzNSA2NCA2NyAwIDE0CjUgMzEgMTEgMzcgMTcgMTcgMTMgMTI4IC03IDE1OCAtMTYgMjUgLTM4IDMzIC00OCAxNnoiLz4KPHBhdGggZD0iTTc1MzkgNDczIGMtMTkgLTUwIC0zMSAtMTczIC0xOCAtMTg5IDE2IC0yMCAzOSAwIDM5IDM1IDAgMjEgOCAzMAo0MCA0NCA0NSAxOSA2MiA1MCA0OCA4NiAtMTIgMzIgLTM3IDUwIC03MSA1MSAtMjEgMCAtMzAgLTcgLTM4IC0yN3ogbTYzIC02NQpjLTIwIC0yMCAtMzYgNSAtMjEgMzMgbDEyIDI0IDEwIC0yMyBjNyAtMTYgNyAtMjYgLTEgLTM0eiIvPgo8cGF0aCBkPSJNNzY3NSA0OTAgYy04IC0xMyAzIC0zMCAyMCAtMzAgMTggMCAyOCAtMzUgMTcgLTU3IC0xNSAtMjggLTIzIC0xMDcKLTEzIC0xMjIgMjQgLTM3IDYxIDM4IDYxIDEyMyAwIDQ2IDMzIDgwIDYxIDYzIDEwIC02IDIxIC0yNCAyNCAtMzkgNCAtMTUgMTEKLTMwIDE2IC0zMyAxMyAtOCAxMSAtNTkgLTIgLTcyIC0xOCAtMTggLTIgLTQzIDI2IC00MyAyMiAwIDI1IDQgMjUgMzggMCAzNAozMSAxMTAgNTEgMTIyIDUgMyAxMCAxNyAxMSAzMCA1IDQxIC0yNSAzNCAtNTEgLTEyIGwtMjQgLTQzIC0xMSAyNiBjLTIxIDUxCi0zMSA1NiAtMTIwIDU4IC00OSAxIC04NyAtMyAtOTEgLTl6Ii8+CjxwYXRoIGQ9Ik04MTk2IDQ2OCBjLTggLTE4IC0xNyAtNjUgLTIxIC0xMDQgLTggLTgxIDIgLTk3IDU3IC05MiAyNSAyIDM0IDgKMzYgMjUgMiAxNiAtMyAyMiAtMjAgMjUgLTE4IDIgLTIyIDggLTIwIDI4IDE1IDEyOCAxNCAxNTAgLTIgMTUwIC0xMCAwIC0yMwotMTQgLTMwIC0zMnoiLz4KPHBhdGggZD0iTTgyOTAgNDg1IGMwIC05IDcgLTE4IDE1IC0yMSAxOCAtNyAyMSAtMTA0IDUgLTEzNCAtMTQgLTI2IC0yIC01MgoyNCAtNDggMTkgMyAyMiAxMiAzMCA4NiA3IDc1IDExIDg0IDMyIDkyIDEzIDUgMjQgMTYgMjQgMjUgMCAxMiAtMTMgMTUgLTY1CjE1IC01MiAwIC02NSAtMyAtNjUgLTE1eiIvPgo8cGF0aCBkPSJNODQ0NSA0NjMgYy0zIC0yMSAtMTAgLTU0IC0xNSAtNzQgLTYgLTIwIC0xMCAtNTMgLTEwIC03MyAwIC0zNCAyCi0zNiAzMyAtMzcgODQgLTMgMTA4IDUgMTM1IDQ0IDM0IDUxIDI5IDk2IC0xMyAxNDAgLTMxIDMyIC00MiAzNyAtODAgMzcgLTQzCjAgLTQ0IC0xIC01MCAtMzd6IG05MiAtMjUgYzEzIC0xMiAyMyAtMzMgMjMgLTQ4IDAgLTM0IC0zNSAtNzIgLTYzIC02OCAtMTkgMwotMjIgOCAtMTkgNDggNiA5NSAxNyAxMDggNTkgNjh6Ii8+CjxwYXRoIGQ9Ik02OTM4IDQ1OCBjLTYgLTEzIC0xMyAtNTggLTE0IC0xMDEgbC0zIC03OCAyNyAzIGMyNCAzIDI3IDggMzAgNDMgMgoyMiAxMCA0OCAxOSA1NyAxOSAyMSAxMCA4MyAtMTMgOTIgLTI1IDEwIC0zMyA3IC00NiAtMTZ6Ii8+CjxwYXRoIGQ9Ik01MzEyIDQwMyBjLTIyIC0yOCAtMzIgLTM0IC0zNSAtMjMgLTMgOCAtOCAyMyAtMTEgMzMgLTkgMjkgLTI2IDIyCi02MCAtMjcgLTEzIC0xOSAtMTQgLTE4IC0yNyAxMCAtMTggMzYgLTUyIDQwIC01NyA2IC0yIC0xMyAyIC0zMCA5IC0zOCA2IC04CjE1IC0yOSAxOCAtNDcgOSAtNDMgNDYgLTUxIDYxIC0xMyAxMiAzMyAzMyAzMyA0OCAxIDE0IC0yOSAzMyAtMzIgNTMgLTcgMjcKMzEgNzAgMTIyIDY0IDEzMiAtMTIgMTkgLTMzIDEwIC02MyAtMjd6Ii8+CjxwYXRoIGQ9Ik01NDMzIDQxMyBjLTQwIC0zOCAtNDggLTY1IC0yOCAtMTAzIDE1IC0yOSAxOCAtMzAgODAgLTMwIDc2IDAgODUgOQo4NSA5NCBsMCA1NiAtMzIgLTEgYy0xOCAtMSAtNDIgMiAtNTQgNiAtMTUgNSAtMjkgLTEgLTUxIC0yMnogbTc1IC02MCBjLTMKLTMyIC00NCAtNDYgLTU0IC0xOSAtMTAgMjYgNCA0NiAzMSA0NiAyMyAwIDI2IC00IDIzIC0yN3oiLz4KPHBhdGggZD0iTTYyMzcgNDMzIGMtNCAtMyAtNyAtMTkgLTcgLTM1IDAgLTQwIC0xNyAtNjggLTQxIC02OCAtMTggMCAtMjAgNAotMTMgNDUgNSAzNyAzIDQ2IC0xMSA1MSAtMjUgMTAgLTM3IC05IC00MyAtNjQgLTYgLTcwIDE2IC04OSA5OCAtODIgMzcgMyA0NQoxNCA2MCA3NSAxMSA0NCAxMSA1NyAwIDcwIC0xMyAxNiAtMzIgMjAgLTQzIDh6Ii8+CjxwYXRoIGQ9Ik02NzQxIDQxNCBjLTI2IC0yMiAtMzEgLTMzIC0zMSAtNzAgMCAtMzMgNSAtNDYgMTkgLTU0IDIzIC0xMiAxMjgKLTE0IDEzNCAtMiAzIDQgNyAzNiA5IDcyIGwzIDY1IC0zNyAwIGMtMjAgMCAtNDAgMyAtNDQgOCAtMTIgMTIgLTIxIDkgLTUzCi0xOXogbTg2IC01MCBjNSAtMTQgLTI0IC00NCAtNDIgLTQ0IC0xNiAwIC0yNiAyNSAtMTggNDYgNiAxNyA1NCAxNiA2MCAtMnoiLz4KPHBhdGggZD0iTTcwNzQgNDIwIGMtNDUgLTI5IC01NyAtMTA3IC0yMCAtMTMyIDIwIC0xNCAxMjYgLTkgMTMyIDUgMyA4IDYgNDAKNyA3MyBsMiA1OSAtMzIgLTIgYy0xNyAtMiAtMzUgMiAtMzggNyAtOSAxNCAtMTYgMTMgLTUxIC0xMHogbTcxIC01MCBjOSAtMTQKLTEzIC01MCAtMzEgLTUwIC0xNyAwIC0yOCAyNCAtMjAgNDUgNiAxNyA0MiAyMCA1MSA1eiIvPgo8cGF0aCBkPSJNNTgzMiA0MTcgYy02IC03IC0xNCAtMzEgLTE4IC01NCAtOCAtNTUgMTggLTgzIDc5IC04MyA1NyAwIDY0IDcgNzgKNjggMTMgNjEgOCA4MiAtMjAgODIgLTE5IDAgLTMxIC0yNSAtMzEgLTY3IDAgLTI2IC0zNyAtNTIgLTQ1IC0zMSAtMyA3IC00IDMxCi0zIDUzIDMgNDIgLTE4IDU5IC00MCAzMnoiLz4KPHBhdGggZD0iTTYzMjQgMzg1IGMtMTAgLTI1IDQgLTQ1IDMwIC00NSAzNCAwIDU2IDEwIDU2IDI2IDAgMzAgLTc2IDQ3IC04NgoxOXoiLz4KPC9nPgo8L3N2Zz4K\" alt=\"First Technology Logo\" class=\"logo\">\n            </div>\n            <div class=\"header-content\">\n                <h1>AD Domain Security & Compliance Audit Report</h1>\n                <p style=\"font-size: 1.3em; font-weight: bold;\">Customer: $CustomerName</p>\n            </div>\n            <div class=\"header-info\">\n                <p>Audit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</p>\n                <p>Auditor/Engineer: $($Summary.TechnicianName)</p>\n            </div>\n        </div>\n        \n        <div class=\"risk-banner\">\n            OVERALL SECURITY RISK: $($Summary.OverallRisk)\n        </div>\n        \n        <div class=\"metrics-grid\">\n            <div class=\"metric-card\">\n                <div class=\"metric-number critical\">$($Summary.CriticalFindings)</div>\n                <div>Critical Issues</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number high\">$($Summary.HighFindings)</div>\n                <div>High Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number medium\">$($Summary.MediumFindings)</div>\n                <div>Medium Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number low\">$($Summary.LowFindings)</div>\n                <div>Low Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\" style=\"color: #17a2b8;\">$($Summary.PassedFindings)</div>\n                <div>Controls Passed</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.IssuesFindings)</div>\n                <div>Issues Found</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.TotalFindings)</div>\n                <div>Total Checks</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$(($script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | Group-Object ComplianceFramework).Count)</div>\n                <div>Compliance Frameworks</div>\n            </div>\n        </div>\n\n        <!-- Domain Controller Health Dashboard -->\n        <div class=\"dc-dashboard\">\n            <div class=\"dc-dashboard-header\">\n                <h2>🖥️ Domain Controller Health Dashboard \n                    <span class=\"dc-count\">$($script:DomainControllerHealthData.Count) Controllers</span>\n                </h2>\n            </div>\n            <div class=\"dc-grid\">\n$(\n    if ($script:DomainControllerHealthData) {\n        foreach ($dc in $script:DomainControllerHealthData) {\n            $statusClass = switch ($dc.Status) {\n                'Healthy' { 'healthy' }\n                'Warning' { 'warning' }\n                'Critical' { 'critical' }\n                default { 'healthy' }\n            }\n            \n            $servicesHtml = ''\n            foreach ($service in $dc.Services.GetEnumerator()) {\n                $serviceClass = if ($service.Value -eq 'Running') { 'running' } else { 'stopped' }\n                $servicesHtml += \"<span class='dc-service $serviceClass'>$($service.Key)</span>\"\n            }\n            \n            $testsHtml = ''\n            foreach ($test in $dc.Tests.GetEnumerator()) {\n                $testClass = if ($test.Value -eq 'Passed') { 'passed' } else { 'failed' }\n                $testsHtml += \"<span class='dc-test $testClass'>$($test.Key)</span>\"\n            }\n            \n            $lastContactTime = $dc.LastContact.ToString('HH:mm:ss')\n            \n            @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header $statusClass\">\n                        <span>$($dc.Name.Split('.')[0])</span>\n                        <span>$($dc.Status.ToUpper())</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Site:</span>\n                            <span class=\"dc-info-value\">$($dc.Site)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Operating System:</span>\n                            <span class=\"dc-info-value\">$($dc.OS)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">IP Address:</span>\n                            <span class=\"dc-info-value\">$($dc.IPv4)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">FSMO Roles:</span>\n                            <span class=\"dc-info-value\">$(if ($dc.FSMORoles -and $dc.FSMORoles -ne 'None') { $dc.FSMORoles } else { 'None' })</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Last Contact:</span>\n                            <span class=\"dc-info-value\">$lastContactTime</span>\n                        </div>\n                        <div class=\"dc-services\">\n                            <strong>Services:</strong><br>\n                            $servicesHtml\n                        </div>\n                        <div class=\"dc-tests\">\n                            <strong>DCDIAG Tests:</strong><br>\n                            $testsHtml\n                        </div>\n                    </div>\n                </div>\n\"@\n        }\n    } else {\n        @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header healthy\">\n                        <span>Domain Controllers</span>\n                        <span>STATUS UNKNOWN</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <p>Domain controller health data not available. Extended health check may be disabled.</p>\n                    </div>\n                </div>\n\"@\n    }\n)\n            </div>\n        </div>\n\n        <div class=\"report-links\">\n            <h3>Download Detailed Reports</h3>\n            <a href=\"Infrastructure-Audit-Report.xlsx\">📊 Excel Report</a>\n            <a href=\"Infrastructure-Audit-Report.csv\">📄 CSV Report</a>\n            <a href=\"Executive-Summary.txt\">📋 Executive Summary</a>\n        </div>\n        \n        <div class=\"section\">\n            <h2>📋 Detailed Security Findings</h2>\n            <div style=\"text-align: right; margin: 10px 0;\">\n                <button onclick=\"expandAll()\" style=\"margin-right: 10px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;\">Expand All</button>\n                <button onclick=\"collapseAll()\" style=\"padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;\">Collapse All</button>\n            </div>\n            <div class=\"findings-container\">\n$(\n    # Group findings by severity for better organization\n    $criticalFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }\n    $highFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'High' }\n    $mediumFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    $lowFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }\n    $passedFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }\n    \n    $allGroupedFindings = @()\n    if ($criticalFindings.Count -gt 0) { $allGroupedFindings += @{Title='🔴 CRITICAL FINDINGS'; Findings=$criticalFindings; Class='critical-section'} }\n    if ($highFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟠 HIGH PRIORITY FINDINGS'; Findings=$highFindings; Class='high-section'} }\n    if ($mediumFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟡 MEDIUM PRIORITY FINDINGS'; Findings=$mediumFindings; Class='medium-section'} }\n    if ($lowFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟢 LOW PRIORITY FINDINGS'; Findings=$lowFindings; Class='low-section'} }\n    if ($passedFindings.Count -gt 0) { $allGroupedFindings += @{Title='✅ SECURITY CONTROLS PASSED'; Findings=$passedFindings; Class='passed-section'} }\n    \n    foreach ($group in $allGroupedFindings) {\n        $output = @\"\n                <div class=\"finding-group $($group.Class)\">\n                    <h3 class=\"finding-group-title\">$($group.Title) ($($group.Findings.Count) Issues)</h3>\n\"@\n        \n        foreach ($finding in $group.Findings) {\n            $severityIcon = switch ($finding.Severity) {\n                'Critical' { '🔴' }\n                'High' { '🟠' }\n                'Medium' { '🟡' }\n                'Low' { '🟢' }\n                'Passed' { '✅' }\n                default { '⚪' }\n            }\n            \n            $evidenceSection = if ($finding.Evidence -and $finding.Evidence.Trim() -ne '') {\n                @\"\n                        <div class=\"evidence-section\">\n                            <h5>📊 Evidence/Data:</h5>\n                            <pre class=\"evidence-data\">$($finding.Evidence)</pre>\n                        </div>\n\"@\n            } else { '' }\n            \n            $complianceSection = if ($finding.ComplianceFramework -and $finding.ComplianceFramework.Trim() -ne '') {\n                \"<p><strong>📝 Compliance Framework:</strong> <span class='compliance-tag'>$($finding.ComplianceFramework)</span></p>\"\n            } else { '' }\n            \n            $output += @\"\n                    <div class=\"finding-item $($finding.Severity.ToLower())-finding\">\n                        <div class=\"finding-header\" onclick=\"toggleFinding('$($finding.ID)')\">\n                            <div>\n                                <h4 class=\"finding-title\">$severityIcon $($finding.Title)</h4>\n                                <div class=\"finding-meta\">\n                                    <span class=\"finding-id\">ID: $($finding.ID)</span>\n                                    <span class=\"finding-category\">$($finding.Category)</span>\n                                    <span class=\"finding-type\">$($finding.Type)</span>\n                                    <span class=\"severity-badge $($finding.Severity.ToLower())\">$($finding.Severity.ToUpper())</span>\n                                </div>\n                            </div>\n                            <span class=\"finding-toggle\" id=\"toggle-$($finding.ID)\">+</span>\n                        </div>\n                        \n                        <div class=\"finding-content\" id=\"content-$($finding.ID)\">\n                            <div class=\"description-section\">\n                                <h5>📋 Description:</h5>\n                                <p>$($finding.Description)</p>\n                            </div>\n                            \n                            <div class=\"impact-section\">\n                                <h5>⚠️ Business Impact:</h5>\n                                <p>$($finding.Impact)</p>\n                            </div>\n                            \n                            <div class=\"recommendation-section\">\n                                <h5>🔧 Recommended Action:</h5>\n                                <p>$($finding.Recommendation)</p>\n                            </div>\n                            \n                            $evidenceSection\n                            \n                            <div class=\"finding-footer\">\n                                $complianceSection\n                                <p><strong>⏰ Discovered:</strong> $($finding.Timestamp.ToString('yyyy-MM-dd HH:mm:ss'))</p>\n                            </div>\n                        </div>\n                    </div>\n\"@\n        }\n        \n        $output += @\"\n                </div>\n\"@\n        $output\n    }\n)\n            </div>\n        </div>\n        \n\n\n        <div class=\"section\">\n            <h2>📊 Executive Summary & Risk Analysis</h2>\n            <div class=\"executive-summary\">\n                <div class=\"summary-grid\">\n                    <div class=\"summary-card\">\n                        <h3>🔍 Audit Scope</h3>\n                        <ul>\n                            <li><strong>Customer:</strong> $CustomerName</li>\n                            <li><strong>Audit Date:</strong> $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</li>\n                            <li><strong>Engineer/Auditor:</strong> $($Summary.TechnicianName)</li>\n                            <li><strong>Systems Assessed:</strong> Active Directory Infrastructure</li>\n                            <li><strong>Note:</strong> Server infrastructure audit temporarily disabled</li>\n                        </ul>\n                    </div>\n                    \n                    <div class=\"summary-card\">\n                        <h3>⚠️ Risk Assessment</h3>\n                        <div class=\"risk-summary\">\n                            <p><strong>Overall Risk Level:</strong> <span class=\"risk-level $($Summary.OverallRisk.ToLower())\">$($Summary.OverallRisk)</span></p>\n                            <p><strong>Priority Actions:</strong> $($Summary.CriticalFindings + $Summary.HighFindings) immediate items</p>\n                            <p><strong>Total Findings:</strong> $($Summary.TotalFindings) security issues identified</p>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"key-findings\">\n                    <h3>🎯 Key Security Concerns</h3>\n                    <div class=\"concern-list\">\n$(\n    $topConcerns = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Sort-Object @{Expression={if($_.Severity -eq 'Critical'){1}else{2}}}, Title | Select-Object -First 5\n    if ($topConcerns.Count -gt 0) {\n        foreach ($concern in $topConcerns) {\n            $icon = if ($concern.Severity -eq 'Critical') { '🔴' } else { '🟠' }\n            @\"\n                        <div class=\"concern-item\">\n                            <span class=\"concern-icon\">$icon</span>\n                            <div class=\"concern-content\">\n                                <strong>$($concern.Category):</strong> $($concern.Title)\n                                <br><small>$($concern.Impact)</small>\n                            </div>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"concern-item\"><span class=\"concern-icon\">✅</span><div class=\"concern-content\">No critical security concerns identified</div></div>'\n    }\n)\n                    </div>\n                </div>\n                \n                <div class=\"compliance-overview\">\n                    <h3>📋 Compliance Framework Analysis</h3>\n                    <div class=\"compliance-grid\">\n$(\n    $complianceStats = $script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | \n        Group-Object ComplianceFramework | Sort-Object Count -Descending\n    \n    if ($complianceStats.Count -gt 0) {\n        foreach ($framework in $complianceStats) {\n            $criticalCount = ($framework.Group | Where-Object { $_.Severity -eq 'Critical' }).Count\n            $highCount = ($framework.Group | Where-Object { $_.Severity -eq 'High' }).Count\n            @\"\n                        <div class=\"compliance-item\">\n                            <h4>$($framework.Name)</h4>\n                            <p>$($framework.Count) findings ($criticalCount critical, $highCount high priority)</p>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"compliance-item\"><h4>General Security</h4><p>Compliance framework mapping in progress</p></div>'\n    }\n)\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        $(if ($script:DomainControllerHealthData) { @\"\n        <div class=\"section\">\n            <h2>🏥 Domain Controller Health Dashboard</h2>\n            <div style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; overflow-x: auto;\">\n                <table style=\"width: 100%; border-collapse: collapse; font-size: 9pt; min-width: 1200px;\">\n                    <thead>\n                        <tr>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Server</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Site</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Ping</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Uptime (hrs)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (%)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (GB)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Time Sync</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NTDS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NetLogon</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Connectivity</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Replication</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Services</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Health Status</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n$(foreach ($dc in $script:DomainControllerHealthData) {\n    $fsmoDisplay = if ($dc.FSMORoles -and $dc.FSMORoles.Count -gt 0) { ($dc.FSMORoles -join '<br>') } else { 'None' }\n    @\"\n                        <tr>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; font-weight: bold;\">$($dc.Server)<br><small style=\"color: #666;\">$fsmoDisplay</small></td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center;\">$($dc.Site)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSTest -eq 'Success') { '#6BBF59' } elseif ($dc.DNSTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.DNSTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.PingTest -eq 'Success') { '#6BBF59' } elseif ($dc.PingTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.PingTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.UptimeHours -eq 'Fail' -or $dc.UptimeHours -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.UptimeHours -lt 24) { '#FFD966' } else { '#6BBF59' });\">$($dc.UptimeHours)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpacePercent -eq 'Fail' -or $dc.OSFreeSpacePercent -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 15) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpacePercent)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpaceGB -eq 'Fail' -or $dc.OSFreeSpaceGB -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 10) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpaceGB)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.TimeOffset -eq 'Fail') { '#D9534F; color: white' } elseif ([Math]::Abs($dc.TimeOffset) -gt 5) { '#D9534F; color: white' } else { '#6BBF59' });\">$($dc.TimeOffset)s</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DNSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NTDSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NTDSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NetLogonService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NetLogonService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagConnectivity -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagConnectivity)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagReplications -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagReplications)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagServices -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagServices)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; font-weight: bold; background: $(if ($dc.OverallHealth -eq 'Healthy') { '#6BBF59' } elseif ($dc.OverallHealth -eq 'Warning') { '#FFD966' } else { '#D9534F; color: white' });\">$($dc.OverallHealth)</td>\n                        </tr>\n\"@\n})\n                    </tbody>\n                </table>\n                <div style=\"margin-top: 10px; font-size: 9pt; color: #666;\">\n                    <strong>Legend:</strong> \n                    <span style=\"background: #6BBF59; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Pass</span>\n                    <span style=\"background: #FFD966; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Warning</span>\n                    <span style=\"background: #D9534F; color: white; padding: 2px 6px; border-radius: 3px;\">Fail</span>\n                </div>\n            </div>\n        </div>\n\"@ })\n        \n        <div style=\"text-align: center; margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 10px;\">\n            <p><strong>Audit Summary</strong></p>\n            <p>This comprehensive audit assessed $($Summary.TotalFindings) security and compliance findings across the Active Directory infrastructure.</p>\n        </div>\n    </div>\n\n    <script>\n        // Collapsible findings functionality\n        function toggleFinding(findingId) {\n            const content = document.getElementById('content-' + findingId);\n            const toggle = document.getElementById('toggle-' + findingId);\n            \n            if (content.classList.contains('show')) {\n                content.classList.remove('show');\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            } else {\n                content.classList.add('show');\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            }\n        }\n        \n        // Expand/Collapse all functions\n        function expandAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.add('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            });\n        }\n        \n        function collapseAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.remove('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            });\n        }\n        \n        console.log('Infrastructure Audit Report loaded successfully');\n        console.log('Total findings: $($Summary.TotalFindings)');\n        console.log('Risk level: $($Summary.OverallRisk)');\n        \n        // Initialize all findings as collapsed by default\n        document.addEventListener('DOMContentLoaded', function() {\n            collapseAll();\n        });\n    </script>\n</body>\n</html>\n\"@\n    \n    $htmlContent | Out-File -FilePath $htmlPath -Encoding UTF8\n    Write-AuditLog \"HTML report saved: $htmlPath\" -Level Success\n}\n\nfunction New-ExcelReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Excel report...' -Level Info\n    \n    try {\n        $excelPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.xlsx'\n        \n        # Check if ImportExcel module is available\n        if (-not (Get-Module -ListAvailable -Name ImportExcel)) {\n            Write-AuditLog \"ImportExcel module not available, skipping Excel export\" -Level Warning\n            return\n        }\n        \n        Import-Module ImportExcel -SkipEditionCheck -ErrorAction SilentlyContinue\n        \n        # Summary sheet\n        $summaryData = [PSCustomObject]@{\n            'Metric' = 'Customer Name'; 'Value' = $Summary.CustomerName\n        }, [PSCustomObject]@{\n            'Metric' = 'Audit Date'; 'Value' = $Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss')\n        }, [PSCustomObject]@{\n            'Metric' = 'Technician'; 'Value' = $Summary.TechnicianName\n        }, [PSCustomObject]@{\n            'Metric' = 'Overall Risk Level'; 'Value' = $Summary.OverallRisk\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Findings'; 'Value' = $Summary.TotalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Critical Findings'; 'Value' = $Summary.CriticalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'High Findings'; 'Value' = $Summary.HighFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Servers'; 'Value' = $Summary.TotalServers\n        }, [PSCustomObject]@{\n            'Metric' = 'Online Servers'; 'Value' = $Summary.OnlineServers\n        }, [PSCustomObject]@{\n            'Metric' = 'High Risk Servers'; 'Value' = $Summary.HighRiskServers\n        }\n        \n        $summaryData | Export-Excel -Path $excelPath -WorksheetName 'Summary' -AutoSize -BoldTopRow\n        \n        # Findings sheet\n        $script:AuditFindings | Export-Excel -Path $excelPath -WorksheetName 'Security Findings' -AutoSize -BoldTopRow\n        \n        # Server results sheet\n        $script:ServerResults | Export-Excel -Path $excelPath -WorksheetName 'Server Status' -AutoSize -BoldTopRow\n        \n        Write-AuditLog \"Excel report saved: $excelPath\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating Excel report: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\nfunction New-CSVReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating CSV reports...' -Level Info\n    \n    # Findings CSV\n    $findingsPath = Join-Path $script:OutputDir 'Audit-Findings.csv'\n    $script:AuditFindings | Export-Csv -Path $findingsPath -NoTypeInformation\n    \n    # Server status CSV\n    $serversPath = Join-Path $script:OutputDir 'Server-Status.csv'\n    $script:ServerResults | Export-Csv -Path $serversPath -NoTypeInformation\n    \n    Write-AuditLog \"CSV reports saved: $findingsPath, $serversPath\" -Level Success\n}\n\nfunction New-MarkdownReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Markdown report...' -Level Info\n    \n    $markdownPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.md'\n    \n    $markdownContent = @\"\n# Infrastructure Security Audit Report\n\n**Customer:** $CustomerName  \n**Audit Date:** $($Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss'))  \n**Technician:** $($Summary.TechnicianName)  \n**Overall Risk Level:** **$($Summary.OverallRisk)**\n\n## Executive Summary\n\nThis infrastructure audit assessed $($Summary.TotalServers) servers and identified $($Summary.TotalFindings) security and configuration findings.\n\n### Key Metrics\n\n| Metric | Count |\n|--------|-------|\n| Critical Findings | $($Summary.CriticalFindings) |\n| High Priority Findings | $($Summary.HighFindings) |\n| Medium Priority Findings | $($Summary.MediumFindings) |\n| Low Priority Findings | $($Summary.LowFindings) |\n| Total Servers Audited | $($Summary.TotalServers) |\n| Online Servers | $($Summary.OnlineServers) |\n| High Risk Servers | $($Summary.HighRiskServers) |\n\n## Security Findings\n\n$(\n    $script:AuditFindings | ForEach-Object {\n        @\"\n### $($_.Title) [$($_.Severity)]\n\n**Category:** $($_.Category)  \n**Type:** $($_.Type)  \n**Compliance Framework:** $($_.ComplianceFramework)\n\n**Description:** $($_.Description)\n\n**Impact:** $($_.Impact)\n\n**Recommendation:** $($_.Recommendation)\n\n$(if ($_.Evidence) { \"**Evidence:**`n``````n$($_.Evidence)`n``````n\" })\n\n---\n\"@\n    }\n)\n\n## Server Infrastructure Status\n\n| Server Name | Status | Operating System | Risk Score | Security Issues | Performance Issues |\n|-------------|--------|------------------|------------|-----------------|-------------------|\n$(\n    $script:ServerResults | ForEach-Object {\n        \"| $($_.ServerName) | $($_.PingStatus) | $($_.OperatingSystem) | $($_.RiskScore) | $($_.SecurityIssues.Count) | $($_.PerformanceIssues.Count) |\"\n    }\n)\n\n## Recommendations Summary\n\n### Immediate Actions Required (Critical/High)\n$(\n    $criticalAndHigh = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') }\n    if ($criticalAndHigh.Count -gt 0) {\n        $criticalAndHigh | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\n### Short-term Improvements (Medium)\n$(\n    $medium = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    if ($medium.Count -gt 0) {\n        $medium | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No medium priority items identified\"\n    }\n)\n\n---\n\n*Report generated by Master Infrastructure Audit Script v$($script:Version)*  \n*Audit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes*\n\"@\n    \n    $markdownContent | Out-File -FilePath $markdownPath -Encoding UTF8\n    Write-AuditLog \"Markdown report saved: $markdownPath\" -Level Success\n}\n\nfunction New-ExecutiveSummary {\n    param($Summary)\n    \n    Write-AuditLog 'Generating executive summary...' -Level Info\n    \n    $execSummaryPath = Join-Path $script:OutputDir 'Executive-Summary.txt'\n    \n    $execSummary = @\"\nINFRASTRUCTURE SECURITY AUDIT - EXECUTIVE SUMMARY\n================================================================\n\nCustomer: $CustomerName\nAudit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))\nEngineer/Auditor: $($Summary.TechnicianName)\nAudit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes\n\nOVERALL RISK ASSESSMENT: $($Summary.OverallRisk)\n\nFINDINGS SUMMARY:\n- Critical Issues: $($Summary.CriticalFindings)\n- High Priority: $($Summary.HighFindings)  \n- Medium Priority: $($Summary.MediumFindings)\n- Low Priority: $($Summary.LowFindings)\n- Total Findings: $($Summary.TotalFindings)\n\nINFRASTRUCTURE SUMMARY:\n- Total Servers: $($Summary.TotalServers)\n- Online Servers: $($Summary.OnlineServers)\n- Offline Servers: $($Summary.OfflineServers)\n- High Risk Servers: $($Summary.HighRiskServers)\n\nIMMEDIATE ACTIONS REQUIRED:\n$(\n    $immediateActions = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Select-Object -First 5\n    if ($immediateActions.Count -gt 0) {\n        $immediateActions | ForEach-Object { \"- $($_.Category): $($_.Title)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\nCOMPLIANCE ASSESSMENT:\n$(\n    $frameworks = $script:AuditFindings | Group-Object ComplianceFramework | Where-Object { $_.Name -ne '' }\n    if ($frameworks.Count -gt 0) {\n        $frameworks | ForEach-Object { \"- $($_.Name): $($_.Count) findings\" }\n    } else {\n        \"- Compliance frameworks assessment pending\"\n    }\n)\n\nThis executive summary provides a high-level overview of the infrastructure \nsecurity assessment. Detailed findings, recommendations, and remediation \nprocedures are available in the comprehensive audit reports.\n\n================================================================\n\"@\n    \n    $execSummary | Out-File -FilePath $execSummaryPath -Encoding UTF8\n    Write-AuditLog \"Executive summary saved: $execSummaryPath\" -Level Success\n}\n\n# ==============================================================================\n# MAIN EXECUTION LOGIC\n# ==============================================================================\n\nfunction Start-MasterInfrastructureAudit {\n    # Display banner\n    Write-Host \"\"\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"MASTER INFRASTRUCTURE AUDIT SCRIPT v$($script:Version)\" -ForegroundColor Cyan\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"Customer: $CustomerName\" -ForegroundColor White\n    Write-Host \"Technician: $TechnicianName\" -ForegroundColor White\n    Write-Host \"Start Time: $($script:StartTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -ForegroundColor White\n    Write-Host \"Output Directory: $script:OutputDir\" -ForegroundColor White\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"\"\n    \n    Write-AuditLog \"Starting Master Infrastructure Audit for $CustomerName\" -Level Header\n    Write-AuditLog \"Technician: $TechnicianName\" -Level Info\n    Write-AuditLog \"Output Directory: $script:OutputDir\" -Level Info\n    Write-AuditLog \"Export Formats: $($ExportFormats -join ', ')\" -Level Info\n    \n    try {\n        # Initialize logo path for reports\n        $script:LogoPath = Initialize-LogoPath\n        Write-AuditLog \"Logo path initialized: $($script:LogoPath)\" -Level Info\n        \n        # Initialize task counting\n        $script:TotalTasks = 1 # Report Generation is always done\n        if (-not $SkipADHealthChecks) { $script:TotalTasks++ }\n        if (-not $SkipServerAudit) { $script:TotalTasks++ }\n        \n        # Active Directory Health Assessment\n        if (-not $SkipADHealthChecks) {\n            Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Starting Active Directory assessment...\"\n            $adSuccess = Test-ADInfrastructureHealth\n            $script:CompletedTasks++\n            \n            if (-not $adSuccess) {\n                Write-AuditLog \"Active Directory assessment failed or incomplete\" -Level Warning\n            }\n        } else {\n            Write-AuditLog \"Skipping Active Directory health checks as requested\" -Level Info\n        }\n        \n        # Server Infrastructure Audit - Currently disabled due to hanging issues\n        if (-not $SkipServerAudit) {\n            Write-AuditLog \"Server infrastructure audit temporarily disabled due to connectivity issues\" -Level Warning\n            Write-AuditLog \"Focus on Active Directory findings - server audit can be run separately if needed\" -Level Info\n            $script:CompletedTasks++\n        } else {\n            Write-AuditLog \"Skipping server infrastructure audit as requested\" -Level Info\n        }\n        \n        # Generate Reports\n        Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Generating comprehensive reports...\"\n        New-ComprehensiveAuditReport\n        $script:CompletedTasks++\n        \n        # Display final summary\n        $executionTime = (Get-Date) - $script:StartTime\n        \n        Write-Host \"\"\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"AUDIT COMPLETED SUCCESSFULLY\" -ForegroundColor Green\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"\"\n        \n        $summary = Get-AuditSummaryStatistics\n        \n        Write-Host \"AUDIT SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"  Customer: $CustomerName\" -ForegroundColor White\n        Write-Host \"  Overall Risk Level: \" -NoNewline -ForegroundColor White\n        \n        switch ($summary.OverallRisk) {\n            'CRITICAL' { Write-Host $summary.OverallRisk -ForegroundColor Red }\n            'HIGH' { Write-Host $summary.OverallRisk -ForegroundColor DarkRed }\n            'MEDIUM' { Write-Host $summary.OverallRisk -ForegroundColor Yellow }\n            'LOW' { Write-Host $summary.OverallRisk -ForegroundColor Green }\n        }\n        \n        Write-Host \"\"\n        Write-Host \"FINDINGS:\" -ForegroundColor Cyan\n        Write-Host \"  Critical: \" -NoNewline -ForegroundColor White\n        Write-Host $summary.CriticalFindings -ForegroundColor $(if ($summary.CriticalFindings -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High:     \" -NoNewline -ForegroundColor White\n        Write-Host $summary.HighFindings -ForegroundColor $(if ($summary.HighFindings -gt 0) { 'DarkRed' } else { 'Green' })\n        Write-Host \"  Medium:   \" -NoNewline -ForegroundColor White\n        Write-Host $summary.MediumFindings -ForegroundColor $(if ($summary.MediumFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Low:      \" -NoNewline -ForegroundColor White\n        Write-Host $summary.LowFindings -ForegroundColor $(if ($summary.LowFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Total:    \" -NoNewline -ForegroundColor White\n        Write-Host $summary.TotalFindings -ForegroundColor Cyan\n        \n        Write-Host \"\"\n        Write-Host \"INFRASTRUCTURE:\" -ForegroundColor Cyan\n        Write-Host \"  Total Servers:    $($summary.TotalServers)\" -ForegroundColor White\n        Write-Host \"  Online Servers:   $($summary.OnlineServers)\" -ForegroundColor Green\n        Write-Host \"  Offline Servers:  $($summary.OfflineServers)\" -ForegroundColor $(if ($summary.OfflineServers -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High Risk Servers: $($summary.HighRiskServers)\" -ForegroundColor $(if ($summary.HighRiskServers -gt 0) { 'Red' } else { 'Green' })\n        \n        Write-Host \"\"\n        Write-Host \"EXECUTION DETAILS:\" -ForegroundColor Cyan\n        Write-Host \"  Duration: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -ForegroundColor White\n        Write-Host \"  Reports Location: $script:OutputDir\" -ForegroundColor White\n        \n        if ($summary.CriticalFindings -gt 0 -or $summary.HighFindings -gt 0) {\n            Write-Host \"\"\n            Write-Host \"⚠️  URGENT ACTION REQUIRED ⚠️\" -ForegroundColor Red -BackgroundColor Yellow\n            Write-Host \"Critical and High priority issues require immediate attention!\" -ForegroundColor Red\n        }\n        \n        Write-AuditLog \"Master Infrastructure Audit completed successfully\" -Level Success\n        Write-AuditLog \"Total execution time: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -Level Info\n        \n        # Open output directory\n        try {\n            Start-Process $script:OutputDir\n        } catch {\n            Write-AuditLog \"Could not open output directory automatically\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"FATAL ERROR during audit execution: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Stack Trace: $($_.ScriptStackTrace)\" -Level Error\n        throw\n    } finally {\n        Write-Progress -Activity \"Master Infrastructure Audit\" -Completed\n    }\n}\n\n# ==============================================================================\n# SCRIPT EXECUTION\n# ==============================================================================\n\n# Check required modules before starting\nif (-not (Test-RequiredModules)) {\n    Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n    exit 1\n}\n\n# Parameter validation\nif (-not $CustomerName -or -not $TechnicianName) {\n    Write-Error \"CustomerName and TechnicianName parameters are required\"\n    exit 1\n}\n\n# Execute the main audit function\ntry {\n    Start-MasterInfrastructureAudit\n} catch {\n    Write-Host \"`nSCRIPT EXECUTION FAILED:\" -ForegroundColor Red\n    Write-Host $_.Exception.Message -ForegroundColor Red\n    Write-Host \"`nFor support, check the audit log in: $script:OutputDir\" -ForegroundColor Yellow\n    exit 1\n}\n\nWrite-Host \"`n✅ Master Infrastructure Audit completed successfully!\" -ForegroundColor Green\nWrite-Host \"📁 All reports and logs saved to: $script:OutputDir\" -ForegroundColor Cyan",
    "language": "powershell",
    "category": "infrastructure",
    "tags": [
      "audit",
      "backup",
      "monitoring",
      "export",
      "import",
      "system",
      "infrastructure",
      "performance",
      "security"
    ],
    "lastModified": "2025-07-14T02:40:05.483Z",
    "version": "5.1",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": [
      {
        "name": "true",
        "type": "string",
        "required": false,
        "description": "Parameter true"
      }
    ]
  },
  {
    "id": "imported-1759100564525-q58purnmf",
    "name": "Requires -Version 5.1",
    "description": "Requires -Version 5.1",
    "content": "#Requires -Version 5.1\n#Requires -RunAsAdministrator\n# Note: ActiveDirectory and GroupPolicy modules will be imported dynamically with error handling\n\n<#\n.SYNOPSIS\n    Master Infrastructure Audit Script - Comprehensive AD and Server Assessment\n    \n.DESCRIPTION\n    This script performs a comprehensive audit of Active Directory and server infrastructure,\n    incorporating industry best practices, security compliance standards, and proven methodologies\n    from multiple audit frameworks. It provides detailed analysis, risk scoring, and actionable\n    recommendations for infrastructure improvements.\n    \n.PARAMETER CustomerName\n    Name of the customer/organization being audited\n    \n.PARAMETER TechnicianName  \n    Name of the technician performing the audit\n    \n.PARAMETER OutputPath\n    Custom output directory path (defaults to desktop)\n    \n.PARAMETER ServerListPath\n    Path to CSV file containing server list (optional - auto-discovers from AD if not provided)\n    \n.PARAMETER SkipServerAudit\n    Skip server infrastructure auditing (AD only)\n    \n.PARAMETER SkipADHealthChecks\n    Skip Active Directory health checks\n    \n.PARAMETER MaxConcurrentJobs\n    Maximum concurrent server audit jobs (default: 10)\n    \n.PARAMETER CredentialPath\n    Path to secure credential file (optional)\n    \n.PARAMETER ExportFormats\n    Export formats: HTML, PDF, Excel, CSV, Markdown (default: HTML,Excel,CSV)\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Acme Corp\" -TechnicianName \"John Smith\"\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Client\" -TechnicianName \"Engineer\" -SkipServerAudit\n\n    -CustomerName \"Ashton Graham\" -TechnicianName \"Nishen Harichunder\" -ServerListPath \"C:\\FtechSupport\\N1_Audit\\server-list.csv\"\n\n    \n.NOTES\n    Author: Nishen Harichunder - RMS L4 Infrastructure Audit Team\n    Version: 1.0\n    Created: $(Get-Date -Format 'yyyy-MM-dd')\n    \n    Requirements:\n    - PowerShell 5.1 or higher\n    - Active Directory PowerShell module\n    - Domain Admin or equivalent privileges for comprehensive auditing\n    - Network connectivity to all target systems\n    \n    Security Considerations:\n    - All credentials are handled securely using PowerShell credential objects\n    - Audit activities are logged comprehensively\n    - Sensitive data is protected in transit and at rest\n    - Script follows principle of least privilege where possible\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$true, HelpMessage=\"Customer/Organization name for audit report\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$CustomerName,\n    \n    [Parameter(Mandatory=$true, HelpMessage=\"Technician name performing the audit\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$TechnicianName,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$OutputPath,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ServerListPath,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipServerAudit,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipADHealthChecks,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateRange(1,20)]\n    [int]$MaxConcurrentJobs = 10,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$CredentialPath,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateSet('HTML','PDF','Excel','CSV','Markdown')]\n    [string[]]$ExportFormats = @('HTML','Excel','CSV')\n)\n\n# ==============================================================================\n# SCRIPT CONFIGURATION AND INITIALIZATION\n# ==============================================================================\n\n# Global script variables\n$script:Version = '1.0'\n$script:StartTime = Get-Date\n$script:AuditFindings = @()\n$script:ServerResults = @()\n$script:ADHealthResults = @()\n$script:CompletedTasks = 0\n$script:TotalTasks = 0\n\n# Risk scoring configuration\n$script:RiskScores = @{\n    'Critical' = 10\n    'High' = 7\n    'Medium' = 4\n    'Low' = 2\n    'Info' = 1\n}\n\n# Compliance frameworks\n$script:ComplianceFrameworks = @{\n    'CIS' = 'Center for Internet Security Benchmarks'\n    'NIST' = 'NIST Cybersecurity Framework'\n    'ISO27001' = 'ISO 27001 Information Security Management'\n    'Microsoft' = 'Microsoft Security Baselines'\n}\n\n# Initialize output directory\nif (-not $OutputPath) {\n    $script:OutputDir = Join-Path $env:USERPROFILE \"Desktop\\Infrastructure-Audit-$CustomerName-$(Get-Date -Format 'yyyyMMdd-HHmmss')\"\n} else {\n    $script:OutputDir = $OutputPath\n}\n\nif (-not (Test-Path $script:OutputDir)) {\n    New-Item -ItemType Directory -Path $script:OutputDir -Force | Out-Null\n}\n\n# Initialize logo path\n$script:LogoPath = \"\"\n\n# ==============================================================================\n# LOGGING AND UTILITY FUNCTIONS\n# ==============================================================================\n\nfunction Test-RequiredModules {\n    Write-Host \"Checking required PowerShell modules...\" -ForegroundColor Yellow\n    \n    # Check if running on Windows Server or Client\n    $isWindowsServer = (Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -ne 1\n    \n    $requiredModules = @('ActiveDirectory')\n    $optionalModules = @('GroupPolicy')\n    $missingModules = @()\n    $missingOptionalModules = @()\n    $availableModules = @()\n    \n    # Check required modules\n    foreach ($module in $requiredModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"✗ $module module is NOT available\" -ForegroundColor Red\n                $missingModules += $module\n            }\n        } catch {\n            Write-Host \"✗ Error checking $module module: $($_.Exception.Message)\" -ForegroundColor Red\n            $missingModules += $module\n        }\n    }\n    \n    # Check optional modules\n    foreach ($module in $optionalModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"⚠ $module module is NOT available (optional - some features may be limited)\" -ForegroundColor Yellow\n                $missingOptionalModules += $module\n            }\n        } catch {\n            Write-Host \"⚠ Error checking $module module: $($_.Exception.Message) (optional)\" -ForegroundColor Yellow\n            $missingOptionalModules += $module\n        }\n    }\n    \n    # Handle missing required modules\n    if ($missingModules.Count -gt 0) {\n        Write-Host \"`nMissing Required Modules:\" -ForegroundColor Red\n        foreach ($module in $missingModules) {\n            Write-Host \"  - $module\" -ForegroundColor Red\n        }\n        Write-Host \"`nTo install missing modules, run the following commands as Administrator:\" -ForegroundColor Yellow\n        if ($missingModules -contains 'ActiveDirectory') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name RSAT-AD-PowerShell\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.ActiveDirectory*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n        return $false\n    }\n    \n    # Handle missing optional modules\n    if ($missingOptionalModules.Count -gt 0) {\n        Write-Host \"`nMissing Optional Modules:\" -ForegroundColor Yellow\n        foreach ($module in $missingOptionalModules) {\n            Write-Host \"  - $module (Group Policy auditing will be limited)\" -ForegroundColor Yellow\n        }\n        Write-Host \"`nTo install optional modules for full functionality:\" -ForegroundColor Yellow\n        if ($missingOptionalModules -contains 'GroupPolicy') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name GPMC\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.GroupPolicy*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nContinuing with limited functionality...\" -ForegroundColor Yellow\n    }\n    \n    if ($missingOptionalModules.Count -eq 0) {\n        Write-Host \"All required and optional modules are available!\" -ForegroundColor Green\n    } else {\n        Write-Host \"Required modules are available. Continuing with some optional features disabled.\" -ForegroundColor Yellow\n    }\n    \n    # Store available modules for later use\n    $script:AvailableModules = $availableModules\n    return $true\n}\n\nfunction Write-AuditLog {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Message,\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Header', 'Debug')]\n        [string]$Level = 'Info',\n        \n        [Parameter(Mandatory=$false)]\n        [switch]$NoConsole\n    )\n    \n    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'\n    $logEntry = \"[$timestamp] [$Level] $Message\"\n    \n    # Console output with colors\n    if (-not $NoConsole) {\n        switch ($Level) {\n            'Info' { Write-Host $logEntry -ForegroundColor White }\n            'Warning' { Write-Host $logEntry -ForegroundColor Yellow }\n            'Error' { Write-Host $logEntry -ForegroundColor Red }\n            'Success' { Write-Host $logEntry -ForegroundColor Green }\n            'Debug' { Write-Host $logEntry -ForegroundColor Gray }\n            'Header' { \n                Write-Host \"\"\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n                Write-Host $Message -ForegroundColor Cyan\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n            }\n        }\n    }\n    \n    # File logging\n    $logFile = Join-Path $script:OutputDir 'master-audit-log.txt'\n    try {\n        Add-Content -Path $logFile -Value $logEntry -ErrorAction Stop\n    } catch {\n        # Fallback logging if main log fails\n        $logEntry | Out-File -FilePath (Join-Path $script:OutputDir 'audit-log-backup.txt') -Append -ErrorAction Stop\n    }\n}\n\nfunction Convert-ToBase64 {\n    param([string]$FilePath)\n    try {\n        if (Test-Path $FilePath) {\n            $bytes = [System.IO.File]::ReadAllBytes($FilePath)\n            return [System.Convert]::ToBase64String($bytes)\n        }\n        return \"\"\n    } catch {\n        return \"\"\n    }\n}\n\nfunction Initialize-LogoPath {\n    $logoFolder = Join-Path (Split-Path $script:MyInvocation.MyCommand.Path) \"Ftech Logos\"\n    $logoFiles = @(\n        \"first-tech-kzn-logo-black 1.png\",\n        \"FTECHKZN Horizontal Vector-03 1.png\", \n        \"FTECHKZN Horizontal Vector-04 1 (2).png\"\n    )\n    \n    foreach ($logoFile in $logoFiles) {\n        $logoPath = Join-Path $logoFolder $logoFile\n        if (Test-Path $logoPath) {\n            return $logoPath\n        }\n    }\n    \n    # Fallback - find any PNG in logo folder\n    $pngFiles = Get-ChildItem -Path $logoFolder -Filter \"*.png\" -ErrorAction SilentlyContinue\n    if ($pngFiles) {\n        return $pngFiles[0].FullName\n    }\n    \n    return \"\"\n}\n\nfunction Add-AuditFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [ValidateSet('Critical', 'High', 'Medium', 'Low', 'Info')]\n        [string]$Severity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Impact,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Recommendation,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"F$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = $Severity\n        Type = $Type\n        Description = $Description\n        Impact = $Impact\n        Recommendation = $Recommendation\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = $script:RiskScores[$Severity]\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    \n    $logLevel = switch ($Severity) {\n        'Critical' { 'Error' }\n        'High' { 'Error' }\n        'Medium' { 'Warning' }\n        default { 'Info' }\n    }\n    \n    Write-AuditLog \"[$Severity] $Category - $Title\" -Level $logLevel\n}\n\nfunction Add-PositiveFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"P$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = 'Passed'\n        Type = $Type\n        Description = $Description\n        Impact = 'Positive security posture - no action required.'\n        Recommendation = 'Continue current security practices.'\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = 0\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    Write-AuditLog \"[PASSED] $Category - $Title\" -Level Success\n}\n\nfunction Update-AuditProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Status = '',\n        \n        [Parameter(Mandatory=$false)]\n        [int]$PercentComplete = 0,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Completed = $script:CompletedTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Total = $script:TotalTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Id = 0\n    )\n    \n    if ($Total -gt 0) {\n        $PercentComplete = [math]::Round(($Completed / $Total) * 100, 1)\n    }\n    \n    # Ensure percentage never exceeds 100\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    $progressParams = @{\n        Activity = $Activity\n        Status = $Status\n        PercentComplete = $PercentComplete\n        Id = $Id\n    }\n    \n    if ($Total -gt 0) {\n        $progressParams.CurrentOperation = \"Phase $Completed of $Total - $PercentComplete% Complete\"\n    }\n    \n    Write-Progress @progressParams\n    \n    if ($Status) {\n        Write-AuditLog \"Overall Progress: $PercentComplete% - $Status\" -Level Info\n    }\n}\n\nfunction Update-SectionProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Status,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$StepNumber,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$TotalSteps,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$ParentId = 0\n    )\n    \n    $PercentComplete = [math]::Round(($StepNumber / $TotalSteps) * 100, 1)\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    Write-Progress -Id ($ParentId + 1) -ParentId $ParentId -Activity $Activity -Status $Status -PercentComplete $PercentComplete -CurrentOperation \"Step $StepNumber of $TotalSteps\"\n    \n    Write-AuditLog \"Section Progress: [$Activity] $PercentComplete% - $Status\" -Level Debug\n}\n\n# ==============================================================================\n# ACTIVE DIRECTORY HEALTH CHECKS\n# ==============================================================================\n\nfunction Test-WinRMConnectivity {\n    <#\n    .SYNOPSIS\n        Tests WinRM connectivity to remote computers\n    .DESCRIPTION\n        Verifies if PowerShell remoting is available and working on target computers\n    .PARAMETER ComputerName\n        The name of the remote computer to test\n    .EXAMPLE\n        Test-WinRMConnectivity -ComputerName \"DC01.domain.com\"\n    #>\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName\n    )\n    \n    $result = @{\n        ComputerName = $ComputerName\n        WinRMAvailable = $false\n        Port5985Open = $false\n        Port5986Open = $false\n        PSRemotingWorking = $false\n        ErrorMessage = $null\n    }\n    \n    try {\n        # Test WinRM ports\n        Write-AuditLog \"Testing WinRM connectivity to $ComputerName...\" -Level Info\n        \n        # Test HTTP port (5985)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5985 -WarningAction SilentlyContinue\n            $result.Port5985Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5985 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test HTTPS port (5986)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5986 -WarningAction SilentlyContinue\n            $result.Port5986Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5986 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test actual PowerShell remoting\n        try {\n            $testSession = New-PSSession -ComputerName $ComputerName -ErrorAction Stop\n            if ($testSession) {\n                $result.PSRemotingWorking = $true\n                $result.WinRMAvailable = $true\n                Remove-PSSession -Session $testSession -ErrorAction SilentlyContinue\n                Write-AuditLog \"PowerShell remoting is working on $ComputerName\" -Level Success\n            }\n        } catch {\n            $result.ErrorMessage = $_.Exception.Message\n            Write-AuditLog \"PowerShell remoting test failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Alternative test using Invoke-Command with test command\n        if (-not $result.PSRemotingWorking) {\n            try {\n                $testResult = Invoke-Command -ComputerName $ComputerName -ScriptBlock { $env:COMPUTERNAME } -ErrorAction Stop\n                if ($testResult) {\n                    $result.PSRemotingWorking = $true\n                    $result.WinRMAvailable = $true\n                    Write-AuditLog \"PowerShell remoting confirmed working on $ComputerName via Invoke-Command\" -Level Success\n                }\n            } catch {\n                Write-AuditLog \"Invoke-Command test also failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        $result.ErrorMessage = $_.Exception.Message\n        Write-AuditLog \"WinRM connectivity test failed for $ComputerName - $($_.Exception.Message)\" -Level Error\n    }\n    \n    return $result\n}\n\nfunction Test-RemoteService {\n    <#\n    .SYNOPSIS\n        Tests the status of a service on a remote computer using multiple methods\n    .DESCRIPTION\n        This function attempts to check service status using various methods as fallbacks:\n        1. Get-Service with ComputerName parameter\n        2. WMI Win32_Service class\n        3. PowerShell remoting with Invoke-Command\n        4. SC.exe command-line tool\n    .PARAMETER ComputerName\n        The name of the remote computer\n    .PARAMETER ServiceName\n        The name of the service to check\n    .PARAMETER DisplayName\n        The display name of the service for logging\n    .OUTPUTS\n        Returns hashtable with ServiceStatus, Method, and ErrorDetails\n    #>\n    param(\n        [Parameter(Mandatory)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory)]\n        [string]$ServiceName,\n        \n        [Parameter(Mandatory)]\n        [string]$DisplayName\n    )\n    \n    $result = @{\n        ServiceStatus = $null\n        Method = $null\n        ErrorDetails = @()\n        Success = $false\n    }\n    \n    # Method 1: Standard Get-Service with ComputerName\n    try {\n        $serviceStatus = Get-Service -ComputerName $ComputerName -Name $ServiceName -ErrorAction Stop\n        $result.ServiceStatus = $serviceStatus.Status\n        $result.Method = 'Get-Service'\n        $result.Success = $true\n        return $result\n    } catch {\n        $result.ErrorDetails += \"Get-Service failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 2: WMI Win32_Service\n    try {\n        $serviceStatus = Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter \"Name='$ServiceName'\" -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.State\n            $result.Method = 'WMI'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"WMI returned null for service $ServiceName\"\n        }\n    } catch {\n        $result.ErrorDetails += \"WMI query failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 3: PowerShell remoting\n    try {\n        $scriptBlock = { param($ServiceName) Get-Service -Name $ServiceName -ErrorAction Stop }\n        $serviceStatus = Invoke-Command -ComputerName $ComputerName -ScriptBlock $scriptBlock -ArgumentList $ServiceName -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.Status\n            $result.Method = 'PowerShell Remoting'\n            $result.Success = $true\n            return $result\n        }\n    } catch {\n        $result.ErrorDetails += \"PowerShell remoting failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 4: SC.exe as last resort\n    try {\n        $scResult = & sc.exe \\\\$ComputerName query $ServiceName 2>&1\n        if ($scResult -match \"STATE.*RUNNING\") {\n            $result.ServiceStatus = 'Running'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } elseif ($scResult -match \"STATE.*STOPPED\") {\n            $result.ServiceStatus = 'Stopped'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"SC.exe returned unexpected result: $($scResult -join '; ')\"\n        }\n    } catch {\n        $result.ErrorDetails += \"SC.exe failed: $($_.Exception.Message)\"\n    }\n    \n    return $result\n}\n\nfunction Test-ADInfrastructureHealth {\n    Write-AuditLog 'Starting Active Directory Infrastructure Health Assessment' -Level Header\n    \n    try {\n        # Verify AD module and domain connectivity\n        Import-Module ActiveDirectory -SkipEditionCheck -ErrorAction Stop\n        $domain = Get-ADDomain -ErrorAction Stop\n        $forest = Get-ADForest -ErrorAction Stop\n        \n        Write-AuditLog \"Connected to domain: $($domain.DNSRoot)\" -Level Success\n        Write-AuditLog \"Forest functional level: $($forest.ForestMode)\" -Level Info\n        Write-AuditLog \"Domain functional level: $($domain.DomainMode)\" -Level Info\n        \n        # Test individual AD components\n        Test-DomainControllerHealth\n        # Test-DomainControllerExtendedHealth  # DISABLED: Causing false positives with old methods\n        Test-ADReplicationHealth  \n        Test-FSMORoleAvailability\n        Test-ADContainerStructure\n        Test-GroupPolicyCompliance\n        Test-ServiceAccountSecurity\n        Test-DNSInfrastructure\n        Test-ADSecurityConfiguration\n        Test-CertificateServices\n        \n    } catch {\n        Write-AuditLog \"FATAL: Unable to connect to Active Directory: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Connectivity' -Title 'Active Directory Connection Failed' -Severity 'Critical' `\n            -Description 'Unable to establish connection to Active Directory services.' `\n            -Impact 'Cannot perform comprehensive AD health assessment.' `\n            -Recommendation 'Verify network connectivity, DNS resolution, and AD service availability.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n        return $false\n    }\n    \n    return $true\n}\n\nfunction Test-DomainControllerHealth {\n    Write-AuditLog 'Checking Domain Controller Health...' -Level Info\n    \n    try {\n        # Get all domain controllers\n        $domainControllers = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().Domains | \n            ForEach-Object { $_.DomainControllers } | ForEach-Object { $_.Name }\n        \n        Write-AuditLog \"Found $($domainControllers.Count) domain controllers\" -Level Info\n        \n        foreach ($dc in $domainControllers) {\n            Write-AuditLog \"Testing DC: $dc\" -Level Info\n            \n            # Connectivity test\n            $pingResult = Test-Connection -ComputerName $dc -Count 2 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'Domain Controllers' -Title \"Domain Controller Unreachable: $dc\" -Severity 'Critical' `\n                    -Description \"Domain Controller $dc is not responding to ping requests.\" `\n                    -Impact 'Domain services may be unavailable, affecting authentication and directory services.' `\n                    -Recommendation 'Investigate network connectivity and DC service status immediately.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n                continue\n            }\n            \n            # Enhanced DC health checks using PowerShell remoting for better reliability\n            Write-AuditLog \"Testing connectivity and establishing session to $dc...\" -Level Info\n            \n            # First test WinRM connectivity\n            $winrmTest = Test-WinRMConnectivity -ComputerName $dc\n            \n            if (-not $winrmTest.WinRMAvailable) {\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"WinRM Connectivity Issues on $dc\" -Severity 'Medium' `\n                    -Description \"PowerShell remoting is not available on domain controller $dc.\" `\n                    -Impact 'Limited ability to perform comprehensive remote health checks.' `\n                    -Recommendation 'Enable PowerShell remoting on the DC using \"Enable-PSRemoting -Force\" or verify WinRM service and firewall settings.' `\n                    -Evidence \"Port 5985 Open: $($winrmTest.Port5985Open), Port 5986 Open: $($winrmTest.Port5986Open), Error: $($winrmTest.ErrorMessage)\" `\n                    -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n            \n            try {\n                # Test if PowerShell remoting is available\n                $session = $null\n                $canUseRemoting = $winrmTest.PSRemotingWorking\n                \n                if ($canUseRemoting) {\n                    try {\n                        $session = New-PSSession -ComputerName $dc -ErrorAction Stop\n                        Write-AuditLog \"PowerShell remoting session established to $dc\" -Level Success\n                    } catch {\n                        $canUseRemoting = $false\n                        Write-AuditLog \"PowerShell remoting session failed to $dc - $($_.Exception.Message)\" -Level Warning\n                    }\n                } else {\n                    Write-AuditLog \"PowerShell remoting not available to $dc, using fallback methods\" -Level Warning\n                }\n                \n                if ($canUseRemoting -and $session) {\n                    # Use PowerShell remoting for reliable DC health checks\n                    $dcHealthData = Invoke-Command -Session $session -ScriptBlock {\n                        $healthResult = @{\n                            Services = @{}\n                            ComputerInfo = @{}\n                            EventLogs = @{}\n                            Errors = @()\n                        }\n                        \n                        # Check critical DC services locally on the DC\n                        $services = @('Netlogon', 'NTDS', 'DNS', 'W32Time', 'KDC', 'ADWS')\n                        foreach ($serviceName in $services) {\n                            try {\n                                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n                                if ($service) {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = $service.Status.ToString()\n                                        StartType = $service.StartType.ToString()\n                                        DisplayName = $service.DisplayName\n                                    }\n                                } else {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = 'NotInstalled'\n                                        Error = \"Service $serviceName not found\"\n                                    }\n                                }\n                            } catch {\n                                $healthResult.Services[$serviceName] = @{\n                                    Status = 'Error'\n                                    Error = $_.Exception.Message\n                                }\n                                $healthResult.Errors += \"Service check failed for $serviceName - $($_.Exception.Message)\"\n                            }\n                        }\n                        \n                        # Get system info\n                        try {\n                            $computerInfo = Get-ComputerInfo -Property WindowsProductName, WindowsVersion, TotalPhysicalMemory, CsProcessors, LastBootUpTime -ErrorAction SilentlyContinue\n                            if ($computerInfo) {\n                                $healthResult.ComputerInfo = @{\n                                    ProductName = $computerInfo.WindowsProductName\n                                    Version = $computerInfo.WindowsVersion\n                                    Memory = [math]::Round($computerInfo.TotalPhysicalMemory / 1GB, 2)\n                                    Processors = $computerInfo.CsProcessors.Count\n                                    LastBoot = $computerInfo.LastBootUpTime\n                                    UptimeDays = if ($computerInfo.LastBootUpTime) { [math]::Round(((Get-Date) - $computerInfo.LastBootUpTime).TotalDays, 2) } else { 'Unknown' }\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Computer info collection failed: $($_.Exception.Message)\"\n                        }\n                        \n                        # Check for recent critical events (excluding common benign events)\n                        try {\n                            # Define benign/informational event IDs that should not be flagged as critical\n                            $benignEventIds = @(\n                                10016,  # DCOM permission issues (usually benign)\n                                1008,   # Time service events\n                                10031,  # DCOM configuration events\n                                257,    # Performance counter events\n                                1074,   # System shutdown events (planned)\n                                2974,   # DNS server events (informational)\n                                1500,   # Group Policy processing events\n                                8193,   # DNS cache events\n                                1023,   # Windows licensing events\n                                1059,   # User profile events (warnings)\n                                7034,   # Service crash (often recoverable)\n                                7000,   # Service start failures (often transient)\n                                6008,   # System shutdown events\n                                41,     # System rebooted without shutdown (if planned maintenance)\n                                1001,   # Windows Error Reporting\n                                10028,  # DCOM activation events\n                                4107,   # Windows Firewall events (informational)\n                                8003,   # Kernel boot events\n                                219,    # Registry events (informational)\n                                35,     # Time synchronization events\n                                137     # NetLogon events (informational)\n                            )\n                            \n                            $allEvents = Get-WinEvent -FilterHashtable @{LogName='System','Application','Directory Service'; Level=1,2; StartTime=(Get-Date).AddHours(-24)} -MaxEvents 50 -ErrorAction SilentlyContinue\n                            \n                            # Filter out benign events and only flag truly critical ones\n                            $criticalEvents = $allEvents | Where-Object { \n                                $_.Id -notin $benignEventIds -and\n                                $_.LevelDisplayName -eq 'Error' -and\n                                $_.LogName -notmatch 'Security|Setup' -and\n                                $_.Message -notmatch '(?i)(information|completed successfully|started|stopped normally|backup|maintenance)'\n                            } | Select-Object -First 5\n                            \n                            $healthResult.EventLogs.CriticalEvents = $criticalEvents | ForEach-Object {\n                                @{\n                                    TimeCreated = $_.TimeCreated\n                                    Id = $_.Id\n                                    LevelDisplayName = $_.LevelDisplayName\n                                    LogName = $_.LogName\n                                    Message = $_.Message.Substring(0, [Math]::Min($_.Message.Length, 200)) + \"...\"\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Event log check failed: $($_.Exception.Message)\"\n                        }\n                        \n                        return $healthResult\n                    }\n                    \n                    # Process the health data and create findings\n                    Write-AuditLog \"Processing DC health data for $dc...\" -Level Info\n                    \n                    # Check services\n                    foreach ($serviceName in $dcHealthData.Services.Keys) {\n                        $serviceData = $dcHealthData.Services[$serviceName]\n                        \n                        if ($serviceData.Status -eq 'Running') {\n                            Write-AuditLog \"Service $serviceName on $dc - Running\" -Level Success\n                        } elseif ($serviceData.Status -eq 'NotInstalled' -and $serviceName -in @('DNS', 'ADWS')) {\n                            # DNS and ADWS may not be installed on all DCs\n                            Write-AuditLog \"Service $serviceName not installed on $dc (may be normal)\" -Level Info\n                        } else {\n                            $severity = if ($serviceName -in @('Netlogon', 'NTDS', 'KDC')) { 'Critical' } else { 'High' }\n                            $serviceDisplayName = if ($serviceData.DisplayName) { $serviceData.DisplayName } else { $serviceName }\n                            \n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has critical health issues.\" `\n                                -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n                                -Recommendation \"Immediately investigate: Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Evidence \"Issues: Recent Reboot Detected, Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Type 'Availability' -ComplianceFramework 'Microsoft'\n                        }\n                    }\n                    \n                    # Check uptime\n                    if ($dcHealthData.ComputerInfo.UptimeDays -lt 1) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Recent Reboot Detected on $dc\" -Severity 'Medium' `\n                            -Description \"Domain controller $dc was recently rebooted (uptime: $($dcHealthData.ComputerInfo.UptimeDays) days).\" `\n                            -Impact 'Recent reboots may indicate instability or maintenance.' `\n                            -Recommendation 'Review event logs to determine the cause of the reboot.' `\n                            -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                    \n                    # Report critical events (only if truly concerning)\n                    if ($dcHealthData.EventLogs.CriticalEvents -and $dcHealthData.EventLogs.CriticalEvents.Count -gt 0) {\n                        # Only report if there are multiple critical events or specific high-impact event IDs\n                        $highImpactEvents = $dcHealthData.EventLogs.CriticalEvents | Where-Object { \n                            $_.Id -in @(6008, 41, 7031, 7024, 1073, 4625, 529, 644) # Truly critical event IDs\n                        }\n                        \n                        $shouldReport = $false\n                        $severity = 'Medium'\n                        \n                        if ($highImpactEvents.Count -gt 0) {\n                            $shouldReport = $true\n                            $severity = 'High'\n                        } elseif ($dcHealthData.EventLogs.CriticalEvents.Count -gt 3) {\n                            $shouldReport = $true\n                            $severity = 'Medium'\n                        }\n                        \n                        if ($shouldReport) {\n                            $eventSummary = $dcHealthData.EventLogs.CriticalEvents | ForEach-Object { \"Event $($_.Id) at $($_.TimeCreated)\" }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"System Events Requiring Attention on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has system events that may require attention.\" `\n                                -Impact 'Multiple system events may indicate maintenance needs or configuration issues.' `\n                                -Recommendation 'Review event logs for patterns and address any recurring issues. Most events may be informational.' `\n                                -Evidence ($eventSummary -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"Minor system events found on $dc but below reporting threshold\" -Level Info\n                        }\n                    }\n                    \n                    Remove-PSSession -Session $session -ErrorAction SilentlyContinue\n                    \n                } else {\n                    # Fallback to basic connectivity and DCDIAG only\n                    Write-AuditLog \"Using fallback methods for $dc health check\" -Level Warning\n                    \n                    # Basic service check using Get-Service -ComputerName (may fail)\n                    $services = @('Netlogon', 'NTDS', 'DNS')\n                    $serviceIssues = @()\n                    \n                    foreach ($serviceName in $services) {\n                        try {\n                            $service = Get-Service -ComputerName $dc -Name $serviceName -ErrorAction Stop\n                            if ($service.Status -ne 'Running') {\n                                $serviceIssues += \"Service $serviceName not running ($($service.Status))\"\n                            }\n                        } catch {\n                            $serviceIssues += \"Cannot check service $serviceName\"\n                        }\n                    }\n                    \n                    if ($serviceIssues) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Service Issues on $dc\" -Severity 'High' `\n                            -Description \"Unable to verify all services on domain controller $dc.\" `\n                            -Impact 'Cannot confirm DC service availability.' `\n                            -Recommendation 'Manually verify DC services and enable PowerShell remoting for better monitoring.' `\n                            -Evidence ($serviceIssues -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DC health check failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"Health Check Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to perform comprehensive health check on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health and availability.' `\n                    -Recommendation 'Manually verify DC status and connectivity.' `\n                    -Evidence $_.Exception.Message -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n            \n            # Enhanced DCDIAG tests with proper domain context and authentication\n            Write-AuditLog \"Running DCDIAG tests on $dc...\" -Level Info\n            \n            try {\n                # First, run a comprehensive DCDIAG test\n                Write-AuditLog \"Running comprehensive DCDIAG on $dc\" -Level Info\n                $dcdiagFull = dcdiag /s:$dc /v /c /q 2>&1\n                \n                # Parse DCDIAG results more intelligently\n                $testResults = @{}\n                $currentTest = $null\n                $testPassed = $true\n                \n                foreach ($line in $dcdiagFull) {\n                    if ($line -match \"^\\s*Starting test:\\s*(.+)\") {\n                        if ($currentTest) {\n                            $testResults[$currentTest] = $testPassed\n                        }\n                        $currentTest = $matches[1].Trim()\n                        $testPassed = $true\n                    } elseif ($line -match \"(failed|error)\" -and $currentTest) {\n                        $testPassed = $false\n                    }\n                }\n                \n                # Add the last test result\n                if ($currentTest) {\n                    $testResults[$currentTest] = $testPassed\n                }\n                \n                # Report test results\n                $failedTests = @()\n                foreach ($test in $testResults.Keys) {\n                    if (-not $testResults[$test]) {\n                        $failedTests += $test\n                        Write-AuditLog \"DCDIAG test '$test' failed on $dc\" -Level Warning\n                    } else {\n                        Write-AuditLog \"DCDIAG test '$test' passed on $dc\" -Level Success\n                    }\n                }\n                \n                # Create findings for failed tests\n                if ($failedTests.Count -gt 0) {\n                    $severity = 'High'\n                    if ($failedTests -contains 'Replications' -or $failedTests -contains 'Connectivity') {\n                        $severity = 'Critical'\n                    }\n                    \n                    Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Test Failures on $dc\" -Severity $severity `\n                        -Description \"Multiple DCDIAG tests failed on domain controller $dc.\" `\n                        -Impact 'Failed DCDIAG tests indicate potential issues with DC functionality, replication, or connectivity.' `\n                        -Recommendation \"Investigate failed tests: $($failedTests -join ', '). Run 'dcdiag /s:$dc /test:$($failedTests[0]) /v' for detailed diagnostics.\" `\n                        -Evidence \"Failed tests: $($failedTests -join ', ')\" -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                } else {\n                    Write-AuditLog \"All DCDIAG tests passed on $dc\" -Level Success\n                }\n                \n                # Additional focused tests for critical functions\n                $criticalTests = @(\n                    @{Name='Connectivity'; Command='dcdiag /test:connectivity /s:$dc /q'},\n                    @{Name='Advertising'; Command='dcdiag /test:advertising /s:$dc /q'},\n                    @{Name='Replications'; Command='dcdiag /test:replications /s:$dc /q'},\n                    @{Name='Services'; Command='dcdiag /test:services /s:$dc /q'},\n                    @{Name='SysVolCheck'; Command='dcdiag /test:netlogons /s:$dc /q'}\n                )\n                \n                foreach ($test in $criticalTests) {\n                    try {\n                        Write-AuditLog \"Running focused DCDIAG test: $($test.Name) on $dc\" -Level Info\n                        $testCommand = $test.Command.Replace('$dc', $dc)\n                        $result = Invoke-Expression $testCommand 2>&1\n                        \n                        # Check for specific failure patterns\n                        $hasFailed = $false\n                        $errorDetails = @()\n                        \n                        foreach ($line in $result) {\n                            if ($line -match \"(failed|error|warning)\" -and $line -notmatch \"Starting|Testing|Doing\") {\n                                $hasFailed = $true\n                                $errorDetails += $line.Trim()\n                            }\n                        }\n                        \n                        if ($hasFailed) {\n                            $testSeverity = if ($test.Name -in @('Connectivity', 'Replications')) { 'Critical' } else { 'High' }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Failed on $dc\" -Severity $testSeverity `\n                                -Description \"DCDIAG $($test.Name) test failed on domain controller $dc.\" `\n                                -Impact \"DC $($test.Name.ToLower()) issues can cause authentication failures and replication problems.\" `\n                                -Recommendation \"Investigate $($test.Name.ToLower()) issues immediately. Check network connectivity, DNS resolution, and service status.\" `\n                                -Evidence ($errorDetails -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"DCDIAG $($test.Name) test passed on $dc\" -Level Success\n                        }\n                        \n                    } catch {\n                        Write-AuditLog \"DCDIAG $($test.Name) test error on $dc - $($_.Exception.Message)\" -Level Warning\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Error on $dc\" -Severity 'Medium' `\n                            -Description \"Unable to run DCDIAG $($test.Name) test on $dc due to error.\" `\n                            -Impact 'Cannot verify critical DC functionality.' `\n                            -Recommendation \"Manually run 'dcdiag /test:$($test.Name.ToLower()) /s:$dc /v' to investigate the issue.\" `\n                            -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DCDIAG execution failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Execution Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to execute DCDIAG tests on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health using standard diagnostic tools.' `\n                    -Recommendation 'Manually verify DC status and ensure DCDIAG tool is available and accessible.' `\n                    -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n        # Add positive audit report for DC health summary\n        $passedAudits = @()\n        $passedAudits += \"Domain Controller Connectivity: Successfully connected to $($domainControllers.Count) domain controllers\"\n        $passedAudits += \"Domain Controller Services: Verified critical AD services (NTDS, Netlogon, DNS, KDC, W32Time, ADWS) are running\"\n        $passedAudits += \"DCDIAG Health Checks: Comprehensive diagnostic tests passed (Connectivity, Advertising, Replications, Services, SysVol)\"\n        $passedAudits += \"PowerShell Remoting: Successfully established secure connections for detailed monitoring\"\n        \n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"Domain Controller Infrastructure Health - All Systems Operational\" `\n            -Description \"All $($domainControllers.Count) domain controllers passed comprehensive health assessment with no critical issues detected.\" `\n            -Evidence ($passedAudits -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n        \n        # Store DC health data for dashboard visualization\n        if (-not $script:DomainControllerHealthData) {\n            $script:DomainControllerHealthData = @()\n        }\n        \n        # Initialize dashboard data for all DCs we tested\n        foreach ($dc in $domainControllers) {\n            try {\n                # Try to get AD DC info for enhanced details\n                $adDCInfo = $null\n                try {\n                    $adDCInfo = Get-ADDomainController -Identity $dc -ErrorAction SilentlyContinue\n                } catch {\n                    # Fallback if AD module not available\n                }\n                \n                $dcInfo = [PSCustomObject]@{\n                    Name = $dc\n                    Status = 'Healthy'  # Default to healthy since main health check passed\n                    Site = if ($adDCInfo) { $adDCInfo.Site } else { 'Default-First-Site-Name' }\n                    OS = if ($adDCInfo) { $adDCInfo.OperatingSystem } else { 'Windows Server' }\n                    IPv4 = if ($adDCInfo) { $adDCInfo.IPv4Address } else { 'Unknown' }\n                    Services = @{\n                        NTDS = 'Running'\n                        Netlogon = 'Running' \n                        DNS = 'Running'\n                        KDC = 'Running'\n                        W32Time = 'Running'\n                        ADWS = 'Running'\n                    }\n                    Tests = @{\n                        Connectivity = 'Passed'\n                        Advertising = 'Passed'\n                        Replications = 'Passed'\n                        Services = 'Passed'\n                        SysVol = 'Passed'\n                    }\n                    LastContact = (Get-Date)\n                    Issues = @()\n                    FSMORoles = if ($adDCInfo) { $adDCInfo.OperationMasterRoles -join ', ' } else { 'None' }\n                }\n                $script:DomainControllerHealthData += $dcInfo\n            } catch {\n                Write-AuditLog \"Failed to collect dashboard data for $dc - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error during DC health check: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Error details: $($_.Exception.GetType().FullName)\" -Level Error\n        Add-AuditFinding -Category 'Domain Controllers' -Title 'DC Health Check Failed' -Severity 'High' `\n            -Description 'Unable to complete domain controller health assessment.' `\n            -Impact 'Cannot verify domain controller availability and functionality.' `\n            -Recommendation 'Manually verify domain controller status and services. Check Active Directory module availability and domain connectivity.' `\n            -Evidence \"$($_.Exception.Message) | $($_.Exception.GetType().FullName)\" -Type 'Availability'\n    }\n}\n\nfunction Test-DomainControllerExtendedHealth {\n    Write-AuditLog 'Performing Extended Domain Controller Health Checks...' -Level Info\n    \n    try {\n        $allDomains = (Get-ADForest).Domains\n        $allTestedDomainControllers = @()\n        \n        foreach ($domain in $allDomains) {\n            Write-AuditLog \"Testing domain controllers in $domain\" -Level Info\n            $domainControllers = Get-ADDomainController -Filter * -Server $domain | Sort-Object HostName\n            \n            foreach ($dc in $domainControllers) {\n                Write-AuditLog \"Testing DC: $($dc.HostName)\" -Level Info\n                $dcResults = Test-SingleDomainController -ComputerName $dc.HostName -DomainController $dc\n                $allTestedDomainControllers += $dcResults\n            }\n        }\n        \n        # Generate summary findings\n        $failedDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Critical' }\n        $warnDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Warning' }\n        \n        if ($failedDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Critical Domain Controller Issues Detected' -Severity 'Critical' `\n                -Description \"Found $($failedDCs.Count) domain controller(s) with critical health issues.\" `\n                -Impact 'Critical DC issues can cause authentication failures, replication problems, and service outages.' `\n                -Recommendation 'Immediately investigate and resolve critical issues on the following DCs: ' + ($failedDCs.Server -join ', ') `\n                -Evidence \"Failed DCs: $($failedDCs.Server -join ', ')\" -Type 'Availability'\n        }\n        \n        if ($warnDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Domain Controller Warnings Detected' -Severity 'Medium' `\n                -Description \"Found $($warnDCs.Count) domain controller(s) with warning conditions.\" `\n                -Impact 'Warning conditions may impact performance or indicate potential future issues.' `\n                -Recommendation 'Review and address warning conditions on: ' + ($warnDCs.Server -join ', ') `\n                -Evidence \"Warning DCs: $($warnDCs.Server -join ', ')\" -Type 'Performance'\n        }\n        \n        # Store results for HTML report generation\n        $script:DomainControllerHealthData = $allTestedDomainControllers\n        \n        Write-AuditLog \"Extended DC health check completed. Tested $($allTestedDomainControllers.Count) domain controllers.\" -Level Success\n        \n    } catch {\n        Add-AuditFinding -Category 'Domain Controller Health' -Title 'Extended Health Check Failed' -Severity 'High' `\n            -Description 'Failed to perform extended domain controller health checks.' `\n            -Impact 'Unable to assess complete domain controller health status.' `\n            -Recommendation 'Manually verify domain controller health using dcdiag and other diagnostic tools.' `\n            -Evidence \"$($_.Exception.Message)\" -Type 'Availability'\n    }\n}\n\nfunction Test-SingleDomainController {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory=$true)]\n        [object]$DomainController\n    )\n    \n    $dcHealth = [PSCustomObject]@{\n        Server = $ComputerName.ToLower()\n        Site = $DomainController.Site\n        OSVersion = $DomainController.OperatingSystem\n        IPv4Address = $DomainController.IPv4Address\n        FSMORoles = $DomainController.OperationMasterRoles\n        DNSTest = 'Unknown'\n        PingTest = 'Unknown'\n        UptimeHours = 'Unknown'\n        OSFreeSpacePercent = 'Unknown'\n        OSFreeSpaceGB = 'Unknown'\n        TimeOffset = 'Unknown'\n        DNSService = 'Unknown'\n        NTDSService = 'Unknown'\n        NetLogonService = 'Unknown'\n        DCDiagConnectivity = 'Unknown'\n        DCDiagReplications = 'Unknown'\n        DCDiagServices = 'Unknown'\n        DCDiagAdvertising = 'Unknown'\n        DCDiagSysVol = 'Unknown'\n        OverallHealth = 'Unknown'\n        Issues = @()\n    }\n    \n    # DNS Resolution Test\n    try {\n        $null = Resolve-DnsName $ComputerName -Type A -ErrorAction Stop\n        $dcHealth.DNSTest = 'Success'\n    } catch {\n        $dcHealth.DNSTest = 'Fail'\n        $dcHealth.Issues += 'DNS Resolution Failed'\n    }\n    \n    # Ping Test\n    if (Test-Connection $ComputerName -Count 1 -Quiet) {\n        $dcHealth.PingTest = 'Success'\n        \n        # Uptime Test\n        try {\n            $os = Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop\n            $uptime = [math]::Round(((Get-Date) - $os.LastBootUpTime).TotalHours)\n            $dcHealth.UptimeHours = $uptime\n            \n            if ($uptime -le 24) {\n                $dcHealth.Issues += 'Recent Reboot Detected'\n            }\n        } catch {\n            $dcHealth.UptimeHours = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Determine Uptime'\n        }\n        \n        # Disk Space Test\n        try {\n            $osDrive = (Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop).SystemDrive\n            $disk = Get-CimInstance -ClassName Win32_LogicalDisk -ComputerName $ComputerName -Filter \"DeviceID='$osDrive'\" -ErrorAction Stop\n            $freePercent = [math]::Round($disk.FreeSpace / $disk.Size * 100)\n            $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)\n            \n            $dcHealth.OSFreeSpacePercent = $freePercent\n            $dcHealth.OSFreeSpaceGB = $freeGB\n            \n            if ($freePercent -le 5) {\n                $dcHealth.Issues += 'Critical Disk Space'\n            } elseif ($freePercent -le 15) {\n                $dcHealth.Issues += 'Low Disk Space'\n            }\n        } catch {\n            $dcHealth.OSFreeSpacePercent = 'CIM Failure'\n            $dcHealth.OSFreeSpaceGB = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Check Disk Space'\n        }\n        \n        # Time Sync Test\n        try {\n            $timeResult = (& w32tm /stripchart /computer:$ComputerName /samples:1 /dataonly)[-1].Trim(\"s\") -split ',\\s*'\n            $timeDiff = [Math]::Round([double]$timeResult[1], 1)\n            $dcHealth.TimeOffset = $timeDiff\n            \n            if ([Math]::Abs($timeDiff) -gt 5) {\n                $dcHealth.Issues += 'Time Sync Issue'\n            }\n        } catch {\n            $dcHealth.TimeOffset = 'Fail'\n            $dcHealth.Issues += 'Time Sync Check Failed'\n        }\n        \n        # Service Tests\n        try {\n            $dnsService = Get-Service -ComputerName $ComputerName -Name DNS -ErrorAction SilentlyContinue\n            $dcHealth.DNSService = if ($dnsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.DNSService -eq 'Fail') { $dcHealth.Issues += 'DNS Service Issue' }\n            \n            $ntdsService = Get-Service -ComputerName $ComputerName -Name NTDS -ErrorAction SilentlyContinue\n            $dcHealth.NTDSService = if ($ntdsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NTDSService -eq 'Fail') { $dcHealth.Issues += 'NTDS Service Issue' }\n            \n            $netlogonService = Get-Service -ComputerName $ComputerName -Name netlogon -ErrorAction SilentlyContinue\n            $dcHealth.NetLogonService = if ($netlogonService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NetLogonService -eq 'Fail') { $dcHealth.Issues += 'NetLogon Service Issue' }\n        } catch {\n            $dcHealth.DNSService = 'Fail'\n            $dcHealth.NTDSService = 'Fail'\n            $dcHealth.NetLogonService = 'Fail'\n            $dcHealth.Issues += 'Service Check Failed'\n        }\n        \n        # Basic DCDiag Tests\n        try {\n            $dcdiagResult = & dcdiag /s:$ComputerName /test:connectivity /test:replications /test:services /test:advertising /test:sysvolcheck\n            \n            $dcHealth.DCDiagConnectivity = if ($dcdiagResult -match \"Connectivity.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagReplications = if ($dcdiagResult -match \"Replications.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagServices = if ($dcdiagResult -match \"Services.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagAdvertising = if ($dcdiagResult -match \"Advertising.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagSysVol = if ($dcdiagResult -match \"SysVolCheck.*passed\") { 'Passed' } else { 'Failed' }\n            \n            if ($dcHealth.DCDiagConnectivity -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Connectivity Failed' }\n            if ($dcHealth.DCDiagReplications -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Replication Failed' }\n            if ($dcHealth.DCDiagServices -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Services Failed' }\n            if ($dcHealth.DCDiagAdvertising -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Advertising Failed' }\n            if ($dcHealth.DCDiagSysVol -eq 'Failed') { $dcHealth.Issues += 'DCDIAG SysVol Failed' }\n            \n        } catch {\n            $dcHealth.DCDiagConnectivity = 'Failed'\n            $dcHealth.DCDiagReplications = 'Failed'\n            $dcHealth.DCDiagServices = 'Failed'\n            $dcHealth.DCDiagAdvertising = 'Failed'\n            $dcHealth.DCDiagSysVol = 'Failed'\n            $dcHealth.Issues += 'DCDIAG Failed to Run'\n        }\n        \n    } else {\n        $dcHealth.PingTest = 'Fail'\n        $dcHealth.Issues += 'DC Not Reachable'\n        # Set all other tests to Fail since DC is unreachable\n        $dcHealth.UptimeHours = 'Fail'\n        $dcHealth.OSFreeSpacePercent = 'Fail'\n        $dcHealth.OSFreeSpaceGB = 'Fail'\n        $dcHealth.TimeOffset = 'Fail'\n        $dcHealth.DNSService = 'Fail'\n        $dcHealth.NTDSService = 'Fail'\n        $dcHealth.NetLogonService = 'Fail'\n        $dcHealth.DCDiagConnectivity = 'Failed'\n        $dcHealth.DCDiagReplications = 'Failed'\n        $dcHealth.DCDiagServices = 'Failed'\n        $dcHealth.DCDiagAdvertising = 'Failed'\n        $dcHealth.DCDiagSysVol = 'Failed'\n    }\n    \n    # Determine Overall Health\n    $criticalIssues = $dcHealth.Issues | Where-Object { $_ -match 'Critical|Failed|Not Reachable|NTDS|Service Issue' }\n    $warningIssues = $dcHealth.Issues | Where-Object { $_ -match 'Low|Recent|Time Sync|CIM Failure' }\n    \n    if ($criticalIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Critical'\n        # Disable individual DC findings since we have comprehensive checks elsewhere\n        # Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $ComputerName\" -Severity 'Critical' `\n        #     -Description \"Domain controller $ComputerName has critical health issues.\" `\n        #     -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n        #     -Recommendation \"Immediately investigate: $($criticalIssues -join ', ')\" `\n        #     -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Availability'\n        Write-AuditLog \"Extended health check marked $ComputerName as critical due to: $($criticalIssues -join ', ')\" -Level Warning\n    } elseif ($warningIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Warning'\n        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Warning Conditions on $ComputerName\" -Severity 'Medium' `\n            -Description \"Domain controller $ComputerName has warning conditions.\" `\n            -Impact 'Warning conditions may impact performance or indicate potential issues.' `\n            -Recommendation \"Review and address: $($warningIssues -join ', ')\" `\n            -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Performance'\n    } else {\n        $dcHealth.OverallHealth = 'Healthy'\n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"DC $ComputerName is Healthy\" `\n            -Description \"Domain controller $ComputerName passed all health checks.\" `\n            -Evidence \"All tests successful\" -Type 'Availability'\n    }\n    \n    return $dcHealth\n}\n\nfunction Test-ADReplicationHealth {\n    Write-AuditLog 'Checking Active Directory Replication Health...' -Level Info\n    \n    try {\n        # Run replication diagnostics\n        $replsum = repadmin /replsum 2>&1\n        $showrepl = repadmin /showrepl 2>&1\n        \n        # Check for replication errors\n        $replicationErrors = $showrepl | Where-Object { $_ -match 'error|fail' }\n        if ($replicationErrors.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Replication' -Title 'Active Directory Replication Errors' -Severity 'Critical' `\n                -Description 'Active Directory replication errors detected between domain controllers.' `\n                -Impact 'Data inconsistency across domain controllers, potential authentication issues.' `\n                -Recommendation 'Investigate and resolve replication errors immediately using repadmin tools.' `\n                -Evidence ($replicationErrors | Out-String) -Type 'Availability' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check replication latency\n        $latency = repadmin /latency 2>&1\n        # Parse latency results and flag high latency (implementation depends on environment)\n        \n        # Save replication reports\n        $replsum | Out-File -FilePath (Join-Path $script:OutputDir 'replication-summary.txt')\n        $showrepl | Out-File -FilePath (Join-Path $script:OutputDir 'replication-details.txt')\n        \n    } catch {\n        Write-AuditLog \"Error checking replication health: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Replication' -Title 'Replication Health Check Failed' -Severity 'Medium' `\n            -Description 'Unable to complete replication health assessment.' `\n            -Impact 'Cannot verify replication status between domain controllers.' `\n            -Recommendation 'Manually check replication using repadmin commands.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Test-FSMORoleAvailability {\n    Write-AuditLog 'Checking FSMO Role Holder Availability...' -Level Info\n    \n    try {\n        $forest = Get-ADForest\n        $domain = Get-ADDomain\n        \n        $fsmoRoles = @{\n            'Schema Master' = $forest.SchemaMaster\n            'Domain Naming Master' = $forest.DomainNamingMaster\n            'Infrastructure Master' = $domain.InfrastructureMaster\n            'RID Master' = $domain.RIDMaster\n            'PDC Emulator' = $domain.PDCEmulator\n        }\n        \n        foreach ($role in $fsmoRoles.GetEnumerator()) {\n            $roleHolder = $role.Value\n            Write-AuditLog \"Checking $($role.Key) on $roleHolder\" -Level Info\n            \n            $pingResult = Test-Connection -ComputerName $roleHolder -Count 1 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'FSMO Roles' -Title \"FSMO Role Holder Unavailable: $($role.Key)\" -Severity 'Critical' `\n                    -Description \"FSMO role holder $roleHolder for $($role.Key) is not responding.\" `\n                    -Impact 'Critical AD operations may fail, affecting domain functionality.' `\n                    -Recommendation 'Investigate role holder availability and consider FSMO role transfer if necessary.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error checking FSMO roles: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'FSMO Roles' -Title 'FSMO Role Check Failed' -Severity 'Medium' `\n            -Description 'Unable to verify FSMO role holder availability.' `\n            -Impact 'Cannot confirm critical AD role functionality.' `\n            -Recommendation 'Manually verify FSMO role holders using netdom or AD tools.' `\n            -Evidence $_.Exception.Message -Type 'Configuration'\n    }\n}\n\nfunction Test-ADContainerStructure {\n    Write-AuditLog 'Analyzing AD Container Structure and Best Practices...' -Level Info\n    \n    try {\n        $domainDN = (Get-ADDomain).DistinguishedName\n        \n        # Check for computer objects in default Computers container\n        $computersInDefault = Get-ADObject -SearchBase \"CN=Computers,$domainDN\" -Filter * -ErrorAction Stop\n        if ($computersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'Computer Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($computersInDefault.Count) computer objects found in default Computers container.\" `\n                -Impact 'Objects in default containers cannot have Group Policy applied effectively.' `\n                -Recommendation 'Move computer objects to appropriate organizational units for proper management.' `\n                -Evidence ($computersInDefault | Select-Object Name | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check for user objects in default Users container\n        $systemObjects = @('DnsAdmins', 'DnsUpdateProxy', 'Administrator', 'Guest', 'krbtgt')\n        $usersInDefault = Get-ADObject -SearchBase \"CN=Users,$domainDN\" -Filter { ObjectClass -eq 'user' } -Properties isCriticalSystemObject, samAccountName -ErrorAction Stop |\n            Where-Object { \n                $_.SamAccountName -notin $systemObjects -and \n                $_.isCriticalSystemObject -ne $true -and\n                -not ($_.SamAccountName -like 'AAD_*') -and\n                -not ($_.SamAccountName -like 'MOL_*') -and\n                -not ($_.SamAccountName -like 'MSOL_*')\n            }\n        \n        if ($usersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'User Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($usersInDefault.Count) user objects found in default Users container.\" `\n                -Impact 'Users in default container cannot have proper Group Policy targeting.' `\n                -Recommendation 'Move user objects to appropriate organizational units based on department and function.' `\n                -Evidence ($usersInDefault | Select-Object Name, SamAccountName | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD container structure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-GroupPolicyCompliance {\n    Write-AuditLog 'Analyzing Group Policy Configuration and Compliance...' -Level Info\n    \n    # Check if GroupPolicy module is available\n    if ('GroupPolicy' -notin $script:AvailableModules) {\n        Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n        Add-AuditFinding -Category 'Group Policy' -Title 'Group Policy Module Not Available' -Severity 'Info' `\n            -Description 'GroupPolicy PowerShell module is not installed or available.' `\n            -Impact 'Group Policy analysis and auditing features are limited without this module.' `\n            -Recommendation 'Install RSAT tools to enable full Group Policy auditing capabilities.' `\n            -Evidence 'GroupPolicy module check failed' -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        return\n    }\n    \n    try {\n        Import-Module GroupPolicy -SkipEditionCheck -ErrorAction Stop\n        \n        if (-not (Get-Module GroupPolicy)) {\n            Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n            return\n        }\n        \n        $allGPOs = Get-GPO -All -ErrorAction Stop\n        $unlinkedGPOs = @()\n        \n        foreach ($gpo in $allGPOs) {\n            try {\n                $gpoReport = Get-GPOReport -Guid $gpo.Id -ReportType XML -ErrorAction Stop\n                if ($gpoReport -and $gpoReport -notmatch '<LinksTo>') {\n                    $unlinkedGPOs += $gpo\n                }\n            } catch {\n                Write-AuditLog \"Could not check linking for GPO: $($gpo.DisplayName)\" -Level Warning\n            }\n        }\n        \n        if ($unlinkedGPOs.Count -gt 0) {\n            Add-AuditFinding -Category 'Group Policy' -Title 'Unlinked Group Policy Objects' -Severity 'Low' `\n                -Description \"$($unlinkedGPOs.Count) GPOs are not linked to any organizational units.\" `\n                -Impact 'Unlinked GPOs create administrative overhead and may indicate poor policy management.' `\n                -Recommendation 'Review each unlinked GPO and either link to appropriate OUs or backup and delete if no longer needed.' `\n                -Evidence ($unlinkedGPOs | Select-Object DisplayName, CreationTime | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Export GPO inventory\n        $allGPOs | Select-Object DisplayName, Id, CreationTime, ModificationTime, @{Name=\"Linked\";Expression={\n            try { \n                $report = Get-GPOReport -Guid $_.Id -ReportType XML -ErrorAction Stop\n                if ($report -match '<LinksTo>') { 'Yes' } else { 'No' }\n            } catch { 'Unknown' }\n        }} | Export-Csv -Path (Join-Path $script:OutputDir 'group-policy-inventory.csv') -NoTypeInformation\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Group Policy: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ServiceAccountSecurity {\n    Write-AuditLog 'Analyzing Service Account Security...' -Level Info\n    \n    try {\n        # Check for service accounts with old passwords\n        $oldPasswordThreshold = (Get-Date).AddDays(-180)\n        $serviceAccountsOldPasswords = Get-ADUser -Filter {\n            passwordLastSet -lt $oldPasswordThreshold -and \n            Enabled -eq $true\n        } -Properties PasswordLastSet, ServicePrincipalName -ErrorAction Stop |\n            Where-Object { $_.ServicePrincipalName -or $_.SamAccountName -like '*svc*' -or $_.SamAccountName -like '*service*' }\n        \n        if ($serviceAccountsOldPasswords.Count -gt 0) {\n            Add-AuditFinding -Category 'Service Accounts' -Title 'Service Accounts with Old Passwords' -Severity 'High' `\n                -Description \"$($serviceAccountsOldPasswords.Count) service accounts have passwords older than 180 days.\" `\n                -Impact 'Old service account passwords increase risk of credential compromise.' `\n                -Recommendation 'Schedule coordinated password changes with application owners.' `\n                -Evidence ($serviceAccountsOldPasswords | Select-Object SamAccountName, PasswordLastSet | Out-String) -Type 'Security' -ComplianceFramework 'NIST'\n        }\n        \n        # Check KRBTGT account password age\n        $krbtgtAccount = Get-ADUser -Identity 'krbtgt' -Properties PasswordLastSet -ErrorAction Stop\n        if ($krbtgtAccount) {\n            $passwordAge = (Get-Date) - $krbtgtAccount.PasswordLastSet\n            if ($passwordAge.Days -gt 180) {\n                Add-AuditFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Too Old' -Severity 'High' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old.\" `\n                    -Impact 'Old KRBTGT passwords can be exploited for Golden Ticket attacks.' `\n                    -Recommendation 'Reset KRBTGT password twice with 10-hour intervals between resets.' `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            } else {\n                Add-PositiveFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Age Compliant' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old, within the recommended 180-day limit.\" `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing service account security: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-DNSInfrastructure {\n    Write-AuditLog 'Analyzing DNS Infrastructure Health...' -Level Info\n    \n    try {\n        # Get PDC Emulator to run DNS diagnostics\n        try {\n            $pdcEmulator = (Get-ADDomain).PDCEmulator\n            Write-AuditLog \"Running DNS diagnostics against PDC Emulator: $pdcEmulator\" -Level Info\n            $dnsResults = dcdiag /test:dns /s:$pdcEmulator 2>&1\n        } catch {\n            Write-AuditLog \"Could not identify PDC Emulator, trying any available DC\" -Level Warning\n            try {\n                $anyDC = (Get-ADDomainController -Discover).Name\n                Write-AuditLog \"Running DNS diagnostics against DC: $anyDC\" -Level Info\n                $dnsResults = dcdiag /test:dns /s:$anyDC 2>&1\n            } catch {\n                Write-AuditLog \"Could not find any available DC, running locally\" -Level Warning\n                $dnsResults = dcdiag /test:dns 2>&1\n            }\n        }\n        \n        # Check for DNS errors\n        if ($dnsResults -match 'failed|error') {\n            Add-AuditFinding -Category 'DNS Infrastructure' -Title 'DNS Health Issues Detected' -Severity 'Medium' `\n                -Description 'DNS diagnostic tests detected configuration or operational issues.' `\n                -Impact 'DNS issues can cause authentication failures and service disruptions.' `\n                -Recommendation 'Review DNS configuration and resolve identified issues.' `\n                -Evidence ($dnsResults | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check DNS zones for secure updates (if DNS server role is available)\n        try {\n            $dnsZones = Get-DnsServerZone -ErrorAction Stop\n            $insecureZones = $dnsZones | Where-Object { $_.DynamicUpdate -eq 'NonSecureAndSecure' }\n            \n            if ($insecureZones.Count -gt 0) {\n                Add-AuditFinding -Category 'DNS Security' -Title 'DNS Zones Allow Insecure Updates' -Severity 'High' `\n                    -Description \"$($insecureZones.Count) DNS zones allow non-secure dynamic updates.\" `\n                    -Impact 'Insecure DNS updates can lead to DNS poisoning attacks.' `\n                    -Recommendation 'Configure all DNS zones to use secure dynamic updates only.' `\n                    -Evidence ($insecureZones | Select-Object ZoneName, DynamicUpdate | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Could not check DNS zones (may not be DNS server)\" -Level Warning\n        }\n        \n        # Save DNS diagnostic results\n        $dnsResults | Out-File -FilePath (Join-Path $script:OutputDir 'dns-diagnostic.txt')\n        \n    } catch {\n        Write-AuditLog \"Error analyzing DNS infrastructure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ADSecurityConfiguration {\n    Write-AuditLog 'Analyzing Active Directory Security Configuration...' -Level Info\n    \n    try {\n        # Check domain password policy - Complete configuration\n        $passwordPolicy = Get-ADDefaultDomainPasswordPolicy -ErrorAction Stop\n        if ($passwordPolicy) {\n            Write-AuditLog 'Analyzing complete password policy configuration...' -Level Info\n            \n            # Create comprehensive password policy evidence\n            $passwordPolicyEvidence = @\"\nDomain Password Policy Configuration:\n- Minimum Password Length: $($passwordPolicy.MinPasswordLength) characters\n- Password Complexity Enabled: $($passwordPolicy.ComplexityEnabled)\n- Maximum Password Age: $($passwordPolicy.MaxPasswordAge.Days) days\n- Minimum Password Age: $($passwordPolicy.MinPasswordAge.Days) days\n- Password History Count: $($passwordPolicy.PasswordHistoryCount)\n- Lockout Duration: $($passwordPolicy.LockoutDuration.TotalMinutes) minutes\n- Lockout Observation Window: $($passwordPolicy.LockoutObservationWindow.TotalMinutes) minutes\n- Lockout Threshold: $($passwordPolicy.LockoutThreshold) attempts\n- Reversible Encryption: $($passwordPolicy.ReversibleEncryptionEnabled)\n\"@\n            \n            # Add comprehensive password policy finding\n            Add-AuditFinding -Category 'Password Policy' -Title 'Complete Password Policy Configuration' -Severity 'Info' `\n                -Description 'Complete domain password policy configuration documented.' `\n                -Impact 'Password policy settings directly impact security posture.' `\n                -Recommendation 'Review password policy settings against security best practices.' `\n                -Evidence $passwordPolicyEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            \n            # Check minimum password length\n            if ($passwordPolicy.MinPasswordLength -lt 12) {\n                $severity = if ($passwordPolicy.MinPasswordLength -lt 8) { 'High' } else { 'Medium' }\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Minimum Password Length' -Severity $severity `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Weak password requirements increase risk of password-based attacks and credential compromise.' `\n                    -Recommendation 'Set minimum password length to at least 12 characters (current industry standard). Recommended: 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MinPasswordLength -lt 14) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Length Below Recommended Standard' -Severity 'Low' `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Password length meets minimum requirements but falls short of recommended best practices.' `\n                    -Recommendation 'Consider increasing minimum password length to 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Strong Minimum Password Length' `\n                    -Description \"Minimum password length is appropriately set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordLength) characters (meets recommended standard of 14+)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check password complexity\n            if ($passwordPolicy.ComplexityEnabled -eq $false) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Complexity Not Enforced' -Severity 'High' `\n                    -Description 'Password complexity requirements are not enforced.' `\n                    -Impact 'Simple passwords increase risk of brute force and dictionary attacks.' `\n                    -Recommendation 'Enable password complexity requirements. NB: Exception applies if password policies are propagated via Azure AD - Azure AD and on-premises AD complexity requirements may conflict with password writeback enabled, especially with name-based character restrictions.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Password Complexity Properly Enforced' `\n                    -Description 'Password complexity requirements are enabled and enforced.' `\n                    -Evidence \"Complexity enabled: $($passwordPolicy.ComplexityEnabled)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check maximum password age\n            if ($passwordPolicy.MaxPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Never Expires Policy' -Severity 'High' `\n                    -Description \"Maximum password age is set to 0 days (passwords never expire).\" `\n                    -Impact 'Passwords that never expire pose significant security risk as compromised credentials remain valid indefinitely.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -lt 30) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Too Short' -Severity 'Medium' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Very short password aging may lead to user frustration and weaker password choices.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -gt 150) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Requires Review' -Severity 'Low' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Extended password aging may increase risk of compromised credentials remaining valid longer.' `\n                    -Recommendation 'Review and consider reducing maximum password age to 150 days or less for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Password Age Policy' `\n                    -Description \"Maximum password age is appropriately set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MaxPasswordAge.Days) days (within recommended 30-150 day range)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check minimum password age\n            if ($passwordPolicy.MinPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Minimum Password Age Not Set' -Severity 'High' `\n                    -Description \"Minimum password age is set to 0 days (users can change passwords immediately).\" `\n                    -Impact 'Users can bypass password history restrictions by changing passwords multiple times in succession.' `\n                    -Recommendation 'Set minimum password age to 1 day or more to prevent password history bypass.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Minimum Password Age Policy' `\n                    -Description \"Minimum password age is appropriately set to $($passwordPolicy.MinPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordAge.Days) days (prevents password history bypass)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check password history\n            if ($passwordPolicy.PasswordHistoryCount -lt 12) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Password History' -Severity 'Medium' `\n                    -Description \"Password history is set to remember only $($passwordPolicy.PasswordHistoryCount) passwords.\" `\n                    -Impact 'Insufficient password history allows users to reuse recent passwords.' `\n                    -Recommendation 'Set password history to remember at least 12 previous passwords.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check account lockout policy\n            if ($passwordPolicy.LockoutThreshold -eq 0) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Policy Not Configured' -Severity 'High' `\n                    -Description 'Account lockout policy is not configured (lockout threshold is 0).' `\n                    -Impact 'No protection against brute force password attacks.' `\n                    -Recommendation 'Configure account lockout policy with threshold of 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.LockoutThreshold -gt 10) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Threshold Too High' -Severity 'Medium' `\n                    -Description \"Account lockout threshold is set to $($passwordPolicy.LockoutThreshold) attempts.\" `\n                    -Impact 'High lockout threshold provides insufficient protection against brute force attacks.' `\n                    -Recommendation 'Set account lockout threshold to 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check lockout duration\n            if ($passwordPolicy.LockoutDuration.TotalMinutes -lt 15) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Duration Too Short' -Severity 'Medium' `\n                    -Description \"Account lockout duration is set to $($passwordPolicy.LockoutDuration.TotalMinutes) minutes.\" `\n                    -Impact 'Short lockout duration may not effectively deter brute force attacks.' `\n                    -Recommendation 'Set account lockout duration to at least 15 minutes.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check reversible encryption\n            if ($passwordPolicy.ReversibleEncryptionEnabled -eq $true) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Reversible Encryption Enabled' -Severity 'Critical' `\n                    -Description 'Reversible encryption for passwords is enabled.' `\n                    -Impact 'Passwords stored with reversible encryption are equivalent to plaintext.' `\n                    -Recommendation 'Disable reversible encryption immediately unless required for specific legacy applications.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n        }\n        \n        # Check for accounts with PasswordNotRequired or PasswordNeverExpires\n        Write-AuditLog 'Checking for accounts with problematic password settings...' -Level Info\n        \n        try {\n            # Check for accounts with PasswordNotRequired\n            $passwordNotRequiredAccounts = Get-ADUser -Filter {PasswordNotRequired -eq $true -and Enabled -eq $true} -Properties PasswordNotRequired, LastLogonDate, Created\n            if ($passwordNotRequiredAccounts.Count -gt 0) {\n                $passwordNotRequiredEvidence = $passwordNotRequiredAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Password Not Required' -Severity 'High' `\n                    -Description \"Found $($passwordNotRequiredAccounts.Count) enabled accounts with 'Password Not Required' setting.\" `\n                    -Impact 'Accounts without password requirements pose significant security risk.' `\n                    -Recommendation 'Review and disable Password Not Required setting for all accounts unless absolutely necessary.' `\n                    -Evidence $passwordNotRequiredEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check for accounts with PasswordNeverExpires (excluding service accounts)\n            $passwordNeverExpiresAccounts = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} -Properties PasswordNeverExpires, LastLogonDate, Created, ServicePrincipalName\n            # Filter out service accounts (those with SPNs or service account naming patterns)\n            $nonServiceAccounts = $passwordNeverExpiresAccounts | Where-Object { \n                -not $_.ServicePrincipalName -and \n                $_.SamAccountName -notmatch '^(svc|service|sql|iis|app)' -and\n                $_.SamAccountName -notmatch '^\\$' \n            }\n            \n            if ($nonServiceAccounts.Count -gt 0) {\n                $passwordNeverExpiresEvidence = $nonServiceAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Non-Service Accounts with Password Never Expires' -Severity 'High' `\n                    -Description \"Found $($nonServiceAccounts.Count) enabled non-service accounts with 'Password Never Expires' setting.\" `\n                    -Impact 'Accounts with non-expiring passwords increase security risk if compromised.' `\n                    -Recommendation 'Review and disable Password Never Expires for non-service accounts.' `\n                    -Evidence $passwordNeverExpiresEvidence -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check for accounts with expired passwords\n            $expiredPasswordAccounts = Get-ADUser -Filter {Enabled -eq $true -and PasswordExpired -eq $true} -Properties PasswordExpired, LastLogonDate, PasswordLastSet\n            if ($expiredPasswordAccounts.Count -gt 0) {\n                $expiredPasswordEvidence = $expiredPasswordAccounts | Select-Object Name, SamAccountName, LastLogonDate, PasswordLastSet | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Expired Passwords' -Severity 'Medium' `\n                    -Description \"Found $($expiredPasswordAccounts.Count) enabled accounts with expired passwords.\" `\n                    -Impact 'Accounts with expired passwords may indicate inactive accounts or password policy issues.' `\n                    -Recommendation 'Review expired password accounts and either reset passwords or disable unused accounts.' `\n                    -Evidence $expiredPasswordEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n        } catch {\n            Write-AuditLog \"Error checking account password settings: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Check for privileged account analysis - Extended sensitive groups\n        $privilegedGroups = @('Domain Admins', 'Enterprise Admins', 'Schema Admins', 'Administrators')\n        $sensitiveGroups = @('Backup Operators', 'Server Operators', 'Print Operators', 'Account Operators', 'Replicator', 'Network Configuration Operators', 'Hyper-V Administrators', 'Remote Desktop Users')\n        \n        Write-AuditLog 'Analyzing privileged and sensitive group memberships...' -Level Info\n        \n        # Check core privileged groups\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop\n                if ($members.Count -gt 5) {\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Excessive Privileged Group Membership: $group\" -Severity 'Medium' `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact 'Large privileged groups increase attack surface and compliance risk.' `\n                        -Recommendation 'Review privileged group membership and remove unnecessary accounts.' `\n                        -Evidence ($members | Select-Object Name, ObjectClass | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group\" -Level Warning\n            }\n        }\n        \n        # Check for inactive privileged accounts\n        $inactiveThreshold = (Get-Date).AddDays(-90)\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop | Where-Object { $_.objectClass -eq 'user' }\n                foreach ($member in $members) {\n                    $user = Get-ADUser -Identity $member.SamAccountName -Properties LastLogonDate -ErrorAction Stop\n                    if ($user.LastLogonDate -and $user.LastLogonDate -lt $inactiveThreshold) {\n                        Add-AuditFinding -Category 'Privileged Access' -Title \"Inactive Privileged Account: $($user.SamAccountName)\" -Severity 'High' `\n                            -Description \"Privileged account $($user.SamAccountName) has not logged in for over 90 days.\" `\n                            -Impact 'Inactive privileged accounts create security risk and compliance violations.' `\n                            -Recommendation 'Disable or remove inactive privileged accounts after proper verification.' `\n                            -Evidence \"Last logon: $($user.LastLogonDate)\" -Type 'Security' -ComplianceFramework 'ISO27001'\n                    }\n                }\n            } catch {\n                Write-AuditLog \"Could not check inactive accounts for $group\" -Level Warning\n            }\n        }\n        \n        # Check sensitive groups for unexpected membership\n        foreach ($group in $sensitiveGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction SilentlyContinue\n                if ($members -and $members.Count -gt 0) {\n                    $memberEvidence = $members | Select-Object Name, ObjectClass | Out-String\n                    $severity = switch ($group) {\n                        'Backup Operators' { 'High' }\n                        'Server Operators' { 'High' }\n                        'Account Operators' { 'High' }\n                        default { 'Medium' }\n                    }\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Sensitive Group Has Members: $group\" -Severity $severity `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact \"Members of $group have elevated privileges that could be misused.\" `\n                        -Recommendation \"Review membership of $group and remove unnecessary accounts.\" `\n                        -Evidence $memberEvidence -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group (may not exist)\" -Level Info\n            }\n        }\n        \n        # Check for disabled user accounts that should be cleaned up\n        Write-AuditLog 'Checking for disabled user accounts...' -Level Info\n        try {\n            $disabledUsers = Get-ADUser -Filter {Enabled -eq $false} -Properties LastLogonDate, WhenChanged\n            $oldDisabledUsers = $disabledUsers | Where-Object { $_.WhenChanged -lt (Get-Date).AddDays(-90) }\n            \n            if ($oldDisabledUsers.Count -gt 0) {\n                $disabledUsersEvidence = $oldDisabledUsers | Select-Object Name, SamAccountName, LastLogonDate, WhenChanged | Sort-Object WhenChanged | Out-String\n                Add-AuditFinding -Category 'Account Hygiene' -Title 'Old Disabled User Accounts' -Severity 'Medium' `\n                    -Description \"Found $($oldDisabledUsers.Count) user accounts that have been disabled for more than 90 days.\" `\n                    -Impact 'Old disabled accounts consume resources and may indicate incomplete cleanup processes.' `\n                    -Recommendation 'Review old disabled accounts and remove them if no longer needed for auditing purposes.' `\n                    -Evidence $disabledUsersEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Error checking disabled user accounts: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD security configuration: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-CertificateServices {\n    Write-AuditLog 'Analyzing Certificate Services Infrastructure...' -Level Info\n    \n    try {\n        # Check Certificate Authority service - improved detection\n        $caService = Get-Service -Name 'CertSvc' -ErrorAction SilentlyContinue\n        if ($caService) {\n            if ($caService.Status -ne 'Running') {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificate Authority Service Not Running' -Severity 'High' `\n                    -Description 'Certificate Authority service is not running.' `\n                    -Impact 'PKI services unavailable, affecting certificate enrollment and validation.' `\n                    -Recommendation 'Start Certificate Authority service and investigate startup issues.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        } else {\n            Write-AuditLog 'Certificate Services not installed on this system' -Level Info\n        }\n        \n        # Check for expiring certificates in local machine store (regardless of CA installation)\n        try {\n            $expiringCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) -and $_.NotAfter -gt (Get-Date) }\n            \n            if ($expiringCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificates Expiring Soon' -Severity 'Medium' `\n                    -Description \"$($expiringCerts.Count) certificates will expire within 30 days.\" `\n                    -Impact 'Certificate expiration can cause service disruptions and authentication failures.' `\n                    -Recommendation 'Review expiring certificates and plan for renewal.' `\n                    -Evidence ($expiringCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n            \n            # Check for already expired certificates\n            $expiredCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date) }\n            \n            if ($expiredCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Expired Certificates Found' -Severity 'Medium' `\n                    -Description \"$($expiredCerts.Count) expired certificates found in local machine store.\" `\n                    -Impact 'Expired certificates should be removed to maintain clean certificate store.' `\n                    -Recommendation 'Remove expired certificates that are no longer needed.' `\n                    -Evidence ($expiredCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n        } catch {\n            Write-AuditLog \"Could not check certificate store: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Certificate Services: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\n# ==============================================================================\n# SERVER INFRASTRUCTURE AUDIT\n# ==============================================================================\n\nfunction Start-ServerInfrastructureAudit {\n    Write-AuditLog 'Starting Server Infrastructure Audit' -Level Header\n    \n    try {\n        # Discover server list\n        $serverList = Get-ServerInventory\n        \n        if ($serverList.Count -eq 0) {\n            Write-AuditLog \"No servers found for auditing\" -Level Warning\n            return\n        }\n        \n        Write-AuditLog \"Found $($serverList.Count) servers to audit\" -Level Success\n        \n        # Get credentials for server access\n        $credential = Get-AuditCredentials\n        if (-not $credential) {\n            Write-AuditLog \"No credentials provided for server audit\" -Level Warning\n            return\n        }\n        \n        # Audit servers in parallel\n        Start-ParallelServerAudit -ServerList $serverList -Credential $credential\n        \n    } catch {\n        Write-AuditLog \"Error during server infrastructure audit: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'Server Audit' -Title 'Server Infrastructure Audit Failed' -Severity 'High' `\n            -Description 'Unable to complete server infrastructure assessment.' `\n            -Impact 'Cannot verify server security and configuration compliance.' `\n            -Recommendation 'Investigate server audit failures and retry with proper credentials.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Get-ServerInventory {\n    Write-AuditLog 'Discovering server inventory...' -Level Info\n    \n    try {\n        if ($ServerListPath -and (Test-Path $ServerListPath)) {\n            # Load from CSV file\n            Write-AuditLog \"Loading server list from: $ServerListPath\" -Level Info\n            $serverList = Import-Csv -Path $ServerListPath\n            return $serverList | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.ServerName\n                    Description = if ($_.Description) { $_.Description } else { 'Imported from CSV' }\n                    Environment = if ($_.Environment) { $_.Environment } else { 'Unknown' }\n                }\n            }\n        } else {\n            # Auto-discover from Active Directory\n            Write-AuditLog \"Auto-discovering servers from Active Directory\" -Level Info\n            $adServers = Get-ADComputer -Filter {OperatingSystem -like \"*Server*\" -and Enabled -eq $true} -Properties Name, OperatingSystem, Description\n            \n            return $adServers | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.Name\n                    Description = if ($_.Description) { $_.Description } else { $_.OperatingSystem }\n                    Environment = 'Production' # Default assumption\n                }\n            }\n        }\n    } catch {\n        Write-AuditLog \"Error discovering server inventory: $($_.Exception.Message)\" -Level Error\n        return @()\n    }\n}\n\nfunction Get-AuditCredentials {\n    if ($CredentialPath -and (Test-Path $CredentialPath)) {\n        try {\n            Write-AuditLog \"Loading credentials from: $CredentialPath\" -Level Info\n            return Import-Clixml -Path $CredentialPath\n        } catch {\n            Write-AuditLog \"Failed to load credentials from file, prompting user\" -Level Warning\n        }\n    }\n    \n    Write-Host \"`nPlease provide credentials for server access:\" -ForegroundColor Yellow\n    return Get-Credential -Message \"Enter credentials for server auditing (Domain Admin or equivalent)\"\n}\n\nfunction Start-ParallelServerAudit {\n    param(\n        [Parameter(Mandatory=$true)]\n        [array]$ServerList,\n        \n        [Parameter(Mandatory=$true)]\n        [PSCredential]$Credential\n    )\n    \n    Write-AuditLog \"Starting parallel audit of $($ServerList.Count) servers with max $MaxConcurrentJobs concurrent jobs\" -Level Info\n    Write-AuditLog \"Using credentials for user: $($Credential.UserName)\" -Level Info\n    Write-AuditLog \"Server list: $($ServerList | ForEach-Object { $_.ServerName } | Join-String -Separator ', ')\" -Level Info\n    \n    $jobs = @()\n    $completedServers = 0\n    \n    # Start initial batch of jobs\n    foreach ($server in $ServerList) {\n        if ($jobs.Count -lt $MaxConcurrentJobs) {\n            Write-AuditLog \"Starting audit job for server: $($server.ServerName)\" -Level Info\n            $job = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $server, $Credential\n            $jobs += [PSCustomObject]@{ Job = $job; Server = $server; StartTime = Get-Date }\n            Write-AuditLog \"Job started for $($server.ServerName) - Job ID: $($job.Id)\" -Level Info\n        } else {\n            break\n        }\n    }\n    \n    $remainingServers = $ServerList[$jobs.Count..($ServerList.Count-1)]\n    \n    # Monitor jobs and start new ones as they complete\n    $loopCount = 0\n    $maxLoops = 1800  # 1 hour maximum (3600 seconds / 2 second sleep)\n    while (($jobs.Count -gt 0 -or $remainingServers.Count -gt 0) -and $loopCount -lt $maxLoops) {\n        Start-Sleep -Seconds 2\n        $loopCount++\n        \n        # Enhanced logging every 30 seconds (15 loops)\n        if ($loopCount % 15 -eq 0) {\n            Write-AuditLog \"Job monitoring status: $($jobs.Count) active jobs, $($remainingServers.Count) servers remaining\" -Level Info\n            foreach ($job in $jobs) {\n                $runtime = [math]::Round(((Get-Date) - $job.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"  - Server: $($job.Server.ServerName), State: $($job.Job.State), Runtime: ${runtime} minutes\" -Level Info\n            }\n        }\n        \n        $finishedJobs = $jobs | Where-Object { $_.Job.State -in @('Completed', 'Failed', 'Stopped') }\n        \n        foreach ($finishedJob in $finishedJobs) {\n            try {\n                $runtime = [math]::Round(((Get-Date) - $finishedJob.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"Processing completed job for server: $($finishedJob.Server.ServerName) (Runtime: ${runtime} minutes, State: $($finishedJob.Job.State))\" -Level Info\n                \n                $result = Receive-Job -Job $finishedJob.Job\n                $script:ServerResults += $result\n                $completedServers++\n                \n                Write-AuditLog \"Server audit completed for $($finishedJob.Server.ServerName). Connection Status: $($result.ConnectionStatus), Risk Score: $($result.RiskScore)\" -Level Success\n                \n                # Update separate progress for server audit\n                $serverPercent = [math]::Min([math]::Round(($completedServers / $ServerList.Count) * 100, 1), 100)\n                Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Status \"Completed $($finishedJob.Server.ServerName)\" -PercentComplete $serverPercent -CurrentOperation \"Auditing $completedServers of $($ServerList.Count) servers\"\n                \n                Remove-Job -Job $finishedJob.Job\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n                \n                # Start next job if servers remain\n                if ($remainingServers.Count -gt 0) {\n                    $nextServer = $remainingServers[0]\n                    $remainingServers = $remainingServers[1..($remainingServers.Count-1)]\n                    \n                    Write-AuditLog \"Starting new audit job for server: $($nextServer.ServerName)\" -Level Info\n                    $newJob = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $nextServer, $Credential\n                    $jobs += [PSCustomObject]@{ Job = $newJob; Server = $nextServer; StartTime = Get-Date }\n                    Write-AuditLog \"New job started for $($nextServer.ServerName) - Job ID: $($newJob.Id)\" -Level Info\n                }\n                \n            } catch {\n                Write-AuditLog \"Error processing job result for $($finishedJob.Server.ServerName): $($_.Exception.Message)\" -Level Error\n                Remove-Job -Job $finishedJob.Job -ErrorAction Stop\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n            }\n        }\n        \n        # Check for hung jobs (running longer than 5 minutes)\n        $hungJobs = $jobs | Where-Object { ((Get-Date) - $_.StartTime).TotalMinutes -gt 5 }\n        foreach ($hungJob in $hungJobs) {\n            $runtime = [math]::Round(((Get-Date) - $hungJob.StartTime).TotalMinutes, 1)\n            Write-AuditLog \"Stopping hung job for server $($hungJob.Server.ServerName) - Runtime: ${runtime} minutes, State: $($hungJob.Job.State)\" -Level Warning\n            \n            # Try to get any partial results\n            try {\n                $partialResult = Receive-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n                if ($partialResult) {\n                    Write-AuditLog \"Retrieved partial results from hung job for $($hungJob.Server.ServerName)\" -Level Info\n                    $script:ServerResults += $partialResult\n                }\n            } catch {\n                Write-AuditLog \"Could not retrieve results from hung job for $($hungJob.Server.ServerName): $($_.Exception.Message)\" -Level Warning\n            }\n            \n            Stop-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            $jobs = $jobs | Where-Object { $_.Job.Id -ne $hungJob.Job.Id }\n            $completedServers++ # Count as completed even if hung\n            \n            # Add failure finding\n            Add-AuditFinding -Category 'Server Audit' -Title \"Server Audit Timeout: $($hungJob.Server.ServerName)\" -Severity 'Medium' `\n                -Description \"Server audit job exceeded 5-minute timeout limit (Runtime: ${runtime} minutes).\" `\n                -Impact 'Unable to complete comprehensive assessment of server.' `\n                -Recommendation 'Investigate server connectivity and performance issues. Check WinRM, firewall, and authentication settings.' `\n                -Type 'Availability'\n        }\n    }\n    \n    # Check if we exceeded maximum loop count\n    if ($loopCount -ge $maxLoops) {\n        Write-AuditLog \"Server audit monitoring exceeded maximum time limit (1 hour). Forcing completion.\" -Level Warning\n        # Clean up any remaining jobs\n        foreach ($job in $jobs) {\n            Write-AuditLog \"Force stopping job for server: $($job.Server.ServerName)\" -Level Warning\n            Stop-Job -Job $job.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $job.Job -ErrorAction SilentlyContinue\n        }\n    }\n    \n    Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Completed\n    Write-AuditLog \"Server infrastructure audit completed. Processed $completedServers of $($ServerList.Count) servers\" -Level Success\n}\n\n# Define the script block for server auditing\n$script:ServerAuditScriptBlock = {\n    param($ServerInfo, $Credential)\n    \n    $serverName = $ServerInfo.ServerName\n    $auditResult = [PSCustomObject]@{\n        ServerName = $serverName\n        Description = $ServerInfo.Description\n        Environment = $ServerInfo.Environment\n        PingStatus = 'Unknown'\n        ConnectionStatus = 'Unknown'\n        OperatingSystem = ''\n        OSVersion = ''\n        Architecture = ''\n        Manufacturer = ''\n        Model = ''\n        SerialNumber = ''\n        TotalMemoryGB = 0\n        ProcessorInfo = ''\n        ProcessorCores = 0\n        CPUUtilization = 0\n        MemoryUtilization = 0\n        DiskInfo = @()\n        NetworkAdapters = @()\n        CriticalServices = @()\n        InstalledRoles = @()\n        LocalAdministrators = @()\n        InstalledSoftware = @()\n        ScheduledTasks = @()\n        NetworkShares = @()\n        RecentUpdates = @()\n        SecurityChecks = @{}\n        PendingUpdates = 0\n        LastBootTime = $null\n        UptimeDays = 0\n        SecurityIssues = @()\n        PerformanceIssues = @()\n        Recommendations = @()\n        RiskScore = 0\n        AuditTimestamp = Get-Date\n        ErrorMessages = @()\n    }\n    \n    try {\n        # Test connectivity\n        $pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet -ErrorAction Stop\n        $auditResult.PingStatus = if ($pingResult) { 'Online' } else { 'Offline' }\n        \n        if (-not $pingResult) {\n            $auditResult.ConnectionStatus = 'Failed - No Response'\n            $auditResult.ErrorMessages += 'Server not responding to ping'\n            return $auditResult\n        }\n        \n        # Establish remote session with enhanced error handling\n        try {\n            $sessionOption = New-PSSessionOption -OpenTimeout 30000 -OperationTimeout 300000\n            $session = New-PSSession -ComputerName $serverName -Credential $Credential -SessionOption $sessionOption -ErrorAction Stop\n            $auditResult.ConnectionStatus = 'Connected'\n        } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n            $auditResult.ConnectionStatus = 'Failed - WinRM/Remoting Issue'\n            $auditResult.ErrorMessages += \"PowerShell remoting failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.Management.Automation.RuntimeException] {\n            $auditResult.ConnectionStatus = 'Failed - Authentication Issue'\n            $auditResult.ErrorMessages += \"Authentication failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.TimeoutException] {\n            $auditResult.ConnectionStatus = 'Failed - Timeout'\n            $auditResult.ErrorMessages += \"Connection timeout: $($_.Exception.Message)\"\n            return $auditResult\n        } catch {\n            $auditResult.ConnectionStatus = 'Failed - Unknown Error'\n            $auditResult.ErrorMessages += \"Unexpected connection error: $($_.Exception.Message)\"\n            return $auditResult\n        }\n        \n        # Execute comprehensive remote audit\n        $remoteData = Invoke-Command -Session $session -ScriptBlock {\n            $results = @{\n                Errors = @()\n            }\n            \n            try {\n                # System information\n                $results.OS = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop\n                $results.ComputerSystem = Get-CimInstance Win32_ComputerSystem -ErrorAction Stop\n                $results.BIOS = Get-CimInstance Win32_BIOS -ErrorAction Stop\n                $results.Processor = Get-CimInstance Win32_Processor -ErrorAction Stop\n                \n                # Performance metrics\n                try {\n                    $cpuCounter = Get-Counter \"\\Processor(_Total)\\% Processor Time\" -MaxSamples 3 -ErrorAction Stop\n                    if ($cpuCounter) {\n                        $results.CPUUtilization = [math]::Round(($cpuCounter.CounterSamples | Measure-Object CookedValue -Average).Average, 2)\n                    }\n                } catch {\n                    $results.CPUUtilization = -1\n                }\n                \n                if ($results.ComputerSystem -and $results.OS) {\n                    $memTotal = $results.ComputerSystem.TotalPhysicalMemory\n                    $memAvailable = $results.OS.FreePhysicalMemory * 1KB\n                    $results.MemoryUtilization = [math]::Round((($memTotal - $memAvailable) / $memTotal) * 100, 2)\n                }\n                \n                # Disk information\n                $results.Disks = Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" -ErrorAction Stop\n                \n                # Network adapters\n                $results.NetworkAdapters = Get-CimInstance Win32_NetworkAdapterConfiguration -ErrorAction Stop\n                    Where-Object { $_.IPEnabled -eq $true }\n                \n                # Critical services\n                $criticalServices = @('DHCP', 'DNS', 'W32Time', 'EventLog', 'RpcSs', 'LanmanServer', 'Spooler')\n                $results.Services = Get-Service -Name $criticalServices -ErrorAction Stop | \n                    Select-Object Name, Status, StartType\n                \n                # Windows features/roles\n                try {\n                    $results.WindowsFeatures = Get-WindowsFeature -ErrorAction Stop | \n                        Where-Object { $_.Installed -eq $true } | \n                        Select-Object -ExpandProperty Name\n                } catch {\n                    $results.WindowsFeatures = @()\n                }\n                \n                # Local administrators\n                try {\n                    $results.LocalAdmins = Get-LocalGroupMember -Group \"Administrators\" -ErrorAction Stop | \n                        Select-Object Name, ObjectClass, PrincipalSource\n                } catch {\n                    $results.LocalAdmins = @()\n                }\n                \n                # Windows updates\n                try {\n                    $updateSession = New-Object -ComObject Microsoft.Update.Session -ErrorAction Stop\n                    if ($updateSession) {\n                        $updateSearcher = $updateSession.CreateUpdateSearcher()\n                        $searchResult = $updateSearcher.Search(\"IsInstalled=0\")\n                        $results.PendingUpdates = $searchResult.Updates.Count\n                    } else {\n                        $results.PendingUpdates = -1\n                    }\n                } catch {\n                    $results.PendingUpdates = -1\n                }\n                \n                # System uptime\n                if ($results.OS) {\n                    $results.LastBoot = $results.OS.LastBootUpTime\n                    $results.UptimeDays = [math]::Round(((Get-Date) - $results.LastBoot).TotalDays, 1)\n                }\n                \n                # Event log errors (last 24 hours)\n                try {\n                    $results.RecentErrors = Get-WinEvent -FilterHashtable @{\n                        LogName='System','Application'\n                        Level=1,2  # Critical and Error\n                        StartTime=(Get-Date).AddDays(-1)\n                    } -MaxEvents 10 -ErrorAction Stop\n                } catch {\n                    $results.RecentErrors = @()\n                }\n                \n                # Security configuration checks\n                $results.SecurityChecks = @{}\n                \n                # Windows Defender status\n                try {\n                    $results.SecurityChecks.DefenderStatus = Get-MpComputerStatus -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.DefenderStatus = $null\n                }\n                \n                # Firewall status\n                try {\n                    $results.SecurityChecks.FirewallProfiles = Get-NetFirewallProfile -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.FirewallProfiles = @()\n                }\n                \n                # Installed software audit\n                try {\n                    $results.InstalledSoftware = Get-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction Stop | \n                        Where-Object { $_.DisplayName -and $_.DisplayName -ne \"\" } |\n                        Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n                        Sort-Object DisplayName\n                } catch {\n                    $results.InstalledSoftware = @()\n                    $results.Errors += \"Failed to retrieve installed software\"\n                }\n                \n                # Scheduled tasks audit\n                try {\n                    $results.ScheduledTasks = Get-ScheduledTask -ErrorAction Stop | \n                        Where-Object { $_.State -eq 'Ready' -and $_.TaskPath -notlike '\\Microsoft\\*' } |\n                        Select-Object TaskName, TaskPath, State, @{N='NextRun';E={$_.NextRunTime}}, @{N='LastRun';E={$_.LastRunTime}}\n                } catch {\n                    $results.ScheduledTasks = @()\n                    $results.Errors += \"Failed to retrieve scheduled tasks\"\n                }\n                \n                # SMBv1 status check\n                try {\n                    $results.SecurityChecks.SMBv1Status = @{}\n                    # Check if SMBv1 feature is installed\n                    $smb1Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.FeatureInstalled = ($smb1Feature.State -eq 'Enabled')\n                    \n                    # Check registry settings\n                    $smb1RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n                    $smb1RegValue = Get-ItemProperty -Path $smb1RegPath -Name \"SMB1\" -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.RegistryEnabled = ($smb1RegValue.SMB1 -eq 1)\n                } catch {\n                    $results.SecurityChecks.SMBv1Status = @{FeatureInstalled = $null; RegistryEnabled = $null}\n                    $results.Errors += \"Failed to check SMBv1 status\"\n                }\n                \n                # Network shares audit\n                try {\n                    $results.NetworkShares = Get-SmbShare -ErrorAction Stop | \n                        Where-Object { $_.Name -notin @('ADMIN$', 'C$', 'IPC$', 'print$') } |\n                        Select-Object Name, Path, Description, ShareType, @{N='AccessRight';E={\n                            try {\n                                $acl = Get-SmbShareAccess -Name $_.Name -ErrorAction SilentlyContinue\n                                ($acl | ForEach-Object { \"$($_.AccountName):$($_.AccessRight)\" }) -join '; '\n                            } catch {\n                                'Unable to retrieve'\n                            }\n                        }}\n                } catch {\n                    $results.NetworkShares = @()\n                    $results.Errors += \"Failed to retrieve network shares\"\n                }\n                \n                # Enhanced antivirus detection\n                try {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                    \n                    # Windows Defender already checked above\n                    \n                    # Check for third-party antivirus via WMI\n                    try {\n                        $avProducts = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ErrorAction SilentlyContinue\n                        if ($avProducts) {\n                            $results.SecurityChecks.AntivirusProducts = $avProducts | ForEach-Object {\n                                [PSCustomObject]@{\n                                    Name = $_.displayName\n                                    State = switch ($_.productState) {\n                                        { $_ -band 0x1000 } { 'Enabled' }\n                                        default { 'Disabled' }\n                                    }\n                                    UpToDate = switch ($_.productState) {\n                                        { $_ -band 0x10 } { 'Yes' }\n                                        default { 'No' }\n                                    }\n                                }\n                            }\n                        }\n                    } catch {\n                        $results.Errors += \"Failed to query third-party antivirus products\"\n                    }\n                } catch {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                }\n                \n                # PowerShell remoting configuration\n                try {\n                    $results.SecurityChecks.PSRemoting = @{}\n                    $winrm = Get-Service WinRM -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.PSRemoting.ServiceStatus = $winrm.Status\n                    \n                    # Check WinRM listeners\n                    $listeners = winrm enumerate winrm/config/listener 2>$null\n                    $results.SecurityChecks.PSRemoting.HasListeners = ($listeners -ne $null)\n                } catch {\n                    $results.SecurityChecks.PSRemoting = @{ServiceStatus = 'Unknown'; HasListeners = $false}\n                    $results.Errors += \"Failed to check PowerShell remoting configuration\"\n                }\n                \n                # BitLocker encryption status\n                try {\n                    $results.SecurityChecks.BitLocker = @()\n                    $bitlockerVolumes = Get-BitLockerVolume -ErrorAction SilentlyContinue\n                    if ($bitlockerVolumes) {\n                        $results.SecurityChecks.BitLocker = $bitlockerVolumes | ForEach-Object {\n                            [PSCustomObject]@{\n                                MountPoint = $_.MountPoint\n                                EncryptionMethod = $_.EncryptionMethod\n                                VolumeStatus = $_.VolumeStatus\n                                ProtectionStatus = $_.ProtectionStatus\n                                EncryptionPercentage = $_.EncryptionPercentage\n                            }\n                        }\n                    }\n                } catch {\n                    $results.SecurityChecks.BitLocker = @()\n                    $results.Errors += \"Failed to check BitLocker status\"\n                }\n                \n                # Recent Windows updates\n                try {\n                    $results.RecentUpdates = Get-HotFix -ErrorAction Stop | \n                        Sort-Object InstalledOn -Descending | \n                        Select-Object -First 10 Description, HotFixID, InstalledBy, InstalledOn\n                } catch {\n                    $results.RecentUpdates = @()\n                    $results.Errors += \"Failed to retrieve recent updates\"\n                }\n                \n                # Time synchronization configuration\n                try {\n                    $results.SecurityChecks.TimeSync = @{}\n                    $w32time = w32tm /query /status 2>$null\n                    $results.SecurityChecks.TimeSync.W32TimeStatus = if ($w32time) { 'Configured' } else { 'Not Configured' }\n                    \n                    $ntpServer = w32tm /query /peers 2>$null | Where-Object { $_ -match \"Peer:\" }\n                    $results.SecurityChecks.TimeSync.NTPServers = if ($ntpServer) { $ntpServer -join '; ' } else { 'None configured' }\n                } catch {\n                    $results.SecurityChecks.TimeSync = @{W32TimeStatus = 'Unknown'; NTPServers = 'Unknown'}\n                    $results.Errors += \"Failed to check time synchronization\"\n                }\n                \n            } catch {\n                $results.Errors += \"General error: $($_.Exception.Message)\"\n            }\n            \n            return $results\n        }\n        \n        # Process remote data\n        if ($remoteData.OS) {\n            $auditResult.OperatingSystem = $remoteData.OS.Caption\n            $auditResult.OSVersion = $remoteData.OS.Version\n            $auditResult.Architecture = $remoteData.OS.OSArchitecture\n        }\n        \n        if ($remoteData.ComputerSystem) {\n            $auditResult.Manufacturer = $remoteData.ComputerSystem.Manufacturer\n            $auditResult.Model = $remoteData.ComputerSystem.Model\n            $auditResult.TotalMemoryGB = [math]::Round($remoteData.ComputerSystem.TotalPhysicalMemory / 1GB, 2)\n        }\n        \n        if ($remoteData.BIOS) {\n            $auditResult.SerialNumber = $remoteData.BIOS.SerialNumber\n        }\n        \n        if ($remoteData.Processor) {\n            $auditResult.ProcessorInfo = ($remoteData.Processor | Select-Object -First 1).Name\n            $auditResult.ProcessorCores = ($remoteData.Processor | Measure-Object NumberOfCores -Sum).Sum\n        }\n        \n        $auditResult.CPUUtilization = $remoteData.CPUUtilization\n        $auditResult.MemoryUtilization = $remoteData.MemoryUtilization\n        $auditResult.LastBootTime = $remoteData.LastBoot\n        $auditResult.UptimeDays = $remoteData.UptimeDays\n        $auditResult.PendingUpdates = $remoteData.PendingUpdates\n        $auditResult.CriticalServices = $remoteData.Services\n        $auditResult.InstalledRoles = $remoteData.WindowsFeatures\n        $auditResult.LocalAdministrators = $remoteData.LocalAdmins\n        $auditResult.InstalledSoftware = $remoteData.InstalledSoftware\n        $auditResult.ScheduledTasks = $remoteData.ScheduledTasks\n        $auditResult.NetworkShares = $remoteData.NetworkShares\n        $auditResult.RecentUpdates = $remoteData.RecentUpdates\n        $auditResult.SecurityChecks = $remoteData.SecurityChecks\n        \n        # Process disk information\n        if ($remoteData.Disks) {\n            $auditResult.DiskInfo = $remoteData.Disks | ForEach-Object {\n                $freePercent = if ($_.Size -gt 0) { [math]::Round(($_.FreeSpace / $_.Size) * 100, 1) } else { 0 }\n                [PSCustomObject]@{\n                    Drive = $_.DeviceID\n                    SizeGB = [math]::Round($_.Size / 1GB, 2)\n                    FreeSpaceGB = [math]::Round($_.FreeSpace / 1GB, 2)\n                    FreeSpacePercent = $freePercent\n                    FileSystem = $_.FileSystem\n                }\n            }\n        }\n        \n        # Process network adapters\n        if ($remoteData.NetworkAdapters) {\n            $auditResult.NetworkAdapters = $remoteData.NetworkAdapters | ForEach-Object {\n                [PSCustomObject]@{\n                    Description = $_.Description\n                    IPAddress = $_.IPAddress -join ', '\n                    DHCPEnabled = $_.DHCPEnabled\n                    DNSServers = $_.DNSServerSearchOrder -join ', '\n                }\n            }\n        }\n        \n        # Security and performance analysis\n        $securityIssues = @()\n        $performanceIssues = @()\n        $recommendations = @()\n        $riskScore = 0\n        \n        # High CPU utilization\n        if ($auditResult.CPUUtilization -gt 80) {\n            $performanceIssues += \"High CPU utilization: $($auditResult.CPUUtilization)%\"\n            $recommendations += \"Investigate high CPU usage and optimize workloads\"\n            $riskScore += 2\n        }\n        \n        # High memory utilization\n        if ($auditResult.MemoryUtilization -gt 85) {\n            $performanceIssues += \"High memory utilization: $($auditResult.MemoryUtilization)%\"\n            $recommendations += \"Consider memory upgrade or workload redistribution\"\n            $riskScore += 2\n        }\n        \n        # Low disk space\n        $lowDiskSpace = $auditResult.DiskInfo | Where-Object { $_.FreeSpacePercent -lt 15 }\n        if ($lowDiskSpace) {\n            $performanceIssues += \"Low disk space on drives: $($lowDiskSpace.Drive -join ', ')\"\n            $recommendations += \"Urgent: Free up disk space or expand storage\"\n            $riskScore += 3\n        }\n        \n        # Pending updates\n        if ($auditResult.PendingUpdates -gt 0) {\n            $securityIssues += \"$($auditResult.PendingUpdates) pending Windows updates\"\n            $recommendations += \"Install pending Windows updates during next maintenance window\"\n            $riskScore += 1\n        }\n        \n        # Excessive uptime\n        if ($auditResult.UptimeDays -gt 90) {\n            $securityIssues += \"Server uptime exceeds 90 days ($($auditResult.UptimeDays) days)\"\n            $recommendations += \"Schedule reboot during maintenance window to apply updates\"\n            $riskScore += 1\n        }\n        \n        # Service status issues\n        $stoppedServices = $auditResult.CriticalServices | Where-Object { $_.Status -ne 'Running' -and $_.StartType -eq 'Automatic' }\n        if ($stoppedServices) {\n            $securityIssues += \"Critical services not running: $($stoppedServices.Name -join ', ')\"\n            $recommendations += \"Investigate and start critical services\"\n            $riskScore += 3\n        }\n        \n        # Windows Defender status\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            $defender = $remoteData.SecurityChecks.DefenderStatus\n            if (-not $defender.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender or verify third-party antivirus is active\"\n                $riskScore += 3\n            }\n            if (-not $defender.RealTimeProtectionEnabled) {\n                $securityIssues += \"Real-time protection is disabled\"\n                $recommendations += \"Enable real-time protection immediately\"\n                $riskScore += 3\n            }\n        }\n        \n        # Firewall status\n        if ($remoteData.SecurityChecks.FirewallProfiles) {\n            $disabledProfiles = $remoteData.SecurityChecks.FirewallProfiles | Where-Object { -not $_.Enabled }\n            if ($disabledProfiles) {\n                $securityIssues += \"Windows Firewall disabled on profiles: $($disabledProfiles.Name -join ', ')\"\n                $recommendations += \"Enable Windows Firewall on all network profiles\"\n                $riskScore += 2\n            }\n        }\n        \n        # Excessive local administrators\n        $userAdmins = $auditResult.LocalAdministrators | Where-Object { $_.ObjectClass -eq 'User' }\n        if ($userAdmins.Count -gt 3) {\n            $securityIssues += \"Excessive local administrators: $($userAdmins.Count) user accounts\"\n            $recommendations += \"Review and reduce local administrator accounts\"\n            $riskScore += 2\n        }\n        \n        # SMBv1 security check\n        if ($remoteData.SecurityChecks.SMBv1Status) {\n            if ($remoteData.SecurityChecks.SMBv1Status.FeatureInstalled -eq $true) {\n                $securityIssues += \"SMBv1 protocol is enabled (security risk)\"\n                $recommendations += \"Disable SMBv1 protocol to prevent security vulnerabilities\"\n                $riskScore += 3\n            }\n            if ($remoteData.SecurityChecks.SMBv1Status.RegistryEnabled -eq $true) {\n                $securityIssues += \"SMBv1 enabled in registry settings\"\n                $recommendations += \"Disable SMBv1 in registry settings\"\n                $riskScore += 2\n            }\n        }\n        \n        # Network shares security review\n        if ($auditResult.NetworkShares -and $auditResult.NetworkShares.Count -gt 0) {\n            $publicShares = $auditResult.NetworkShares | Where-Object { $_.AccessRight -match \"Everyone\" }\n            if ($publicShares.Count -gt 0) {\n                $securityIssues += \"Network shares with 'Everyone' permissions found: $($publicShares.Count)\"\n                $recommendations += \"Review and restrict network share permissions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Antivirus status check\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            if (-not $remoteData.SecurityChecks.DefenderStatus.RealTimeProtectionEnabled) {\n                $securityIssues += \"Windows Defender real-time protection is disabled\"\n                $recommendations += \"Enable Windows Defender real-time protection\"\n                $riskScore += 3\n            }\n            if (-not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender antivirus protection\"\n                $riskScore += 3\n            }\n        }\n        \n        # Third-party antivirus check\n        if ($remoteData.SecurityChecks.AntivirusProducts) {\n            $enabledAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.State -eq 'Enabled' }\n            $outdatedAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.UpToDate -eq 'No' }\n            \n            if ($enabledAV.Count -eq 0 -and -not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"No active antivirus protection detected\"\n                $recommendations += \"Install and enable antivirus protection\"\n                $riskScore += 4\n            }\n            \n            if ($outdatedAV.Count -gt 0) {\n                $securityIssues += \"Outdated antivirus definitions detected\"\n                $recommendations += \"Update antivirus definitions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Scheduled tasks security review\n        if ($auditResult.ScheduledTasks -and $auditResult.ScheduledTasks.Count -gt 5) {\n            $securityIssues += \"Multiple custom scheduled tasks detected: $($auditResult.ScheduledTasks.Count)\"\n            $recommendations += \"Review scheduled tasks for unauthorized or suspicious activities\"\n            $riskScore += 1\n        }\n        \n        # BitLocker encryption check\n        if ($remoteData.SecurityChecks.BitLocker) {\n            $unencryptedVolumes = $remoteData.SecurityChecks.BitLocker | Where-Object { $_.VolumeStatus -ne 'FullyEncrypted' }\n            if ($unencryptedVolumes.Count -gt 0) {\n                $securityIssues += \"Unencrypted volumes detected: $($unencryptedVolumes.Count)\"\n                $recommendations += \"Enable BitLocker encryption on all system volumes\"\n                $riskScore += 2\n            }\n        } else {\n            $securityIssues += \"BitLocker status could not be determined\"\n            $recommendations += \"Verify BitLocker encryption status\"\n            $riskScore += 1\n        }\n        \n        # PowerShell remoting security\n        if ($remoteData.SecurityChecks.PSRemoting.ServiceStatus -eq 'Running' -and $remoteData.SecurityChecks.PSRemoting.HasListeners) {\n            $securityIssues += \"PowerShell remoting is enabled and listening\"\n            $recommendations += \"Review PowerShell remoting configuration and security settings\"\n            $riskScore += 1\n        }\n        \n        # Time synchronization check\n        if ($remoteData.SecurityChecks.TimeSync.W32TimeStatus -eq 'Not Configured') {\n            $securityIssues += \"Time synchronization not properly configured\"\n            $recommendations += \"Configure proper time synchronization with domain or NTP servers\"\n            $riskScore += 1\n        }\n        \n        $auditResult.SecurityIssues = $securityIssues\n        $auditResult.PerformanceIssues = $performanceIssues\n        $auditResult.Recommendations = $recommendations\n        $auditResult.RiskScore = $riskScore\n        $auditResult.ErrorMessages = $remoteData.Errors\n        \n        # Clean up session with error handling\n        try {\n            Remove-PSSession $session -ErrorAction Stop\n        } catch {\n            $auditResult.ErrorMessages += \"Session cleanup warning: $($_.Exception.Message)\"\n        }\n        \n    } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Execution Error'\n        $auditResult.ErrorMessages += \"Remote command execution failed: $($_.Exception.Message)\"\n    } catch [System.TimeoutException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Command Timeout'\n        $auditResult.ErrorMessages += \"Remote command timeout: $($_.Exception.Message)\"\n    } catch [System.UnauthorizedAccessException] {\n        $auditResult.ConnectionStatus = 'Failed - Access Denied'\n        $auditResult.ErrorMessages += \"Access denied during audit: $($_.Exception.Message)\"\n    } catch {\n        $auditResult.ConnectionStatus = 'Failed - Audit Error'\n        $auditResult.ErrorMessages += \"Unexpected audit error: $($_.Exception.Message)\"\n        \n        # Include inner exception details if available\n        if ($_.Exception.InnerException) {\n            $auditResult.ErrorMessages += \"Inner exception: $($_.Exception.InnerException.Message)\"\n        }\n    } finally {\n        # Ensure session cleanup in finally block\n        if ($session) {\n            try {\n                Remove-PSSession $session -ErrorAction SilentlyContinue\n            } catch {\n                # Silently handle cleanup errors in finally block\n            }\n        }\n    }\n    \n    return $auditResult\n}\n\n# ==============================================================================\n# REPORT GENERATION FUNCTIONS\n# ==============================================================================\n\nfunction New-ComprehensiveAuditReport {\n    Write-AuditLog 'Generating comprehensive audit reports...' -Level Header\n    \n    try {\n        # Calculate overall statistics\n        $summary = Get-AuditSummaryStatistics\n        \n        # Generate reports in requested formats\n        foreach ($format in $ExportFormats) {\n            switch ($format) {\n                'HTML' { New-HTMLReport -Summary $summary }\n                'Excel' { New-ExcelReport -Summary $summary }\n                'CSV' { New-CSVReport -Summary $summary }\n                'Markdown' { New-MarkdownReport -Summary $summary }\n                'PDF' { New-PDFReport -Summary $summary }\n            }\n        }\n        \n        # Generate executive summary\n        New-ExecutiveSummary -Summary $summary\n        \n        Write-AuditLog \"All reports generated successfully in: $script:OutputDir\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating reports: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Get-AuditSummaryStatistics {\n    $totalFindings = $script:AuditFindings.Count\n    $criticalFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }).Count\n    $highFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'High' }).Count\n    $mediumFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }).Count\n    $lowFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }).Count\n    $passedFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }).Count\n    $issuesFindings = $totalFindings - $passedFindings\n    \n    $totalServers = $script:ServerResults.Count\n    $onlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Online' }).Count\n    $offlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Offline' }).Count\n    $highRiskServers = ($script:ServerResults | Where-Object { $_.RiskScore -gt 5 }).Count\n    \n    $totalRiskScore = ($script:AuditFindings | Measure-Object -Property Score -Sum).Sum\n    $overallRisk = if ($criticalFindings -gt 0) { 'CRITICAL' }\n                  elseif ($highFindings -gt 3) { 'HIGH' }\n                  elseif ($highFindings -gt 0 -or $mediumFindings -gt 5) { 'MEDIUM' }\n                  else { 'LOW' }\n    \n    return [PSCustomObject]@{\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n        AuditDate = $script:StartTime\n        AuditDuration = (Get-Date) - $script:StartTime\n        TotalFindings = $totalFindings\n        IssuesFindings = $issuesFindings\n        PassedFindings = $passedFindings\n        CriticalFindings = $criticalFindings\n        HighFindings = $highFindings\n        MediumFindings = $mediumFindings\n        LowFindings = $lowFindings\n        TotalServers = $totalServers\n        OnlineServers = $onlineServers\n        OfflineServers = $offlineServers\n        HighRiskServers = $highRiskServers\n        TotalRiskScore = $totalRiskScore\n        OverallRisk = $overallRisk\n        ComplianceFrameworks = $script:ComplianceFrameworks\n    }\n}\n\nfunction New-HTMLReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating HTML report...' -Level Info\n    \n    $htmlPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.html'\n    \n    $riskColor = switch ($Summary.OverallRisk) {\n        'CRITICAL' { '#dc3545' }\n        'HIGH' { '#fd7e14' }\n        'MEDIUM' { '#ffc107' }\n        'LOW' { '#28a745' }\n    }\n    \n    $htmlContent = @\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Infrastructure Audit Report - $CustomerName</title>\n    <style>\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 10px; background: #f8f9fa; line-height: 1.4; }\n        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .header { margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; border-radius: 6px; display: flex; align-items: center; justify-content: space-between; }\n        .header-content { text-align: center; flex: 1; }\n        .header-info { text-align: right; width: 250px; }\n        .logo { max-height: 80px; max-width: 250px; }\n        .risk-banner { text-align: center; padding: 10px; margin: 10px 0; border-radius: 6px; color: white; font-size: 1.3em; font-weight: bold; background: $riskColor; }\n        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0; }\n        .metric-card { background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .metric-number { font-size: 2.0em; font-weight: bold; margin: 5px 0; }\n        .critical { color: #dc3545; }\n        .high { color: #fd7e14; }\n        .medium { color: #ffc107; color: #333; }\n        .low { color: #28a745; }\n        table { width: 100%; border-collapse: collapse; margin: 10px 0; }\n        th, td { padding: 8px; text-align: left; border: 1px solid #dee2e6; }\n        th { background: #495057; color: white; }\n        tr:nth-child(even) { background: #f8f9fa; }\n        .section { margin: 20px 0; }\n        .section h2 { color: #495057; border-bottom: 2px solid #dee2e6; padding-bottom: 6px; font-size: 1.6em; margin: 10px 0; }\n        \n        /* Detailed Findings Styling */\n        .findings-container { margin: 10px 0; }\n        .finding-group { margin: 15px 0; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 4px rgba(0,0,0,0.1); }\n        .finding-group-title { background: #495057; color: white; margin: 0; padding: 12px; font-size: 1.2em; font-weight: bold; }\n        .critical-section .finding-group-title { background: #dc3545; }\n        .high-section .finding-group-title { background: #fd7e14; }\n        .medium-section .finding-group-title { background: #ffc107; color: #333; }\n        .low-section .finding-group-title { background: #28a745; }\n        .passed-section .finding-group-title { background: #17a2b8; }\n        \n        .finding-item { background: white; border-bottom: 1px solid #dee2e6; padding: 15px; }\n        .finding-item:last-child { border-bottom: none; }\n        \n        /* Collapsible Findings */\n        .finding-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 8px; transition: background-color 0.3s; }\n        .finding-header:hover { background: #e9ecef; }\n        .finding-title { font-weight: bold; color: #495057; margin: 0; }\n        .finding-toggle { font-size: 1.2em; font-weight: bold; color: #6c757d; transition: transform 0.3s; }\n        .finding-content { display: none; padding: 12px; background: white; border-radius: 5px; border: 1px solid #dee2e6; }\n        .finding-content.show { display: block; }\n        .finding-toggle.open { transform: rotate(45deg); }\n        .finding-header { margin-bottom: 10px; }\n        .finding-header h4 { margin: 0 0 6px 0; font-size: 1.2em; color: #333; }\n        .finding-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }\n        .finding-id, .finding-category, .finding-type { \n            background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; color: #666; \n        }\n        .severity-badge { \n            padding: 6px 12px; border-radius: 20px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; \n        }\n        .severity-badge.critical { background: #dc3545; color: white; }\n        .severity-badge.high { background: #fd7e14; color: white; }\n        .severity-badge.medium { background: #ffc107; color: #333; }\n        .severity-badge.low { background: #28a745; color: white; }\n        \n        .finding-content { margin-top: 10px; }\n        .description-section, .impact-section, .recommendation-section, .evidence-section { \n            margin: 10px 0; padding: 10px; border-radius: 5px; \n        }\n        .description-section { background: #f8f9fa; border-left: 4px solid #007bff; }\n        .impact-section { background: #fff5f5; border-left: 4px solid #dc3545; }\n        .recommendation-section { background: #f0f9ff; border-left: 4px solid #10b981; }\n        .evidence-section { background: #fffbeb; border-left: 4px solid #f59e0b; }\n        \n        .finding-content h5 { \n            margin: 0 0 6px 0; font-size: 1.0em; color: #333; font-weight: 600; \n        }\n        .finding-content p { margin: 0; color: #555; }\n        .evidence-data { \n            background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 4px; \n            font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85em; margin: 6px 0 0 0;\n            white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; \n        }\n        .compliance-tag { \n            background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; \n            font-size: 0.9em; font-weight: 500; \n        }\n        .finding-footer { \n            margin-top: 20px; padding-top: 15px; border-top: 1px solid #e5e7eb; \n            font-size: 0.95em; color: #6b7280; \n        }\n        \n        /* Executive Summary Styling */\n        .executive-summary { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }\n        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; margin-bottom: 15px; }\n        .summary-card { background: white; padding: 12px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .summary-card h3 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .summary-card ul { margin: 0; padding-left: 15px; }\n        .summary-card li { margin: 4px 0; color: #555; }\n        .risk-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; }\n        .risk-level.critical { background: #dc3545; color: white; }\n        .risk-level.high { background: #fd7e14; color: white; }\n        .risk-level.medium { background: #ffc107; color: #333; }\n        .risk-level.low { background: #28a745; color: white; }\n        .key-findings { margin: 15px 0; }\n        .concern-list { margin: 10px 0; }\n        .concern-item { display: flex; align-items: flex-start; margin: 8px 0; padding: 10px; background: white; border-radius: 5px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }\n        .concern-icon { font-size: 1.1em; margin-right: 10px; flex-shrink: 0; }\n        .concern-content { flex: 1; color: #555; }\n        .concern-content strong { color: #333; }\n        .concern-content small { color: #777; }\n        .compliance-overview { margin: 25px 0; }\n        .compliance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }\n        .compliance-item { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .compliance-item h4 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .compliance-item p { margin: 0; color: #666; font-size: 0.95em; }\n        \n        .report-links { text-align: center; margin: 30px 0; }\n        .report-links a { display: inline-block; margin: 10px; padding: 12px 25px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold; }\n        .report-links a:hover { background: #0056b3; }\n        \n        /* Domain Controller Health Dashboard */\n        .dc-dashboard { margin: 25px 0; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }\n        .dc-dashboard-header { background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; padding: 15px; border-radius: 8px 8px 0 0; }\n        .dc-dashboard-header h2 { margin: 0; font-size: 1.5em; display: flex; align-items: center; }\n        .dc-dashboard-header .dc-count { background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 15px; margin-left: 15px; font-size: 0.9em; }\n        .dc-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; padding: 20px; }\n        .dc-card { border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }\n        .dc-card-header { padding: 12px 15px; font-weight: bold; color: white; display: flex; justify-content: space-between; align-items: center; }\n        .dc-card-header.healthy { background: #28a745; }\n        .dc-card-header.warning { background: #ffc107; color: #333; }\n        .dc-card-header.critical { background: #dc3545; }\n        .dc-card-body { padding: 15px; background: #f8f9fa; }\n        .dc-info-row { display: flex; justify-content: space-between; margin: 5px 0; }\n        .dc-info-label { font-weight: 600; color: #495057; }\n        .dc-info-value { color: #28a745; }\n        .dc-info-value.warning { color: #856404; }\n        .dc-info-value.failed { color: #dc3545; }\n        .dc-services { margin-top: 10px; }\n        .dc-service { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-service.running { background: #d4edda; color: #155724; }\n        .dc-service.stopped { background: #f8d7da; color: #721c24; }\n        .dc-tests { margin-top: 10px; }\n        .dc-test { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-test.passed { background: #d4edda; color: #155724; }\n        .dc-test.failed { background: #f8d7da; color: #721c24; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <div class=\"logo-container\">\n                <img src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iOTAwLjAwMDAwMHB0IiBoZWlnaHQ9IjE3NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDkwMC4wMDAwMDAgMTc0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjEwLCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxMQo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwxNzQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTgwNiAxNTA4IGMtMTMgLTQ0IC0yNiAtMTI1IC0yNiAtMTU2IDAgLTIwIC03IC02MiAtMTUgLTkyIC04IC0zMAotMTUgLTc2IC0xNSAtMTAxIDAgLTI2IC03IC02MyAtMTUgLTgyIC04IC0yMCAtMTUgLTU2IC0xNSAtNzkgMCAtMjQgLTcgLTY1Ci0xNSAtOTIgLTggLTI3IC0xNSAtNjIgLTE1IC03OCAwIC0yOCAxIC0yOCA2MCAtMjggbDU5IDAgNiAzOCBjMyAyMCAxMCA1NiAxNgo3OSA1IDIzIDkgNjEgOSA4NSAxIDg4IDY1IDE1NSAxMjggMTMyIDI3IC0xMCAyNyAtMTEgMjQgLTg5IC0xIC00NCAtOSAtMTAwCi0xNyAtMTI1IC04IC0yNSAtMTUgLTYxIC0xNyAtODAgbC0zIC0zNSA2MyAtMyA2MiAtMyAwIDM3IGMwIDIwIDcgNjIgMTUgOTQgOAozMiAxNiAxMDEgMTggMTU0IDIgODcgMCA5NyAtMjEgMTE4IC0xOSAxOSAtMzMgMjMgLTg1IDIzIC00MyAwIC03MSAtNiAtOTAKLTE3IC0xNCAtMTAgLTMxIC0xOCAtMzcgLTE4IC0xNSAwIC0xMiA0MiA1IDgzIDggMjAgMTUgNTIgMTUgNzAgMCAxOSA3IDU0IDE1Cjc3IDggMjMgMTUgNTUgMTUgNzEgMCAyOSAtMSAyOSAtNjAgMjkgLTQwIDAgLTYyIC00IC02NCAtMTJ6Ii8+CjxwYXRoIGQ9Ik03MTgwIDE0NTMgYy02IC0zNyAtMTYgLTk5IC0yMCAtMTM4IC00IC0zOCAtMTMgLTg2IC0xOSAtMTA1IC02IC0xOQotMTEgLTU3IC0xMSAtODUgMCAtNDYgLTE1IC0xMzAgLTQxIC0yMzAgLTYgLTIyIC0xMyAtNTMgLTE2IC02OCBsLTUgLTI4IDYzIDMKNjQgMyA4IDQ1IGM0IDI1IDEyIDgxIDE3IDEyNSA5IDgxIDIzIDE1OCA0MSAyMzAgNiAyMiAxNCA2OSAxOSAxMDUgNCAzNiAxMgo3NyAxOCA5MSA2IDE0IDEyIDQ2IDE0IDcwIGwzIDQ0IC02MSAzIC02MSAzIC0xMyAtNjh6Ii8+CjxwYXRoIGQ9Ik0zMjg5IDE0NjcgYy0xNCAtMTIgLTMxIC0zNiAtMzggLTU0IC0xMiAtMjggLTExIC0zNyA2IC02NSAyOCAtNDgKNzQgLTUxIDExOSAtNyAyNyAyNiAzNCA0MSAzNCA3MiAwIDY5IC02OCAxMDAgLTEyMSA1NHoiLz4KPHBhdGggZD0iTTI4NjggMTQzMiBjLTE3IC0zIC0yOCAtNTEgLTI4IC0xMjcgMCAtMjcgLTcgLTcyIC0xNSAtOTkgLTggLTI3Ci0xNSAtNjggLTE1IC05MCAwIC0yMyAtNyAtNjYgLTE1IC05NiAtOCAtMzAgLTE1IC03MyAtMTUgLTk1IDAgLTIyIC03IC01MQotMTUgLTY1IC0zMSAtNTQgLTI0IC02MCA3NSAtNjAgbDkwIDAgMCA0NSBjMCAyNCA0IDY2IDkgOTIgNSAyNiAxMiA2NCAxNiA4NApsNSAzNiA4NyAtMSA4NyAtMSA3IDM1IGM0IDE5IDEwIDUwIDE0IDY4IGw4IDMzIC04NiAtMiBjLTQ4IC0yIC04OSAwIC05MiAzCi0xMSAxMCA3IDEwNyAyMCAxMTIgOCAzIDUxIDEgOTcgLTQgNDYgLTQgODYgLTUgOTAgLTIgMyA0IDggMjcgMTAgNTIgMyAyNSA2CjUyIDkgNjAgMyAxMyAtMjEgMTYgLTE2MiAyMCAtOTIgMyAtMTczIDQgLTE4MSAyeiIvPgo8cGF0aCBkPSJNNDYyNCAxNDI3IGMtOSAtNSAtMTQgLTI0IC0xNCAtNTMgbDAgLTQ1IDY4IDMgYzY2IDMgNjcgMyA2NSAtMjIgLTYKLTY3IC0yMiAtMTU4IC0zMiAtMTgzIC02IC0xNiAtMTEgLTQ3IC0xMSAtNjkgMCAtMjMgLTYgLTY0IC0xNCAtOTIgLTE5IC02NwotMzQgLTE1NSAtMjggLTE2MSAzIC0zIDM0IC01IDY5IC01IGw2MyAwIDAgMzggYzEgMjAgNyA2NCAxNSA5NyA4IDMzIDE1IDc5CjE1IDEwMSAwIDIzIDcgNTggMTUgNzcgOCAyMCAxNSA1NSAxNSA3OCAwIDIyIDcgNjYgMTYgOTYgbDE2IDU1IDU3IC02IGM3NyAtOQoxMDAgMTMgOTIgODkgLTEgMTIgLTM4NSAxNCAtNDA3IDJ6Ii8+CjxwYXRoIGQ9Ik0yNjE0IDEzNjcgYy03MyAtNzUgLTExOCAtMTE0IC0xNjEgLTE0MCAtMTggLTEwIC0zMyAtMjMgLTMzIC0yOCAwCi01IC01IC05IC0xMSAtOSAtNiAwIC0zNyAtMjAgLTY5IC00NSAtMzIgLTI1IC02MSAtNDUgLTY0IC00NSAtNCAwIC0yNSAtMTQKLTQ4IC0zMCAtNDcgLTM0IC03MiAtODIgLTgyIC0xNTcgLTYgLTUxIC02IC01MyAxNyAtNTMgMTQgMCAzMCA3IDM3IDE1IDcgOAoyNCAxNSAzOSAxNSAxNCAxIDM3IDcgNTEgMTUgMTQgOCA0MiAxNCA2MiAxNSAyMCAwIDY3IDcgMTA1IDE2IDM3IDkgODIgMTMgOTkKMTEgMTcgLTMgMzUgLTIgNDEgMSAxMiA5IDIzIDQ5IDMzIDEyNyAxMSA4NiAyOSAxNzAgNTIgMjQ3IDM2IDExOSAxOCAxMzEgLTY4CjQ1eiBtLTE0MiAtMzE5IGMtMTUgLTE1IC0yNiAtNCAtMTggMTggNSAxMyA5IDE1IDE4IDYgOSAtOSA5IC0xNSAwIC0yNHoiLz4KPHBhdGggZD0iTTQxNTYgMTMxMCBjLTcgLTU4IC0xMSAtNjYgLTQ4IC05MyAtOSAtNyAtMjAgLTMzIC0yMyAtNTkgLTcgLTQzIC02Ci00NyAxNiAtNTAgMjcgLTMgMjcgLTYgNiAtMTM4IC04IC00NyAtMTkgLTk4IC0yNiAtMTEzIC0yMiAtNTUgLTE4IC01OCA2NgotNTUgbDc4IDMgNyA0MCBjNSAyMiAxMiA4NCAxOCAxMzkgNSA1NCAxNSAxMDUgMjEgMTEyIDggOSAyMyAxMiA0MyA5IDE3IC0zCjM2IC0yIDQzIDMgMTMgOCAyMSAxMDggOSAxMTkgLTQgNCAtMjMgNiAtNDMgNCAtMzUgLTMgLTM2IC0zIC0yOSAzMSA0IDE4IDEwCjUwIDEzIDcxIGw1IDM3IC03NSAwIC03NCAwIC03IC02MHoiLz4KPHBhdGggZD0iTTM2NjYgMTIzMyBjLTIxIC05IC01MCAtMjcgLTY0IC00MCAtMzMgLTMxIC00MiAtMjkgLTQyIDcgbDAgMzEgLTY3Ci0zIC02OCAtMyAtMTIgLTEwMCBjLTExIC04NyAtMjYgLTE3OSAtNDkgLTI5MiBsLTYgLTMzIDc1IDAgYzg3IDAgODMgLTUgOTQKMTI1IDEwIDEyNyA0NSAxNzcgMTI2IDE4MSAyOSAxIDU1IDMgNTggMyAxMCAyIDMyIDEwOCAyNiAxMjUgLTggMjAgLTIxIDE5Ci03MSAtMXoiLz4KPHBhdGggZD0iTTM4NjQgMTIzNSBjLTEwIC04IC0yNiAtMTUgLTM1IC0xNSAtOSAwIC0yNSAtMTIgLTM1IC0yNyAtMTAgLTE0Ci0yOCAtMzYgLTM5IC00NyAtMTcgLTE3IC0yMCAtMzEgLTE3IC03MyAzIC00NyA4IC01NSAzNyAtNzMgMTggLTExIDQ4IC0yMCA2NwotMjAgNTYgMCA3NyAtNDAgNDAgLTczIC0yNSAtMjMgLTQyIC0yMSAtMTAzIDkgLTUxIDI2IC01MyAyNiAtNjUgOCAtMTkgLTI3Ci0yNiAtMzcgLTQ3IC02MSAtMTggLTIwIC0xNyAtMjEgMTkgLTQ0IDMyIC0yMCA1MSAtMjMgMTMzIC0yMyA4MiAwIDEwMSA0IDEzMwoyMyA2MyAzOCA4OCA4MSA4OCAxNTAgMCA1NyAtMiA2MCAtMzQgODAgLTE4IDEyIC00OSAyMSAtNjggMjEgLTM4IDAgLTU4IDE1Ci01OCA0MiAwIDMxIDQzIDQzIDkyIDI3IDM4IC0xMiA0MiAtMTIgNTIgNiA2IDEwIDIyIDI5IDM0IDQxIGwyNCAyMyAtMzQgMjEKYy00MSAyNSAtMTUzIDI4IC0xODQgNXoiLz4KPHBhdGggZD0iTTMyMjYgMTIxMyBjLTMgLTEwIC0xMCAtNTYgLTE2IC0xMDMgLTYgLTQ3IC0xNiAtMTAwIC0yMSAtMTE4IC05Ci0yOCAtMjEgLTk1IC0zMSAtMTY3IC0zIC0xOCA0IC0yMCA2NiAtMjMgMzggLTIgNzMgMSA3OCA2IDUgNSAxMyA1MSAxOCAxMDMgOAo4MiAyMiAxNjcgNDYgMjg3IGw2IDMyIC03MCAwIGMtNTkgMCAtNzIgLTMgLTc2IC0xN3oiLz4KPHBhdGggZD0iTTUwNjAgMTIyMyBjLTE0IC0yIC0zMiAtMTAgLTQwIC0xNyAtOCAtNyAtMjMgLTE2IC0zMiAtMTkgLTIwIC03Ci03OCAtODQgLTc4IC0xMDIgMCAtNyAtNyAtMjYgLTE1IC00MSAtMzcgLTcxIC01IC0xODQgNjEgLTIyMyA1NCAtMzIgMTgwIC0zMAoyMzMgNCA2NCA0MCA5NCA3NCA4MCA5MSAtMTkgMjMgLTk1IDE4IC0xMTggLTggLTI5IC0zMCAtMTAyIC0zMSAtMTMwIC0xIC0yNQoyNiAtMjggODEgLTUgOTAgOCAzIDc1IDYgMTQ3IDcgbDEzMiAxIDMgNjAgYzQgNjcgLTEyIDEwOCAtNTQgMTM4IC0yNSAxOQotMTM0IDMxIC0xODQgMjB6IG0xMTkgLTEwMCBjMjAgLTI0IDI3IC00MSAyMSAtNDcgLTUgLTUgLTQ2IC0xMSAtOTAgLTEyIC03MgotMiAtODAgLTEgLTgwIDE2IDAgMjQgNjggODAgOTcgODAgMTMgMCAzNCAtMTUgNTIgLTM3eiIvPgo8cGF0aCBkPSJNNTUyMyAxMjIzIGMtMTcgLTIgLTM3IC0xMSAtNDMgLTE5IC03IC04IC0xOCAtMTQgLTI1IC0xNCAtMTUgMCAtOTUKLTg5IC05NSAtMTA2IDAgLTcgLTcgLTI1IC0xNSAtNDAgLTM2IC02OSAtMTAgLTE2NSA2MCAtMjE4IDMwIC0yMyA0MyAtMjYgMTE5Ci0yNiA5NCAwIDk1IDEgMTEyIDY4IDkgMzYgOSA0NSAtMyA0OSAtNyAzIC0yMiAtMiAtMzIgLTExIC0zMCAtMjcgLTg4IC0yMQotMTIyIDEzIC0zNyAzOCAtMzkgODYgLTQgMTQxIDM1IDU2IDY1IDczIDExNyA2NyAxMDIgLTEzIDkzIC0xNyA5NiAzMiAyIDI0Ci0xIDQ4IC02IDUzIC0xMSAxMSAtMTEyIDE4IC0xNTkgMTF6Ii8+CjxwYXRoIGQ9Ik02Mzk1IDEyMjMgYy0xMSAtMyAtMjggLTEyIC0zOCAtMjEgLTE3IC0xNiAtMjAgLTE1IC0zMiAxIC05IDEzIC0yNwoxNyAtNjkgMTcgbC01NiAwIDAgLTQ1IGMwIC0yNCAtNyAtNzAgLTE1IC0xMDIgLTggLTMxIC0xNSAtNzQgLTE1IC05NCAwIC0yMAotNyAtNTMgLTE1IC03MiAtOCAtMjAgLTE1IC01MiAtMTUgLTcyIGwwIC0zNSA1OCAwIDU4IDAgMTMgNzMgYzcgMzkgMTYgOTcgMTkKMTI3IDExIDkyIDUwIDE0MCAxMTIgMTQwIDM5IDAgNTEgLTI3IDQ0IC05OCAtMyAtMzcgLTEyIC04NyAtMTkgLTExMiAtOCAtMjUKLTE2IC02MyAtMTcgLTg1IGwtMyAtNDAgNjMgLTMgNjIgLTMgMCAzOCBjMCAyMSA3IDcxIDE2IDExMiA4IDQxIDE2IDExMCAxNwoxNTIgMiA2OCAtMSA4MSAtMTkgOTkgLTIxIDIyIC0xMDcgMzUgLTE0OSAyM3oiLz4KPHBhdGggZD0iTTY3OTggMTIyMyBjLTIwIC0yIC00MiAtMTEgLTQ4IC0xOSAtNyAtOCAtMTggLTE0IC0yNCAtMTQgLTE0IDAgLTY1Ci01NCAtODUgLTkwIC0yNSAtNDMgLTM3IC0xMzEgLTI2IC0xODAgMTMgLTU3IDE4IC02NiA2NiAtOTUgMzMgLTIxIDUxIC0yNQoxMTggLTI1IDk2IDAgMTQ0IDIxIDE5OCA4NiA2NCA3NiA4NSAxNjkgNTQgMjM2IC0zMCA2NyAtNzcgOTggLTE1MyAxMDIgLTM1IDIKLTgwIDIgLTEwMCAtMXogbTEyNiAtMTI3IGMzMSAtNDIgMzMgLTczIDUgLTEyMCAtNDQgLTc0IC0xMTkgLTEwNiAtMTY1IC02OAotNTUgNDcgLTQ5IDEzMCAxNiAxODkgMjggMjYgNDQgMzMgNzYgMzMgMzYgMCA0NSAtNSA2OCAtMzR6Ii8+CjxwYXRoIGQ9Ik03NDYzIDEyMjMgYy0xNyAtMiAtMzcgLTExIC00MyAtMTkgLTcgLTggLTE4IC0xNCAtMjQgLTE0IC0xOCAwIC04MAotNzAgLTk5IC0xMTMgLTI2IC01OCAtMjMgLTE2OSA1IC0yMDggNDAgLTU0IDc2IC02OSAxNjUgLTY5IDE1NiAwIDI0NyA4NiAyNjAKMjQ2IDYgNzIgLTExIDExMSAtNjYgMTUyIC0zMSAyMyAtMTI5IDM1IC0xOTggMjV6IG0xMjUgLTExNyBjMTcgLTE4IDIyIC0zNgoyMiAtNzQgMCAtNDcgLTQgLTU0IC00NiAtOTYgLTUzIC01MyAtODcgLTU5IC0xMzQgLTI0IC0yOCAyMCAtMzAgMjcgLTMwIDg0IDAKNjEgMSA2MyA0MyA5OCA1MyA0NSAxMDkgNDkgMTQ1IDEyeiIvPgo8cGF0aCBkPSJNNzk0MSAxMjIzIGMtOTMgLTE5IC0xNTkgLTExNiAtMTc2IC0yNTMgLTYgLTQ3IC0zIC02MiAxNSAtOTMgMzEKLTUyIDc2IC03NyAxNDAgLTc3IDM3IDAgNTkgNiA3NyAyMCAzNSAyNyA2MyAyNiA2MyAtMiAwIC0xMyAtNyAtMzIgLTE1IC00MgotOCAtMTEgLTE1IC0yOCAtMTUgLTM3IDAgLTIzIC02MCAtNTkgLTk4IC01OSAtMjMgMCAtMzggOSAtNjQgMzkgLTI4IDMzIC00MQo0MCAtODEgNDQgLTM5IDQgLTQ5IDEgLTU4IC0xNCAtMjEgLTQxIDE5IC0xMDIgOTEgLTEzOSA1MyAtMjcgMTU2IC0yNyAyMDkgMAo0NiAyMyAxMjEgMTA3IDEyMSAxMzUgMSAxMSA3IDMxIDE1IDQ1IDggMTQgMTQgNDYgMTUgNzEgMCAyNSA3IDY4IDE1IDk1IDggMjcKMTUgNzAgMTUgOTUgMCAyNiA3IDY2IDE1IDg5IDI2IDc0IDIzIDgwIC00MCA4MCAtNDAgMCAtNTcgLTQgLTYxIC0xNSAtOCAtMTkKLTIzIC0xOSAtNDQgMCAtMTggMTYgLTk4IDI3IC0xMzkgMTh6IG0xMjkgLTExNCBjMjIgLTE5IDI1IC0yOSAyNSAtODIgLTEgLTU4Ci0yIC02MSAtNDUgLTk4IC01NyAtNDkgLTkyIC01MSAtMTM3IC03IC0yNCAyMyAtMzMgNDEgLTMzIDY1IDAgMzggMzYgMTAxIDcxCjEyNiAzNCAyMyA4OSAyMSAxMTkgLTR6Ii8+CjxwYXRoIGQ9Ik04NjgwIDEyMjMgYy00MyAtNCAtODAgLTI1IC04MCAtNDYgMCAtNSAtMTMgLTI4IC0yOCAtNTEgLTE1IC0yMgotMzcgLTYwIC00OCAtODQgLTE2IC0zNSAtMjMgLTQyIC00NCAtNDAgLTIyIDMgLTI2IDkgLTMxIDU4IC0zIDMxIC0xMSA2NSAtMTcKNzcgLTcgMTIgLTEyIDM1IC0xMiA1MiBsMCAzMSAtNzUgMCBjLTQxIDAgLTc1IC00IC03NSAtOSAwIC01IDYgLTIyIDE0IC0zOAozMSAtNjUgNjUgLTE1MiA3MyAtMTkzIDMgLTE0IDEyIC0zMyAyMCAtNDIgMzIgLTM3IDIxIC03OSAtNDUgLTE2NSAtMzQgLTQ1Ci02MiAtODUgLTYyIC04OSAwIC01IC0xNCAtMjMgLTMxIC00MCAtNDAgLTQxIC0zNCAtNzAgMTIgLTYwIDE4IDMgNDYgNiA2MyA2CjI5IDAgMzkgMTIgMTY2IDIwMSA3NCAxMTAgMTQxIDIxMSAxNDggMjI1IDcgMTMgMTcgMjQgMjMgMjQgNSAwIDkgNiA5IDEzIDAgNgoyNSA0MiA1NSA4MCAzMCAzNyA1NSA3MSA1NSA3NiAwIDkgLTI2IDIyIC0zOCAxOSAtNCAtMSAtMjcgLTMgLTUyIC01eiIvPgo8cGF0aCBkPSJNMjAxOSA5NDMgYy0zMSAtMjMgLTU5IC00MCAtODQgLTUzIC0xMSAtNiAtMzMgLTE5IC01MCAtMzAgLTE2IC0xMQotMzcgLTIyIC00NSAtMjYgLTggLTMgLTIyIC05IC0zMCAtMTQgLTggLTUgLTc2IC0zOSAtMTUwIC03NSAtNzQgLTM3IC0xNDcKLTczIC0xNjIgLTgxIC0xNCAtOCAtMzMgLTE0IC00MSAtMTQgLTggMCAtMjAgLTcgLTI3IC0xNSAtNyAtOCAtMjMgLTE1IC0zNQotMTUgLTEyIDAgLTI4IC03IC0zNSAtMTUgLTcgLTggLTIwIC0xNSAtMjkgLTE1IC0xMCAwIC0yNiAtNyAtMzcgLTE1IC0xMCAtOAotMjcgLTE1IC0zNiAtMTUgLTkgMCAtMzAgLTcgLTQ3IC0xNSAtMTcgLTggLTQ1IC0yMiAtNjIgLTMwIC0xNyAtOCAtMzggLTE1Ci00OCAtMTUgLTkgMCAtMjYgLTcgLTM3IC0xNSAtMTAgLTggLTI3IC0xNSAtMzcgLTE1IC0xMSAwIC0zMSAtNiAtNDUgLTE0IC0zMAotMTUgLTgxIC0zMyAtMTI3IC00NiAtMzkgLTExIC05MSAtMjkgLTEzMyAtNDYgLTE4IC04IC00MyAtMTQgLTU1IC0xNCAtMTIgLTEKLTMzIC03IC00NyAtMTUgLTE0IC04IC0zOCAtMTQgLTUzIC0xNSAtMTYgMCAtMzggLTUgLTUwIC0xMiAtMjEgLTExIC0zOCAtMTUKLTE2MiAtMzggLTMzIC02IC02OSAtMTUgLTgwIC0yMCAtMTEgLTUgLTMzIC0xNCAtNDkgLTIwIC0yMSAtOCAtMjYgLTE0IC0xOQotMjEgOCAtOCA3MyAtOCAyMjUgMSAxOTYgMTEgMTE2MiAxMCAxMjEzIC0xIDI0IC01IDMzIDI2IDEyIDQ5IC01OSA2OSAtMzUKMjM3IDQ4IDMzMCAzMCAzNSAxMjcgMTEzIDE1NSAxMjUgNzggMzYgMTc3IDk4IDE4NyAxMTggNiAxMyAxNCA0OCAxOCA3NyA4IDU4Ci0zIDY2IC00NiAzNXogbS00ODkgLTQwNSBjMzIgLTI0IDQyIC03MSAxNiAtODEgLTE5IC03IC0zMSAtNjYgLTE3IC04MCAxOAotMTggMTMgLTMwIC0xMCAtMjQgLTE1IDQgLTMwIC0zIC01MSAtMjYgLTI2IC0yOCAtMzEgLTMwIC00MSAtMTYgLTEwIDEzIC0zNwoxNSAtMTY0IDE1IC0xNzQgLTEgLTE5OSA3IC0xNDggNDkgMzcgMzAgMTU5IDkwIDIwMiAxMDAgMTggMyA0OCAxNyA2OCAzMSAyMAoxMyA0NCAyNCA1NCAyNCA5IDAgMjYgNyAzNyAxNSAyNCAxOCAyMCAxOSA1NCAtN3oiLz4KPHBhdGggZD0iTTI0NTUgNjYwIGMtMTYgLTQgLTUxIC04IC03NiAtOSAtMjYgMCAtNjMgLTggLTgyIC0xNiAtMjAgLTggLTUwCi0xNSAtNjYgLTE1IC0xNiAwIC0zOSAtOSAtNTIgLTE5IC0yMSAtMTcgLTIyIC0yMiAtMTEgLTQwIDYgLTExIDEyIC0yOSAxMgotNDAgMCAtMTAgNyAtMjQgMTUgLTMxIDggLTcgMTUgLTIwIDE1IC0zMCAwIC0xMCA3IC0yMyAxNSAtMzAgOCAtNyAxNSAtMTcgMTUKLTIyIDAgLTE1IDg1IC0xMjIgMTI1IC0xNTcgMzAgLTI2IDQ0IC0zMSA3MyAtMjkgMzcgMyAzNyAzIDQ0IDU4IDQgMzAgMTEgNjgKMTcgODMgNiAxNiAxMSA0NSAxMSA2NiAwIDIxIDYgNTYgMTQgNzcgNyAyMiAxNyA2NyAyMSAxMDIgbDcgNjIgLTM0IC0xIGMtMTgKLTEgLTQ2IC01IC02MyAtOXogbS02MiAtMTUzIGMzIC03IDMgLTI1IDAgLTQwIC04IC00MCAtNDAgLTM2IC01MSA2IC01IDE3IC03CjM1IC01IDQwIDcgMTIgNTEgOCA1NiAtNnoiLz4KPHBhdGggZD0iTTI3MDcgNTU3IGMtMTUgLTEwIC0xNiAtMTUgLTUgLTMwIDEyIC0xNiA1OCAtMTcgNzUyIC0xNyA1MzkgMCA3NDIKMyA3NTIgMTEgMTkgMTUgMTggMzUgLTIgNDMgLTkgMyAtMzQ1IDYgLTc0OCA2IC01NzQgMCAtNzM2IC0zIC03NDkgLTEzeiIvPgo8cGF0aCBkPSJNMTk5MCA1MTUgYy03IC04IC0xOSAtMTUgLTI3IC0xNSAtNyAwIC0xNiAtNyAtMTkgLTE1IC00IC04IC0xMCAtMTUKLTE1IC0xNSAtNSAwIC0zMSAtMjMgLTU4IC01MSAtNDAgLTQyIC01MCAtNTkgLTU1IC05OSAtNCAtMjYgLTIgLTU5IDMgLTczCmwxMCAtMjYgOTggNSBjNTQgMyAxMzEgMiAxNzEgLTMgODggLTExIDkxIC00IDMyIDczIC0yMiAyOSAtNDAgNTkgLTQwIDY3IDAgNwotNyAyMiAtMTUgMzMgLTggMTAgLTE1IDM1IC0xNSA1NCAtMSA1OCAtMTAgODAgLTM1IDgwIC0xMiAwIC0yOCAtNyAtMzUgLTE1eiIvPgo8cGF0aCBkPSJNNjAzMSA0OTggYy01IC0xOCAtMTEgLTczIC0xMyAtMTIzIGwtMyAtOTAgMjUgMCBjMjMgMCAyNiA1IDMyIDU1IDQKMzAgMTIgODIgMTggMTE0IDExIDY3IDggNzYgLTI1IDc2IC0xOCAwIC0yNiAtOCAtMzQgLTMyeiIvPgo8cGF0aCBkPSJNNzI2MyA1MTggYy02IC03IC0xMyAtNjQgLTE2IC0xMjUgbC03IC0xMTMgMjUgMCBjMjkgMCAzMiAxMSA0NSAxMjEKMTQgMTI0IDE0IDEyOSAtMTQgMTI5IC0xMyAwIC0yOCAtNiAtMzMgLTEyeiIvPgo8cGF0aCBkPSJNNDk1NSA1MDIgYy02IC00IC0xNiAtNDEgLTIzIC04MiAtNiAtNDEgLTE1IC05MCAtMTggLTEwNyAtNiAtMzIgLTUKLTMzIDI1IC0zMyAxNyAwIDMyIDUgMzIgMTMgMSA2IDMgMTkgNCAyNyAxIDggMyAyMSA0IDI5IDIgMTkgNDAgLTE1IDUyIC00NiA2Ci0xNyAxNyAtMjMgMzkgLTIzIDM5IDAgMzkgMjAgLTEgNzAgLTM1IDQ0IC0zNSA0NiAyNCAxMDMgMzEgMzAgMzAgNTcgLTIgNTcKLTIxIDAgLTQ1IC0yMCAtNjEgLTUxIC0xNiAtMjggLTMwIC0yMyAtMzAgMTAgMCAxNyAtNiAzMSAtMTYgMzUgLTE5IDcgLTE3IDcKLTI5IC0yeiIvPgo8cGF0aCBkPSJNNTYzMSA1MDIgYy0xNiAtNSAtMTQgLTM3IDMgLTUxIDcgLTYgMjEgLTkgMzAgLTUgMzYgMTQgMjcgLTI2IC0xOQotODYgLTI1IC0zMyAtNDMgLTY1IC00MCAtNzAgMyAtNiA0NCAtMTAgOTEgLTEwIDgzIDAgODUgMSA4MiAyMyAtMiAxOCAtMTAgMjMKLTQwIDI1IC0yMSAyIC0zOCA0IC0zOCA2IDAgMTQgMzcgNzAgNjkgMTA2IDI0IDI3IDM2IDQ5IDMxIDU0IC05IDkgLTE0OCAxNQotMTY5IDh6Ii8+CjxwYXRoIGQ9Ik02NDcyIDQ5OCBjLTcgLTcgLTEyIC0yNiAtMTIgLTQyIC0xIC0xNyAtNyAtNTggLTE0IC05MSAtMTUgLTc0IC0xMgotODUgMjQgLTg1IDI5IDAgMjkgMSAzMiA2MyAyIDM0IDcgNjEgMTMgNjEgOCAtMSA0NyAtNjMgNzEgLTExMSA5IC0xOSA2MSAtMTYKNjggMyAzIDkgNiAyOSA2IDQ0IDAgMTYgNyA1NSAxNSA4NyAxMyA0OSAxMyA1OSAxIDcxIC04IDkgLTIyIDExIC0zNSA3IC0xOAotNSAtMjEgLTE0IC0yMSAtNjUgMCAtMzIgLTQgLTYxIC04IC02NCAtMTAgLTYgLTQ2IDQwIC01NiA3MCAtOCAyNiAtNDMgNjQKLTU5IDY0IC03IDAgLTE4IC01IC0yNSAtMTJ6Ii8+CjxwYXRoIGQ9Ik03NDU0IDQ5MyBjLTMgLTEwIC0xMyAtMzEgLTIxIC00OCAtMTAgLTIyIC0xMyAtNTYgLTExIC0xMjUgMyAtODcgNQotOTUgMjMgLTk1IDE5IDAgMjAgNyAyMCAxMDAgMCA4MCA0IDEwNSAxOSAxMjcgMTAgMTYgMTYgMzUgMTIgNDMgLTcgMjEgLTM1CjE5IC00MiAtMnoiLz4KPHBhdGggZD0iTTc5OTYgNTAxIGMtMyAtNSAxIC0yNSA5IC00NSAxNyAtNDAgMjAgLTkyIDYgLTEwMCAtNSAtNCAtMTIgLTI0Ci0xNiAtNDUgLTQgLTIyIC0xMyAtNDIgLTIxIC00NSAtMTkgLTcgLTE4IC0zNSAyIC00MyAyMiAtOCA2NCAzNSA2NCA2NyAwIDE0CjUgMzEgMTEgMzcgMTcgMTcgMTMgMTI4IC03IDE1OCAtMTYgMjUgLTM4IDMzIC00OCAxNnoiLz4KPHBhdGggZD0iTTc1MzkgNDczIGMtMTkgLTUwIC0zMSAtMTczIC0xOCAtMTg5IDE2IC0yMCAzOSAwIDM5IDM1IDAgMjEgOCAzMAo0MCA0NCA0NSAxOSA2MiA1MCA0OCA4NiAtMTIgMzIgLTM3IDUwIC03MSA1MSAtMjEgMCAtMzAgLTcgLTM4IC0yN3ogbTYzIC02NQpjLTIwIC0yMCAtMzYgNSAtMjEgMzMgbDEyIDI0IDEwIC0yMyBjNyAtMTYgNyAtMjYgLTEgLTM0eiIvPgo8cGF0aCBkPSJNNzY3NSA0OTAgYy04IC0xMyAzIC0zMCAyMCAtMzAgMTggMCAyOCAtMzUgMTcgLTU3IC0xNSAtMjggLTIzIC0xMDcKLTEzIC0xMjIgMjQgLTM3IDYxIDM4IDYxIDEyMyAwIDQ2IDMzIDgwIDYxIDYzIDEwIC02IDIxIC0yNCAyNCAtMzkgNCAtMTUgMTEKLTMwIDE2IC0zMyAxMyAtOCAxMSAtNTkgLTIgLTcyIC0xOCAtMTggLTIgLTQzIDI2IC00MyAyMiAwIDI1IDQgMjUgMzggMCAzNAozMSAxMTAgNTEgMTIyIDUgMyAxMCAxNyAxMSAzMCA1IDQxIC0yNSAzNCAtNTEgLTEyIGwtMjQgLTQzIC0xMSAyNiBjLTIxIDUxCi0zMSA1NiAtMTIwIDU4IC00OSAxIC04NyAtMyAtOTEgLTl6Ii8+CjxwYXRoIGQ9Ik04MTk2IDQ2OCBjLTggLTE4IC0xNyAtNjUgLTIxIC0xMDQgLTggLTgxIDIgLTk3IDU3IC05MiAyNSAyIDM0IDgKMzYgMjUgMiAxNiAtMyAyMiAtMjAgMjUgLTE4IDIgLTIyIDggLTIwIDI4IDE1IDEyOCAxNCAxNTAgLTIgMTUwIC0xMCAwIC0yMwotMTQgLTMwIC0zMnoiLz4KPHBhdGggZD0iTTgyOTAgNDg1IGMwIC05IDcgLTE4IDE1IC0yMSAxOCAtNyAyMSAtMTA0IDUgLTEzNCAtMTQgLTI2IC0yIC01MgoyNCAtNDggMTkgMyAyMiAxMiAzMCA4NiA3IDc1IDExIDg0IDMyIDkyIDEzIDUgMjQgMTYgMjQgMjUgMCAxMiAtMTMgMTUgLTY1CjE1IC01MiAwIC02NSAtMyAtNjUgLTE1eiIvPgo8cGF0aCBkPSJNODQ0NSA0NjMgYy0zIC0yMSAtMTAgLTU0IC0xNSAtNzQgLTYgLTIwIC0xMCAtNTMgLTEwIC03MyAwIC0zNCAyCi0zNiAzMyAtMzcgODQgLTMgMTA4IDUgMTM1IDQ0IDM0IDUxIDI5IDk2IC0xMyAxNDAgLTMxIDMyIC00MiAzNyAtODAgMzcgLTQzCjAgLTQ0IC0xIC01MCAtMzd6IG05MiAtMjUgYzEzIC0xMiAyMyAtMzMgMjMgLTQ4IDAgLTM0IC0zNSAtNzIgLTYzIC02OCAtMTkgMwotMjIgOCAtMTkgNDggNiA5NSAxNyAxMDggNTkgNjh6Ii8+CjxwYXRoIGQ9Ik02OTM4IDQ1OCBjLTYgLTEzIC0xMyAtNTggLTE0IC0xMDEgbC0zIC03OCAyNyAzIGMyNCAzIDI3IDggMzAgNDMgMgoyMiAxMCA0OCAxOSA1NyAxOSAyMSAxMCA4MyAtMTMgOTIgLTI1IDEwIC0zMyA3IC00NiAtMTZ6Ii8+CjxwYXRoIGQ9Ik01MzEyIDQwMyBjLTIyIC0yOCAtMzIgLTM0IC0zNSAtMjMgLTMgOCAtOCAyMyAtMTEgMzMgLTkgMjkgLTI2IDIyCi02MCAtMjcgLTEzIC0xOSAtMTQgLTE4IC0yNyAxMCAtMTggMzYgLTUyIDQwIC01NyA2IC0yIC0xMyAyIC0zMCA5IC0zOCA2IC04CjE1IC0yOSAxOCAtNDcgOSAtNDMgNDYgLTUxIDYxIC0xMyAxMiAzMyAzMyAzMyA0OCAxIDE0IC0yOSAzMyAtMzIgNTMgLTcgMjcKMzEgNzAgMTIyIDY0IDEzMiAtMTIgMTkgLTMzIDEwIC02MyAtMjd6Ii8+CjxwYXRoIGQ9Ik01NDMzIDQxMyBjLTQwIC0zOCAtNDggLTY1IC0yOCAtMTAzIDE1IC0yOSAxOCAtMzAgODAgLTMwIDc2IDAgODUgOQo4NSA5NCBsMCA1NiAtMzIgLTEgYy0xOCAtMSAtNDIgMiAtNTQgNiAtMTUgNSAtMjkgLTEgLTUxIC0yMnogbTc1IC02MCBjLTMKLTMyIC00NCAtNDYgLTU0IC0xOSAtMTAgMjYgNCA0NiAzMSA0NiAyMyAwIDI2IC00IDIzIC0yN3oiLz4KPHBhdGggZD0iTTYyMzcgNDMzIGMtNCAtMyAtNyAtMTkgLTcgLTM1IDAgLTQwIC0xNyAtNjggLTQxIC02OCAtMTggMCAtMjAgNAotMTMgNDUgNSAzNyAzIDQ2IC0xMSA1MSAtMjUgMTAgLTM3IC05IC00MyAtNjQgLTYgLTcwIDE2IC04OSA5OCAtODIgMzcgMyA0NQoxNCA2MCA3NSAxMSA0NCAxMSA1NyAwIDcwIC0xMyAxNiAtMzIgMjAgLTQzIDh6Ii8+CjxwYXRoIGQ9Ik02NzQxIDQxNCBjLTI2IC0yMiAtMzEgLTMzIC0zMSAtNzAgMCAtMzMgNSAtNDYgMTkgLTU0IDIzIC0xMiAxMjgKLTE0IDEzNCAtMiAzIDQgNyAzNiA5IDcyIGwzIDY1IC0zNyAwIGMtMjAgMCAtNDAgMyAtNDQgOCAtMTIgMTIgLTIxIDkgLTUzCi0xOXogbTg2IC01MCBjNSAtMTQgLTI0IC00NCAtNDIgLTQ0IC0xNiAwIC0yNiAyNSAtMTggNDYgNiAxNyA1NCAxNiA2MCAtMnoiLz4KPHBhdGggZD0iTTcwNzQgNDIwIGMtNDUgLTI5IC01NyAtMTA3IC0yMCAtMTMyIDIwIC0xNCAxMjYgLTkgMTMyIDUgMyA4IDYgNDAKNyA3MyBsMiA1OSAtMzIgLTIgYy0xNyAtMiAtMzUgMiAtMzggNyAtOSAxNCAtMTYgMTMgLTUxIC0xMHogbTcxIC01MCBjOSAtMTQKLTEzIC01MCAtMzEgLTUwIC0xNyAwIC0yOCAyNCAtMjAgNDUgNiAxNyA0MiAyMCA1MSA1eiIvPgo8cGF0aCBkPSJNNTgzMiA0MTcgYy02IC03IC0xNCAtMzEgLTE4IC01NCAtOCAtNTUgMTggLTgzIDc5IC04MyA1NyAwIDY0IDcgNzgKNjggMTMgNjEgOCA4MiAtMjAgODIgLTE5IDAgLTMxIC0yNSAtMzEgLTY3IDAgLTI2IC0zNyAtNTIgLTQ1IC0zMSAtMyA3IC00IDMxCi0zIDUzIDMgNDIgLTE4IDU5IC00MCAzMnoiLz4KPHBhdGggZD0iTTYzMjQgMzg1IGMtMTAgLTI1IDQgLTQ1IDMwIC00NSAzNCAwIDU2IDEwIDU2IDI2IDAgMzAgLTc2IDQ3IC04NgoxOXoiLz4KPC9nPgo8L3N2Zz4K\" alt=\"First Technology Logo\" class=\"logo\">\n            </div>\n            <div class=\"header-content\">\n                <h1>AD Domain Security & Compliance Audit Report</h1>\n                <p style=\"font-size: 1.3em; font-weight: bold;\">Customer: $CustomerName</p>\n            </div>\n            <div class=\"header-info\">\n                <p>Audit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</p>\n                <p>Auditor/Engineer: $($Summary.TechnicianName)</p>\n            </div>\n        </div>\n        \n        <div class=\"risk-banner\">\n            OVERALL SECURITY RISK: $($Summary.OverallRisk)\n        </div>\n        \n        <div class=\"metrics-grid\">\n            <div class=\"metric-card\">\n                <div class=\"metric-number critical\">$($Summary.CriticalFindings)</div>\n                <div>Critical Issues</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number high\">$($Summary.HighFindings)</div>\n                <div>High Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number medium\">$($Summary.MediumFindings)</div>\n                <div>Medium Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number low\">$($Summary.LowFindings)</div>\n                <div>Low Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\" style=\"color: #17a2b8;\">$($Summary.PassedFindings)</div>\n                <div>Controls Passed</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.IssuesFindings)</div>\n                <div>Issues Found</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.TotalFindings)</div>\n                <div>Total Checks</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$(($script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | Group-Object ComplianceFramework).Count)</div>\n                <div>Compliance Frameworks</div>\n            </div>\n        </div>\n\n        <!-- Domain Controller Health Dashboard -->\n        <div class=\"dc-dashboard\">\n            <div class=\"dc-dashboard-header\">\n                <h2>🖥️ Domain Controller Health Dashboard \n                    <span class=\"dc-count\">$($script:DomainControllerHealthData.Count) Controllers</span>\n                </h2>\n            </div>\n            <div class=\"dc-grid\">\n$(\n    if ($script:DomainControllerHealthData) {\n        foreach ($dc in $script:DomainControllerHealthData) {\n            $statusClass = switch ($dc.Status) {\n                'Healthy' { 'healthy' }\n                'Warning' { 'warning' }\n                'Critical' { 'critical' }\n                default { 'healthy' }\n            }\n            \n            $servicesHtml = ''\n            foreach ($service in $dc.Services.GetEnumerator()) {\n                $serviceClass = if ($service.Value -eq 'Running') { 'running' } else { 'stopped' }\n                $servicesHtml += \"<span class='dc-service $serviceClass'>$($service.Key)</span>\"\n            }\n            \n            $testsHtml = ''\n            foreach ($test in $dc.Tests.GetEnumerator()) {\n                $testClass = if ($test.Value -eq 'Passed') { 'passed' } else { 'failed' }\n                $testsHtml += \"<span class='dc-test $testClass'>$($test.Key)</span>\"\n            }\n            \n            $lastContactTime = $dc.LastContact.ToString('HH:mm:ss')\n            \n            @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header $statusClass\">\n                        <span>$($dc.Name.Split('.')[0])</span>\n                        <span>$($dc.Status.ToUpper())</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Site:</span>\n                            <span class=\"dc-info-value\">$($dc.Site)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Operating System:</span>\n                            <span class=\"dc-info-value\">$($dc.OS)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">IP Address:</span>\n                            <span class=\"dc-info-value\">$($dc.IPv4)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">FSMO Roles:</span>\n                            <span class=\"dc-info-value\">$(if ($dc.FSMORoles -and $dc.FSMORoles -ne 'None') { $dc.FSMORoles } else { 'None' })</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Last Contact:</span>\n                            <span class=\"dc-info-value\">$lastContactTime</span>\n                        </div>\n                        <div class=\"dc-services\">\n                            <strong>Services:</strong><br>\n                            $servicesHtml\n                        </div>\n                        <div class=\"dc-tests\">\n                            <strong>DCDIAG Tests:</strong><br>\n                            $testsHtml\n                        </div>\n                    </div>\n                </div>\n\"@\n        }\n    } else {\n        @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header healthy\">\n                        <span>Domain Controllers</span>\n                        <span>STATUS UNKNOWN</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <p>Domain controller health data not available. Extended health check may be disabled.</p>\n                    </div>\n                </div>\n\"@\n    }\n)\n            </div>\n        </div>\n\n        <div class=\"report-links\">\n            <h3>Download Detailed Reports</h3>\n            <a href=\"Infrastructure-Audit-Report.xlsx\">📊 Excel Report</a>\n            <a href=\"Infrastructure-Audit-Report.csv\">📄 CSV Report</a>\n            <a href=\"Executive-Summary.txt\">📋 Executive Summary</a>\n        </div>\n        \n        <div class=\"section\">\n            <h2>📋 Detailed Security Findings</h2>\n            <div style=\"text-align: right; margin: 10px 0;\">\n                <button onclick=\"expandAll()\" style=\"margin-right: 10px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;\">Expand All</button>\n                <button onclick=\"collapseAll()\" style=\"padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;\">Collapse All</button>\n            </div>\n            <div class=\"findings-container\">\n$(\n    # Group findings by severity for better organization\n    $criticalFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }\n    $highFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'High' }\n    $mediumFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    $lowFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }\n    $passedFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }\n    \n    $allGroupedFindings = @()\n    if ($criticalFindings.Count -gt 0) { $allGroupedFindings += @{Title='🔴 CRITICAL FINDINGS'; Findings=$criticalFindings; Class='critical-section'} }\n    if ($highFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟠 HIGH PRIORITY FINDINGS'; Findings=$highFindings; Class='high-section'} }\n    if ($mediumFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟡 MEDIUM PRIORITY FINDINGS'; Findings=$mediumFindings; Class='medium-section'} }\n    if ($lowFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟢 LOW PRIORITY FINDINGS'; Findings=$lowFindings; Class='low-section'} }\n    if ($passedFindings.Count -gt 0) { $allGroupedFindings += @{Title='✅ SECURITY CONTROLS PASSED'; Findings=$passedFindings; Class='passed-section'} }\n    \n    foreach ($group in $allGroupedFindings) {\n        $output = @\"\n                <div class=\"finding-group $($group.Class)\">\n                    <h3 class=\"finding-group-title\">$($group.Title) ($($group.Findings.Count) Issues)</h3>\n\"@\n        \n        foreach ($finding in $group.Findings) {\n            $severityIcon = switch ($finding.Severity) {\n                'Critical' { '🔴' }\n                'High' { '🟠' }\n                'Medium' { '🟡' }\n                'Low' { '🟢' }\n                'Passed' { '✅' }\n                default { '⚪' }\n            }\n            \n            $evidenceSection = if ($finding.Evidence -and $finding.Evidence.Trim() -ne '') {\n                @\"\n                        <div class=\"evidence-section\">\n                            <h5>📊 Evidence/Data:</h5>\n                            <pre class=\"evidence-data\">$($finding.Evidence)</pre>\n                        </div>\n\"@\n            } else { '' }\n            \n            $complianceSection = if ($finding.ComplianceFramework -and $finding.ComplianceFramework.Trim() -ne '') {\n                \"<p><strong>📝 Compliance Framework:</strong> <span class='compliance-tag'>$($finding.ComplianceFramework)</span></p>\"\n            } else { '' }\n            \n            $output += @\"\n                    <div class=\"finding-item $($finding.Severity.ToLower())-finding\">\n                        <div class=\"finding-header\" onclick=\"toggleFinding('$($finding.ID)')\">\n                            <div>\n                                <h4 class=\"finding-title\">$severityIcon $($finding.Title)</h4>\n                                <div class=\"finding-meta\">\n                                    <span class=\"finding-id\">ID: $($finding.ID)</span>\n                                    <span class=\"finding-category\">$($finding.Category)</span>\n                                    <span class=\"finding-type\">$($finding.Type)</span>\n                                    <span class=\"severity-badge $($finding.Severity.ToLower())\">$($finding.Severity.ToUpper())</span>\n                                </div>\n                            </div>\n                            <span class=\"finding-toggle\" id=\"toggle-$($finding.ID)\">+</span>\n                        </div>\n                        \n                        <div class=\"finding-content\" id=\"content-$($finding.ID)\">\n                            <div class=\"description-section\">\n                                <h5>📋 Description:</h5>\n                                <p>$($finding.Description)</p>\n                            </div>\n                            \n                            <div class=\"impact-section\">\n                                <h5>⚠️ Business Impact:</h5>\n                                <p>$($finding.Impact)</p>\n                            </div>\n                            \n                            <div class=\"recommendation-section\">\n                                <h5>🔧 Recommended Action:</h5>\n                                <p>$($finding.Recommendation)</p>\n                            </div>\n                            \n                            $evidenceSection\n                            \n                            <div class=\"finding-footer\">\n                                $complianceSection\n                                <p><strong>⏰ Discovered:</strong> $($finding.Timestamp.ToString('yyyy-MM-dd HH:mm:ss'))</p>\n                            </div>\n                        </div>\n                    </div>\n\"@\n        }\n        \n        $output += @\"\n                </div>\n\"@\n        $output\n    }\n)\n            </div>\n        </div>\n        \n\n\n        <div class=\"section\">\n            <h2>📊 Executive Summary & Risk Analysis</h2>\n            <div class=\"executive-summary\">\n                <div class=\"summary-grid\">\n                    <div class=\"summary-card\">\n                        <h3>🔍 Audit Scope</h3>\n                        <ul>\n                            <li><strong>Customer:</strong> $CustomerName</li>\n                            <li><strong>Audit Date:</strong> $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</li>\n                            <li><strong>Engineer/Auditor:</strong> $($Summary.TechnicianName)</li>\n                            <li><strong>Systems Assessed:</strong> Active Directory Infrastructure</li>\n                            <li><strong>Note:</strong> Server infrastructure audit temporarily disabled</li>\n                        </ul>\n                    </div>\n                    \n                    <div class=\"summary-card\">\n                        <h3>⚠️ Risk Assessment</h3>\n                        <div class=\"risk-summary\">\n                            <p><strong>Overall Risk Level:</strong> <span class=\"risk-level $($Summary.OverallRisk.ToLower())\">$($Summary.OverallRisk)</span></p>\n                            <p><strong>Priority Actions:</strong> $($Summary.CriticalFindings + $Summary.HighFindings) immediate items</p>\n                            <p><strong>Total Findings:</strong> $($Summary.TotalFindings) security issues identified</p>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"key-findings\">\n                    <h3>🎯 Key Security Concerns</h3>\n                    <div class=\"concern-list\">\n$(\n    $topConcerns = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Sort-Object @{Expression={if($_.Severity -eq 'Critical'){1}else{2}}}, Title | Select-Object -First 5\n    if ($topConcerns.Count -gt 0) {\n        foreach ($concern in $topConcerns) {\n            $icon = if ($concern.Severity -eq 'Critical') { '🔴' } else { '🟠' }\n            @\"\n                        <div class=\"concern-item\">\n                            <span class=\"concern-icon\">$icon</span>\n                            <div class=\"concern-content\">\n                                <strong>$($concern.Category):</strong> $($concern.Title)\n                                <br><small>$($concern.Impact)</small>\n                            </div>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"concern-item\"><span class=\"concern-icon\">✅</span><div class=\"concern-content\">No critical security concerns identified</div></div>'\n    }\n)\n                    </div>\n                </div>\n                \n                <div class=\"compliance-overview\">\n                    <h3>📋 Compliance Framework Analysis</h3>\n                    <div class=\"compliance-grid\">\n$(\n    $complianceStats = $script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | \n        Group-Object ComplianceFramework | Sort-Object Count -Descending\n    \n    if ($complianceStats.Count -gt 0) {\n        foreach ($framework in $complianceStats) {\n            $criticalCount = ($framework.Group | Where-Object { $_.Severity -eq 'Critical' }).Count\n            $highCount = ($framework.Group | Where-Object { $_.Severity -eq 'High' }).Count\n            @\"\n                        <div class=\"compliance-item\">\n                            <h4>$($framework.Name)</h4>\n                            <p>$($framework.Count) findings ($criticalCount critical, $highCount high priority)</p>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"compliance-item\"><h4>General Security</h4><p>Compliance framework mapping in progress</p></div>'\n    }\n)\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        $(if ($script:DomainControllerHealthData) { @\"\n        <div class=\"section\">\n            <h2>🏥 Domain Controller Health Dashboard</h2>\n            <div style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; overflow-x: auto;\">\n                <table style=\"width: 100%; border-collapse: collapse; font-size: 9pt; min-width: 1200px;\">\n                    <thead>\n                        <tr>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Server</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Site</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Ping</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Uptime (hrs)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (%)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (GB)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Time Sync</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NTDS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NetLogon</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Connectivity</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Replication</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Services</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Health Status</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n$(foreach ($dc in $script:DomainControllerHealthData) {\n    $fsmoDisplay = if ($dc.FSMORoles -and $dc.FSMORoles.Count -gt 0) { ($dc.FSMORoles -join '<br>') } else { 'None' }\n    @\"\n                        <tr>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; font-weight: bold;\">$($dc.Server)<br><small style=\"color: #666;\">$fsmoDisplay</small></td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center;\">$($dc.Site)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSTest -eq 'Success') { '#6BBF59' } elseif ($dc.DNSTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.DNSTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.PingTest -eq 'Success') { '#6BBF59' } elseif ($dc.PingTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.PingTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.UptimeHours -eq 'Fail' -or $dc.UptimeHours -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.UptimeHours -lt 24) { '#FFD966' } else { '#6BBF59' });\">$($dc.UptimeHours)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpacePercent -eq 'Fail' -or $dc.OSFreeSpacePercent -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 15) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpacePercent)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpaceGB -eq 'Fail' -or $dc.OSFreeSpaceGB -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 10) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpaceGB)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.TimeOffset -eq 'Fail') { '#D9534F; color: white' } elseif ([Math]::Abs($dc.TimeOffset) -gt 5) { '#D9534F; color: white' } else { '#6BBF59' });\">$($dc.TimeOffset)s</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DNSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NTDSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NTDSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NetLogonService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NetLogonService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagConnectivity -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagConnectivity)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagReplications -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagReplications)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagServices -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagServices)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; font-weight: bold; background: $(if ($dc.OverallHealth -eq 'Healthy') { '#6BBF59' } elseif ($dc.OverallHealth -eq 'Warning') { '#FFD966' } else { '#D9534F; color: white' });\">$($dc.OverallHealth)</td>\n                        </tr>\n\"@\n})\n                    </tbody>\n                </table>\n                <div style=\"margin-top: 10px; font-size: 9pt; color: #666;\">\n                    <strong>Legend:</strong> \n                    <span style=\"background: #6BBF59; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Pass</span>\n                    <span style=\"background: #FFD966; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Warning</span>\n                    <span style=\"background: #D9534F; color: white; padding: 2px 6px; border-radius: 3px;\">Fail</span>\n                </div>\n            </div>\n        </div>\n\"@ })\n        \n        <div style=\"text-align: center; margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 10px;\">\n            <p><strong>Audit Summary</strong></p>\n            <p>This comprehensive audit assessed $($Summary.TotalFindings) security and compliance findings across the Active Directory infrastructure.</p>\n        </div>\n    </div>\n\n    <script>\n        // Collapsible findings functionality\n        function toggleFinding(findingId) {\n            const content = document.getElementById('content-' + findingId);\n            const toggle = document.getElementById('toggle-' + findingId);\n            \n            if (content.classList.contains('show')) {\n                content.classList.remove('show');\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            } else {\n                content.classList.add('show');\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            }\n        }\n        \n        // Expand/Collapse all functions\n        function expandAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.add('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            });\n        }\n        \n        function collapseAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.remove('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            });\n        }\n        \n        console.log('Infrastructure Audit Report loaded successfully');\n        console.log('Total findings: $($Summary.TotalFindings)');\n        console.log('Risk level: $($Summary.OverallRisk)');\n        \n        // Initialize all findings as collapsed by default\n        document.addEventListener('DOMContentLoaded', function() {\n            collapseAll();\n        });\n    </script>\n</body>\n</html>\n\"@\n    \n    $htmlContent | Out-File -FilePath $htmlPath -Encoding UTF8\n    Write-AuditLog \"HTML report saved: $htmlPath\" -Level Success\n}\n\nfunction New-ExcelReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Excel report...' -Level Info\n    \n    try {\n        $excelPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.xlsx'\n        \n        # Check if ImportExcel module is available\n        if (-not (Get-Module -ListAvailable -Name ImportExcel)) {\n            Write-AuditLog \"ImportExcel module not available, skipping Excel export\" -Level Warning\n            return\n        }\n        \n        Import-Module ImportExcel -SkipEditionCheck -ErrorAction SilentlyContinue\n        \n        # Summary sheet\n        $summaryData = [PSCustomObject]@{\n            'Metric' = 'Customer Name'; 'Value' = $Summary.CustomerName\n        }, [PSCustomObject]@{\n            'Metric' = 'Audit Date'; 'Value' = $Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss')\n        }, [PSCustomObject]@{\n            'Metric' = 'Technician'; 'Value' = $Summary.TechnicianName\n        }, [PSCustomObject]@{\n            'Metric' = 'Overall Risk Level'; 'Value' = $Summary.OverallRisk\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Findings'; 'Value' = $Summary.TotalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Critical Findings'; 'Value' = $Summary.CriticalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'High Findings'; 'Value' = $Summary.HighFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Servers'; 'Value' = $Summary.TotalServers\n        }, [PSCustomObject]@{\n            'Metric' = 'Online Servers'; 'Value' = $Summary.OnlineServers\n        }, [PSCustomObject]@{\n            'Metric' = 'High Risk Servers'; 'Value' = $Summary.HighRiskServers\n        }\n        \n        $summaryData | Export-Excel -Path $excelPath -WorksheetName 'Summary' -AutoSize -BoldTopRow\n        \n        # Findings sheet\n        $script:AuditFindings | Export-Excel -Path $excelPath -WorksheetName 'Security Findings' -AutoSize -BoldTopRow\n        \n        # Server results sheet\n        $script:ServerResults | Export-Excel -Path $excelPath -WorksheetName 'Server Status' -AutoSize -BoldTopRow\n        \n        Write-AuditLog \"Excel report saved: $excelPath\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating Excel report: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\nfunction New-CSVReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating CSV reports...' -Level Info\n    \n    # Findings CSV\n    $findingsPath = Join-Path $script:OutputDir 'Audit-Findings.csv'\n    $script:AuditFindings | Export-Csv -Path $findingsPath -NoTypeInformation\n    \n    # Server status CSV\n    $serversPath = Join-Path $script:OutputDir 'Server-Status.csv'\n    $script:ServerResults | Export-Csv -Path $serversPath -NoTypeInformation\n    \n    Write-AuditLog \"CSV reports saved: $findingsPath, $serversPath\" -Level Success\n}\n\nfunction New-MarkdownReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Markdown report...' -Level Info\n    \n    $markdownPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.md'\n    \n    $markdownContent = @\"\n# Infrastructure Security Audit Report\n\n**Customer:** $CustomerName  \n**Audit Date:** $($Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss'))  \n**Technician:** $($Summary.TechnicianName)  \n**Overall Risk Level:** **$($Summary.OverallRisk)**\n\n## Executive Summary\n\nThis infrastructure audit assessed $($Summary.TotalServers) servers and identified $($Summary.TotalFindings) security and configuration findings.\n\n### Key Metrics\n\n| Metric | Count |\n|--------|-------|\n| Critical Findings | $($Summary.CriticalFindings) |\n| High Priority Findings | $($Summary.HighFindings) |\n| Medium Priority Findings | $($Summary.MediumFindings) |\n| Low Priority Findings | $($Summary.LowFindings) |\n| Total Servers Audited | $($Summary.TotalServers) |\n| Online Servers | $($Summary.OnlineServers) |\n| High Risk Servers | $($Summary.HighRiskServers) |\n\n## Security Findings\n\n$(\n    $script:AuditFindings | ForEach-Object {\n        @\"\n### $($_.Title) [$($_.Severity)]\n\n**Category:** $($_.Category)  \n**Type:** $($_.Type)  \n**Compliance Framework:** $($_.ComplianceFramework)\n\n**Description:** $($_.Description)\n\n**Impact:** $($_.Impact)\n\n**Recommendation:** $($_.Recommendation)\n\n$(if ($_.Evidence) { \"**Evidence:**`n``````n$($_.Evidence)`n``````n\" })\n\n---\n\"@\n    }\n)\n\n## Server Infrastructure Status\n\n| Server Name | Status | Operating System | Risk Score | Security Issues | Performance Issues |\n|-------------|--------|------------------|------------|-----------------|-------------------|\n$(\n    $script:ServerResults | ForEach-Object {\n        \"| $($_.ServerName) | $($_.PingStatus) | $($_.OperatingSystem) | $($_.RiskScore) | $($_.SecurityIssues.Count) | $($_.PerformanceIssues.Count) |\"\n    }\n)\n\n## Recommendations Summary\n\n### Immediate Actions Required (Critical/High)\n$(\n    $criticalAndHigh = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') }\n    if ($criticalAndHigh.Count -gt 0) {\n        $criticalAndHigh | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\n### Short-term Improvements (Medium)\n$(\n    $medium = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    if ($medium.Count -gt 0) {\n        $medium | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No medium priority items identified\"\n    }\n)\n\n---\n\n*Report generated by Master Infrastructure Audit Script v$($script:Version)*  \n*Audit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes*\n\"@\n    \n    $markdownContent | Out-File -FilePath $markdownPath -Encoding UTF8\n    Write-AuditLog \"Markdown report saved: $markdownPath\" -Level Success\n}\n\nfunction New-ExecutiveSummary {\n    param($Summary)\n    \n    Write-AuditLog 'Generating executive summary...' -Level Info\n    \n    $execSummaryPath = Join-Path $script:OutputDir 'Executive-Summary.txt'\n    \n    $execSummary = @\"\nINFRASTRUCTURE SECURITY AUDIT - EXECUTIVE SUMMARY\n================================================================\n\nCustomer: $CustomerName\nAudit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))\nEngineer/Auditor: $($Summary.TechnicianName)\nAudit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes\n\nOVERALL RISK ASSESSMENT: $($Summary.OverallRisk)\n\nFINDINGS SUMMARY:\n- Critical Issues: $($Summary.CriticalFindings)\n- High Priority: $($Summary.HighFindings)  \n- Medium Priority: $($Summary.MediumFindings)\n- Low Priority: $($Summary.LowFindings)\n- Total Findings: $($Summary.TotalFindings)\n\nINFRASTRUCTURE SUMMARY:\n- Total Servers: $($Summary.TotalServers)\n- Online Servers: $($Summary.OnlineServers)\n- Offline Servers: $($Summary.OfflineServers)\n- High Risk Servers: $($Summary.HighRiskServers)\n\nIMMEDIATE ACTIONS REQUIRED:\n$(\n    $immediateActions = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Select-Object -First 5\n    if ($immediateActions.Count -gt 0) {\n        $immediateActions | ForEach-Object { \"- $($_.Category): $($_.Title)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\nCOMPLIANCE ASSESSMENT:\n$(\n    $frameworks = $script:AuditFindings | Group-Object ComplianceFramework | Where-Object { $_.Name -ne '' }\n    if ($frameworks.Count -gt 0) {\n        $frameworks | ForEach-Object { \"- $($_.Name): $($_.Count) findings\" }\n    } else {\n        \"- Compliance frameworks assessment pending\"\n    }\n)\n\nThis executive summary provides a high-level overview of the infrastructure \nsecurity assessment. Detailed findings, recommendations, and remediation \nprocedures are available in the comprehensive audit reports.\n\n================================================================\n\"@\n    \n    $execSummary | Out-File -FilePath $execSummaryPath -Encoding UTF8\n    Write-AuditLog \"Executive summary saved: $execSummaryPath\" -Level Success\n}\n\n# ==============================================================================\n# MAIN EXECUTION LOGIC\n# ==============================================================================\n\nfunction Start-MasterInfrastructureAudit {\n    # Display banner\n    Write-Host \"\"\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"MASTER INFRASTRUCTURE AUDIT SCRIPT v$($script:Version)\" -ForegroundColor Cyan\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"Customer: $CustomerName\" -ForegroundColor White\n    Write-Host \"Technician: $TechnicianName\" -ForegroundColor White\n    Write-Host \"Start Time: $($script:StartTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -ForegroundColor White\n    Write-Host \"Output Directory: $script:OutputDir\" -ForegroundColor White\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"\"\n    \n    Write-AuditLog \"Starting Master Infrastructure Audit for $CustomerName\" -Level Header\n    Write-AuditLog \"Technician: $TechnicianName\" -Level Info\n    Write-AuditLog \"Output Directory: $script:OutputDir\" -Level Info\n    Write-AuditLog \"Export Formats: $($ExportFormats -join ', ')\" -Level Info\n    \n    try {\n        # Initialize logo path for reports\n        $script:LogoPath = Initialize-LogoPath\n        Write-AuditLog \"Logo path initialized: $($script:LogoPath)\" -Level Info\n        \n        # Initialize task counting\n        $script:TotalTasks = 1 # Report Generation is always done\n        if (-not $SkipADHealthChecks) { $script:TotalTasks++ }\n        if (-not $SkipServerAudit) { $script:TotalTasks++ }\n        \n        # Active Directory Health Assessment\n        if (-not $SkipADHealthChecks) {\n            Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Starting Active Directory assessment...\"\n            $adSuccess = Test-ADInfrastructureHealth\n            $script:CompletedTasks++\n            \n            if (-not $adSuccess) {\n                Write-AuditLog \"Active Directory assessment failed or incomplete\" -Level Warning\n            }\n        } else {\n            Write-AuditLog \"Skipping Active Directory health checks as requested\" -Level Info\n        }\n        \n        # Server Infrastructure Audit - Currently disabled due to hanging issues\n        if (-not $SkipServerAudit) {\n            Write-AuditLog \"Server infrastructure audit temporarily disabled due to connectivity issues\" -Level Warning\n            Write-AuditLog \"Focus on Active Directory findings - server audit can be run separately if needed\" -Level Info\n            $script:CompletedTasks++\n        } else {\n            Write-AuditLog \"Skipping server infrastructure audit as requested\" -Level Info\n        }\n        \n        # Generate Reports\n        Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Generating comprehensive reports...\"\n        New-ComprehensiveAuditReport\n        $script:CompletedTasks++\n        \n        # Display final summary\n        $executionTime = (Get-Date) - $script:StartTime\n        \n        Write-Host \"\"\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"AUDIT COMPLETED SUCCESSFULLY\" -ForegroundColor Green\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"\"\n        \n        $summary = Get-AuditSummaryStatistics\n        \n        Write-Host \"AUDIT SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"  Customer: $CustomerName\" -ForegroundColor White\n        Write-Host \"  Overall Risk Level: \" -NoNewline -ForegroundColor White\n        \n        switch ($summary.OverallRisk) {\n            'CRITICAL' { Write-Host $summary.OverallRisk -ForegroundColor Red }\n            'HIGH' { Write-Host $summary.OverallRisk -ForegroundColor DarkRed }\n            'MEDIUM' { Write-Host $summary.OverallRisk -ForegroundColor Yellow }\n            'LOW' { Write-Host $summary.OverallRisk -ForegroundColor Green }\n        }\n        \n        Write-Host \"\"\n        Write-Host \"FINDINGS:\" -ForegroundColor Cyan\n        Write-Host \"  Critical: \" -NoNewline -ForegroundColor White\n        Write-Host $summary.CriticalFindings -ForegroundColor $(if ($summary.CriticalFindings -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High:     \" -NoNewline -ForegroundColor White\n        Write-Host $summary.HighFindings -ForegroundColor $(if ($summary.HighFindings -gt 0) { 'DarkRed' } else { 'Green' })\n        Write-Host \"  Medium:   \" -NoNewline -ForegroundColor White\n        Write-Host $summary.MediumFindings -ForegroundColor $(if ($summary.MediumFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Low:      \" -NoNewline -ForegroundColor White\n        Write-Host $summary.LowFindings -ForegroundColor $(if ($summary.LowFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Total:    \" -NoNewline -ForegroundColor White\n        Write-Host $summary.TotalFindings -ForegroundColor Cyan\n        \n        Write-Host \"\"\n        Write-Host \"INFRASTRUCTURE:\" -ForegroundColor Cyan\n        Write-Host \"  Total Servers:    $($summary.TotalServers)\" -ForegroundColor White\n        Write-Host \"  Online Servers:   $($summary.OnlineServers)\" -ForegroundColor Green\n        Write-Host \"  Offline Servers:  $($summary.OfflineServers)\" -ForegroundColor $(if ($summary.OfflineServers -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High Risk Servers: $($summary.HighRiskServers)\" -ForegroundColor $(if ($summary.HighRiskServers -gt 0) { 'Red' } else { 'Green' })\n        \n        Write-Host \"\"\n        Write-Host \"EXECUTION DETAILS:\" -ForegroundColor Cyan\n        Write-Host \"  Duration: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -ForegroundColor White\n        Write-Host \"  Reports Location: $script:OutputDir\" -ForegroundColor White\n        \n        if ($summary.CriticalFindings -gt 0 -or $summary.HighFindings -gt 0) {\n            Write-Host \"\"\n            Write-Host \"⚠️  URGENT ACTION REQUIRED ⚠️\" -ForegroundColor Red -BackgroundColor Yellow\n            Write-Host \"Critical and High priority issues require immediate attention!\" -ForegroundColor Red\n        }\n        \n        Write-AuditLog \"Master Infrastructure Audit completed successfully\" -Level Success\n        Write-AuditLog \"Total execution time: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -Level Info\n        \n        # Open output directory\n        try {\n            Start-Process $script:OutputDir\n        } catch {\n            Write-AuditLog \"Could not open output directory automatically\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"FATAL ERROR during audit execution: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Stack Trace: $($_.ScriptStackTrace)\" -Level Error\n        throw\n    } finally {\n        Write-Progress -Activity \"Master Infrastructure Audit\" -Completed\n    }\n}\n\n# ==============================================================================\n# SCRIPT EXECUTION\n# ==============================================================================\n\n# Check required modules before starting\nif (-not (Test-RequiredModules)) {\n    Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n    exit 1\n}\n\n# Parameter validation\nif (-not $CustomerName -or -not $TechnicianName) {\n    Write-Error \"CustomerName and TechnicianName parameters are required\"\n    exit 1\n}\n\n# Execute the main audit function\ntry {\n    Start-MasterInfrastructureAudit\n} catch {\n    Write-Host \"`nSCRIPT EXECUTION FAILED:\" -ForegroundColor Red\n    Write-Host $_.Exception.Message -ForegroundColor Red\n    Write-Host \"`nFor support, check the audit log in: $script:OutputDir\" -ForegroundColor Yellow\n    exit 1\n}\n\nWrite-Host \"`n✅ Master Infrastructure Audit completed successfully!\" -ForegroundColor Green\nWrite-Host \"📁 All reports and logs saved to: $script:OutputDir\" -ForegroundColor Cyan",
    "language": "powershell",
    "category": "infrastructure",
    "tags": [
      "audit",
      "backup",
      "monitoring",
      "export",
      "import",
      "system",
      "infrastructure",
      "performance",
      "security"
    ],
    "lastModified": "2025-07-14T02:40:17.212Z",
    "version": "5.1",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": [
      {
        "name": "true",
        "type": "string",
        "required": false,
        "description": "Parameter true"
      }
    ]
  },
  {
    "id": "imported-1759100564557-vty03tg36",
    "name": "Requires -Version 5.1",
    "description": "Requires -Version 5.1",
    "content": "#Requires -Version 5.1\n#Requires -RunAsAdministrator\n# Note: ActiveDirectory and GroupPolicy modules will be imported dynamically with error handling\n\n<#\n.SYNOPSIS\n    Master Infrastructure Audit Script - Comprehensive AD and Server Assessment\n    \n.DESCRIPTION\n    This script performs a comprehensive audit of Active Directory and server infrastructure,\n    incorporating industry best practices, security compliance standards, and proven methodologies\n    from multiple audit frameworks. It provides detailed analysis, risk scoring, and actionable\n    recommendations for infrastructure improvements.\n    \n.PARAMETER CustomerName\n    Name of the customer/organization being audited\n    \n.PARAMETER TechnicianName  \n    Name of the technician performing the audit\n    \n.PARAMETER OutputPath\n    Custom output directory path (defaults to desktop)\n    \n.PARAMETER ServerListPath\n    Path to CSV file containing server list (optional - auto-discovers from AD if not provided)\n    \n.PARAMETER SkipServerAudit\n    Skip server infrastructure auditing (AD only)\n    \n.PARAMETER SkipADHealthChecks\n    Skip Active Directory health checks\n    \n.PARAMETER MaxConcurrentJobs\n    Maximum concurrent server audit jobs (default: 10)\n    \n.PARAMETER CredentialPath\n    Path to secure credential file (optional)\n    \n.PARAMETER ExportFormats\n    Export formats: HTML, PDF, Excel, CSV, Markdown (default: HTML,Excel,CSV)\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Acme Corp\" -TechnicianName \"John Smith\"\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Client\" -TechnicianName \"Engineer\" -SkipServerAudit\n\n    -CustomerName \"Ashton Graham\" -TechnicianName \"Nishen Harichunder\" -ServerListPath \"C:\\FtechSupport\\N1_Audit\\server-list.csv\"\n\n    \n.NOTES\n    Author: Nishen Harichunder - RMS L4 Infrastructure Audit Team\n    Version: 1.0\n    Created: $(Get-Date -Format 'yyyy-MM-dd')\n    \n    Requirements:\n    - PowerShell 5.1 or higher\n    - Active Directory PowerShell module\n    - Domain Admin or equivalent privileges for comprehensive auditing\n    - Network connectivity to all target systems\n    \n    Security Considerations:\n    - All credentials are handled securely using PowerShell credential objects\n    - Audit activities are logged comprehensively\n    - Sensitive data is protected in transit and at rest\n    - Script follows principle of least privilege where possible\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$true, HelpMessage=\"Customer/Organization name for audit report\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$CustomerName,\n    \n    [Parameter(Mandatory=$true, HelpMessage=\"Technician name performing the audit\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$TechnicianName,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$OutputPath,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ServerListPath,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipServerAudit,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipADHealthChecks,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateRange(1,20)]\n    [int]$MaxConcurrentJobs = 10,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$CredentialPath,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateSet('HTML','PDF','Excel','CSV','Markdown')]\n    [string[]]$ExportFormats = @('HTML','Excel','CSV')\n)\n\n# ==============================================================================\n# SCRIPT CONFIGURATION AND INITIALIZATION\n# ==============================================================================\n\n# Global script variables\n$script:Version = '1.0'\n$script:StartTime = Get-Date\n$script:AuditFindings = @()\n$script:ServerResults = @()\n$script:ADHealthResults = @()\n$script:CompletedTasks = 0\n$script:TotalTasks = 0\n\n# Risk scoring configuration\n$script:RiskScores = @{\n    'Critical' = 10\n    'High' = 7\n    'Medium' = 4\n    'Low' = 2\n    'Info' = 1\n}\n\n# Compliance frameworks\n$script:ComplianceFrameworks = @{\n    'CIS' = 'Center for Internet Security Benchmarks'\n    'NIST' = 'NIST Cybersecurity Framework'\n    'ISO27001' = 'ISO 27001 Information Security Management'\n    'Microsoft' = 'Microsoft Security Baselines'\n}\n\n# Initialize output directory\nif (-not $OutputPath) {\n    $script:OutputDir = Join-Path $env:USERPROFILE \"Desktop\\Infrastructure-Audit-$CustomerName-$(Get-Date -Format 'yyyyMMdd-HHmmss')\"\n} else {\n    $script:OutputDir = $OutputPath\n}\n\nif (-not (Test-Path $script:OutputDir)) {\n    New-Item -ItemType Directory -Path $script:OutputDir -Force | Out-Null\n}\n\n# Initialize logo path\n$script:LogoPath = \"\"\n\n# ==============================================================================\n# LOGGING AND UTILITY FUNCTIONS\n# ==============================================================================\n\nfunction Test-RequiredModules {\n    Write-Host \"Checking required PowerShell modules...\" -ForegroundColor Yellow\n    \n    # Check if running on Windows Server or Client\n    $isWindowsServer = (Get-CimInstance -ClassName Win32_OperatingSystem).ProductType -ne 1\n    \n    $requiredModules = @('ActiveDirectory')\n    $optionalModules = @('GroupPolicy')\n    $missingModules = @()\n    $missingOptionalModules = @()\n    $availableModules = @()\n    \n    # Check required modules\n    foreach ($module in $requiredModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"✗ $module module is NOT available\" -ForegroundColor Red\n                $missingModules += $module\n            }\n        } catch {\n            Write-Host \"✗ Error checking $module module: $($_.Exception.Message)\" -ForegroundColor Red\n            $missingModules += $module\n        }\n    }\n    \n    # Check optional modules\n    foreach ($module in $optionalModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"⚠ $module module is NOT available (optional - some features may be limited)\" -ForegroundColor Yellow\n                $missingOptionalModules += $module\n            }\n        } catch {\n            Write-Host \"⚠ Error checking $module module: $($_.Exception.Message) (optional)\" -ForegroundColor Yellow\n            $missingOptionalModules += $module\n        }\n    }\n    \n    # Handle missing required modules\n    if ($missingModules.Count -gt 0) {\n        Write-Host \"`nMissing Required Modules:\" -ForegroundColor Red\n        foreach ($module in $missingModules) {\n            Write-Host \"  - $module\" -ForegroundColor Red\n        }\n        Write-Host \"`nTo install missing modules, run the following commands as Administrator:\" -ForegroundColor Yellow\n        if ($missingModules -contains 'ActiveDirectory') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name RSAT-AD-PowerShell\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.ActiveDirectory*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n        return $false\n    }\n    \n    # Handle missing optional modules\n    if ($missingOptionalModules.Count -gt 0) {\n        Write-Host \"`nMissing Optional Modules:\" -ForegroundColor Yellow\n        foreach ($module in $missingOptionalModules) {\n            Write-Host \"  - $module (Group Policy auditing will be limited)\" -ForegroundColor Yellow\n        }\n        Write-Host \"`nTo install optional modules for full functionality:\" -ForegroundColor Yellow\n        if ($missingOptionalModules -contains 'GroupPolicy') {\n            if ($isWindowsServer) {\n                Write-Host \"  Install-WindowsFeature -Name GPMC\" -ForegroundColor Cyan\n            } else {\n                Write-Host \"  # For Windows 10/11 - Install RSAT via Windows Features:\" -ForegroundColor Cyan\n                Write-Host \"  Get-WindowsCapability -Online | Where-Object Name -like '*RSAT.GroupPolicy*' | Add-WindowsCapability -Online\" -ForegroundColor Cyan\n                Write-Host \"  # OR download RSAT from Microsoft and install manually\" -ForegroundColor Cyan\n            }\n        }\n        Write-Host \"`nContinuing with limited functionality...\" -ForegroundColor Yellow\n    }\n    \n    if ($missingOptionalModules.Count -eq 0) {\n        Write-Host \"All required and optional modules are available!\" -ForegroundColor Green\n    } else {\n        Write-Host \"Required modules are available. Continuing with some optional features disabled.\" -ForegroundColor Yellow\n    }\n    \n    # Store available modules for later use\n    $script:AvailableModules = $availableModules\n    return $true\n}\n\nfunction Write-AuditLog {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Message,\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Header', 'Debug')]\n        [string]$Level = 'Info',\n        \n        [Parameter(Mandatory=$false)]\n        [switch]$NoConsole\n    )\n    \n    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'\n    $logEntry = \"[$timestamp] [$Level] $Message\"\n    \n    # Console output with colors\n    if (-not $NoConsole) {\n        switch ($Level) {\n            'Info' { Write-Host $logEntry -ForegroundColor White }\n            'Warning' { Write-Host $logEntry -ForegroundColor Yellow }\n            'Error' { Write-Host $logEntry -ForegroundColor Red }\n            'Success' { Write-Host $logEntry -ForegroundColor Green }\n            'Debug' { Write-Host $logEntry -ForegroundColor Gray }\n            'Header' { \n                Write-Host \"\"\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n                Write-Host $Message -ForegroundColor Cyan\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n            }\n        }\n    }\n    \n    # File logging\n    $logFile = Join-Path $script:OutputDir 'master-audit-log.txt'\n    try {\n        Add-Content -Path $logFile -Value $logEntry -ErrorAction Stop\n    } catch {\n        # Fallback logging if main log fails\n        $logEntry | Out-File -FilePath (Join-Path $script:OutputDir 'audit-log-backup.txt') -Append -ErrorAction Stop\n    }\n}\n\nfunction Convert-ToBase64 {\n    param([string]$FilePath)\n    try {\n        if (Test-Path $FilePath) {\n            $bytes = [System.IO.File]::ReadAllBytes($FilePath)\n            return [System.Convert]::ToBase64String($bytes)\n        }\n        return \"\"\n    } catch {\n        return \"\"\n    }\n}\n\nfunction Initialize-LogoPath {\n    $logoFolder = Join-Path (Split-Path $script:MyInvocation.MyCommand.Path) \"Ftech Logos\"\n    $logoFiles = @(\n        \"first-tech-kzn-logo-black 1.png\",\n        \"FTECHKZN Horizontal Vector-03 1.png\", \n        \"FTECHKZN Horizontal Vector-04 1 (2).png\"\n    )\n    \n    foreach ($logoFile in $logoFiles) {\n        $logoPath = Join-Path $logoFolder $logoFile\n        if (Test-Path $logoPath) {\n            return $logoPath\n        }\n    }\n    \n    # Fallback - find any PNG in logo folder\n    $pngFiles = Get-ChildItem -Path $logoFolder -Filter \"*.png\" -ErrorAction SilentlyContinue\n    if ($pngFiles) {\n        return $pngFiles[0].FullName\n    }\n    \n    return \"\"\n}\n\nfunction Add-AuditFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [ValidateSet('Critical', 'High', 'Medium', 'Low', 'Info')]\n        [string]$Severity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Impact,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Recommendation,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"F$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = $Severity\n        Type = $Type\n        Description = $Description\n        Impact = $Impact\n        Recommendation = $Recommendation\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = $script:RiskScores[$Severity]\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    \n    $logLevel = switch ($Severity) {\n        'Critical' { 'Error' }\n        'High' { 'Error' }\n        'Medium' { 'Warning' }\n        default { 'Info' }\n    }\n    \n    Write-AuditLog \"[$Severity] $Category - $Title\" -Level $logLevel\n}\n\nfunction Add-PositiveFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"P$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = 'Passed'\n        Type = $Type\n        Description = $Description\n        Impact = 'Positive security posture - no action required.'\n        Recommendation = 'Continue current security practices.'\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = 0\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    Write-AuditLog \"[PASSED] $Category - $Title\" -Level Success\n}\n\nfunction Update-AuditProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Status = '',\n        \n        [Parameter(Mandatory=$false)]\n        [int]$PercentComplete = 0,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Completed = $script:CompletedTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Total = $script:TotalTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Id = 0\n    )\n    \n    if ($Total -gt 0) {\n        $PercentComplete = [math]::Round(($Completed / $Total) * 100, 1)\n    }\n    \n    # Ensure percentage never exceeds 100\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    $progressParams = @{\n        Activity = $Activity\n        Status = $Status\n        PercentComplete = $PercentComplete\n        Id = $Id\n    }\n    \n    if ($Total -gt 0) {\n        $progressParams.CurrentOperation = \"Phase $Completed of $Total - $PercentComplete% Complete\"\n    }\n    \n    Write-Progress @progressParams\n    \n    if ($Status) {\n        Write-AuditLog \"Overall Progress: $PercentComplete% - $Status\" -Level Info\n    }\n}\n\nfunction Update-SectionProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Status,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$StepNumber,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$TotalSteps,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$ParentId = 0\n    )\n    \n    $PercentComplete = [math]::Round(($StepNumber / $TotalSteps) * 100, 1)\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    Write-Progress -Id ($ParentId + 1) -ParentId $ParentId -Activity $Activity -Status $Status -PercentComplete $PercentComplete -CurrentOperation \"Step $StepNumber of $TotalSteps\"\n    \n    Write-AuditLog \"Section Progress: [$Activity] $PercentComplete% - $Status\" -Level Debug\n}\n\n# ==============================================================================\n# ACTIVE DIRECTORY HEALTH CHECKS\n# ==============================================================================\n\nfunction Test-WinRMConnectivity {\n    <#\n    .SYNOPSIS\n        Tests WinRM connectivity to remote computers\n    .DESCRIPTION\n        Verifies if PowerShell remoting is available and working on target computers\n    .PARAMETER ComputerName\n        The name of the remote computer to test\n    .EXAMPLE\n        Test-WinRMConnectivity -ComputerName \"DC01.domain.com\"\n    #>\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName\n    )\n    \n    $result = @{\n        ComputerName = $ComputerName\n        WinRMAvailable = $false\n        Port5985Open = $false\n        Port5986Open = $false\n        PSRemotingWorking = $false\n        ErrorMessage = $null\n    }\n    \n    try {\n        # Test WinRM ports\n        Write-AuditLog \"Testing WinRM connectivity to $ComputerName...\" -Level Info\n        \n        # Test HTTP port (5985)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5985 -WarningAction SilentlyContinue\n            $result.Port5985Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5985 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test HTTPS port (5986)\n        try {\n            $tcpTest = Test-NetConnection -ComputerName $ComputerName -Port 5986 -WarningAction SilentlyContinue\n            $result.Port5986Open = $tcpTest.TcpTestSucceeded\n        } catch {\n            Write-AuditLog \"TCP test for port 5986 failed: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Test actual PowerShell remoting\n        try {\n            $testSession = New-PSSession -ComputerName $ComputerName -ErrorAction Stop\n            if ($testSession) {\n                $result.PSRemotingWorking = $true\n                $result.WinRMAvailable = $true\n                Remove-PSSession -Session $testSession -ErrorAction SilentlyContinue\n                Write-AuditLog \"PowerShell remoting is working on $ComputerName\" -Level Success\n            }\n        } catch {\n            $result.ErrorMessage = $_.Exception.Message\n            Write-AuditLog \"PowerShell remoting test failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Alternative test using Invoke-Command with test command\n        if (-not $result.PSRemotingWorking) {\n            try {\n                $testResult = Invoke-Command -ComputerName $ComputerName -ScriptBlock { $env:COMPUTERNAME } -ErrorAction Stop\n                if ($testResult) {\n                    $result.PSRemotingWorking = $true\n                    $result.WinRMAvailable = $true\n                    Write-AuditLog \"PowerShell remoting confirmed working on $ComputerName via Invoke-Command\" -Level Success\n                }\n            } catch {\n                Write-AuditLog \"Invoke-Command test also failed for $ComputerName - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        $result.ErrorMessage = $_.Exception.Message\n        Write-AuditLog \"WinRM connectivity test failed for $ComputerName - $($_.Exception.Message)\" -Level Error\n    }\n    \n    return $result\n}\n\nfunction Test-RemoteService {\n    <#\n    .SYNOPSIS\n        Tests the status of a service on a remote computer using multiple methods\n    .DESCRIPTION\n        This function attempts to check service status using various methods as fallbacks:\n        1. Get-Service with ComputerName parameter\n        2. WMI Win32_Service class\n        3. PowerShell remoting with Invoke-Command\n        4. SC.exe command-line tool\n    .PARAMETER ComputerName\n        The name of the remote computer\n    .PARAMETER ServiceName\n        The name of the service to check\n    .PARAMETER DisplayName\n        The display name of the service for logging\n    .OUTPUTS\n        Returns hashtable with ServiceStatus, Method, and ErrorDetails\n    #>\n    param(\n        [Parameter(Mandatory)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory)]\n        [string]$ServiceName,\n        \n        [Parameter(Mandatory)]\n        [string]$DisplayName\n    )\n    \n    $result = @{\n        ServiceStatus = $null\n        Method = $null\n        ErrorDetails = @()\n        Success = $false\n    }\n    \n    # Method 1: Standard Get-Service with ComputerName\n    try {\n        $serviceStatus = Get-Service -ComputerName $ComputerName -Name $ServiceName -ErrorAction Stop\n        $result.ServiceStatus = $serviceStatus.Status\n        $result.Method = 'Get-Service'\n        $result.Success = $true\n        return $result\n    } catch {\n        $result.ErrorDetails += \"Get-Service failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 2: WMI Win32_Service\n    try {\n        $serviceStatus = Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter \"Name='$ServiceName'\" -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.State\n            $result.Method = 'WMI'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"WMI returned null for service $ServiceName\"\n        }\n    } catch {\n        $result.ErrorDetails += \"WMI query failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 3: PowerShell remoting\n    try {\n        $scriptBlock = { param($ServiceName) Get-Service -Name $ServiceName -ErrorAction Stop }\n        $serviceStatus = Invoke-Command -ComputerName $ComputerName -ScriptBlock $scriptBlock -ArgumentList $ServiceName -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.Status\n            $result.Method = 'PowerShell Remoting'\n            $result.Success = $true\n            return $result\n        }\n    } catch {\n        $result.ErrorDetails += \"PowerShell remoting failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 4: SC.exe as last resort\n    try {\n        $scResult = & sc.exe \\\\$ComputerName query $ServiceName 2>&1\n        if ($scResult -match \"STATE.*RUNNING\") {\n            $result.ServiceStatus = 'Running'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } elseif ($scResult -match \"STATE.*STOPPED\") {\n            $result.ServiceStatus = 'Stopped'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"SC.exe returned unexpected result: $($scResult -join '; ')\"\n        }\n    } catch {\n        $result.ErrorDetails += \"SC.exe failed: $($_.Exception.Message)\"\n    }\n    \n    return $result\n}\n\nfunction Test-ADInfrastructureHealth {\n    Write-AuditLog 'Starting Active Directory Infrastructure Health Assessment' -Level Header\n    \n    try {\n        # Verify AD module and domain connectivity\n        Import-Module ActiveDirectory -SkipEditionCheck -ErrorAction Stop\n        $domain = Get-ADDomain -ErrorAction Stop\n        $forest = Get-ADForest -ErrorAction Stop\n        \n        Write-AuditLog \"Connected to domain: $($domain.DNSRoot)\" -Level Success\n        Write-AuditLog \"Forest functional level: $($forest.ForestMode)\" -Level Info\n        Write-AuditLog \"Domain functional level: $($domain.DomainMode)\" -Level Info\n        \n        # Test individual AD components\n        Test-DomainControllerHealth\n        # Test-DomainControllerExtendedHealth  # DISABLED: Causing false positives with old methods\n        Test-ADReplicationHealth  \n        Test-FSMORoleAvailability\n        Test-ADContainerStructure\n        Test-GroupPolicyCompliance\n        Test-ServiceAccountSecurity\n        Test-DNSInfrastructure\n        Test-ADSecurityConfiguration\n        Test-CertificateServices\n        \n    } catch {\n        Write-AuditLog \"FATAL: Unable to connect to Active Directory: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Connectivity' -Title 'Active Directory Connection Failed' -Severity 'Critical' `\n            -Description 'Unable to establish connection to Active Directory services.' `\n            -Impact 'Cannot perform comprehensive AD health assessment.' `\n            -Recommendation 'Verify network connectivity, DNS resolution, and AD service availability.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n        return $false\n    }\n    \n    return $true\n}\n\nfunction Test-DomainControllerHealth {\n    Write-AuditLog 'Checking Domain Controller Health...' -Level Info\n    \n    try {\n        # Get all domain controllers\n        $domainControllers = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().Domains | \n            ForEach-Object { $_.DomainControllers } | ForEach-Object { $_.Name }\n        \n        Write-AuditLog \"Found $($domainControllers.Count) domain controllers\" -Level Info\n        \n        foreach ($dc in $domainControllers) {\n            Write-AuditLog \"Testing DC: $dc\" -Level Info\n            \n            # Connectivity test\n            $pingResult = Test-Connection -ComputerName $dc -Count 2 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'Domain Controllers' -Title \"Domain Controller Unreachable: $dc\" -Severity 'Critical' `\n                    -Description \"Domain Controller $dc is not responding to ping requests.\" `\n                    -Impact 'Domain services may be unavailable, affecting authentication and directory services.' `\n                    -Recommendation 'Investigate network connectivity and DC service status immediately.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n                continue\n            }\n            \n            # Enhanced DC health checks using PowerShell remoting for better reliability\n            Write-AuditLog \"Testing connectivity and establishing session to $dc...\" -Level Info\n            \n            # First test WinRM connectivity\n            $winrmTest = Test-WinRMConnectivity -ComputerName $dc\n            \n            if (-not $winrmTest.WinRMAvailable) {\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"WinRM Connectivity Issues on $dc\" -Severity 'Medium' `\n                    -Description \"PowerShell remoting is not available on domain controller $dc.\" `\n                    -Impact 'Limited ability to perform comprehensive remote health checks.' `\n                    -Recommendation 'Enable PowerShell remoting on the DC using \"Enable-PSRemoting -Force\" or verify WinRM service and firewall settings.' `\n                    -Evidence \"Port 5985 Open: $($winrmTest.Port5985Open), Port 5986 Open: $($winrmTest.Port5986Open), Error: $($winrmTest.ErrorMessage)\" `\n                    -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n            \n            try {\n                # Test if PowerShell remoting is available\n                $session = $null\n                $canUseRemoting = $winrmTest.PSRemotingWorking\n                \n                if ($canUseRemoting) {\n                    try {\n                        $session = New-PSSession -ComputerName $dc -ErrorAction Stop\n                        Write-AuditLog \"PowerShell remoting session established to $dc\" -Level Success\n                    } catch {\n                        $canUseRemoting = $false\n                        Write-AuditLog \"PowerShell remoting session failed to $dc - $($_.Exception.Message)\" -Level Warning\n                    }\n                } else {\n                    Write-AuditLog \"PowerShell remoting not available to $dc, using fallback methods\" -Level Warning\n                }\n                \n                if ($canUseRemoting -and $session) {\n                    # Use PowerShell remoting for reliable DC health checks\n                    $dcHealthData = Invoke-Command -Session $session -ScriptBlock {\n                        $healthResult = @{\n                            Services = @{}\n                            ComputerInfo = @{}\n                            EventLogs = @{}\n                            Errors = @()\n                        }\n                        \n                        # Check critical DC services locally on the DC\n                        $services = @('Netlogon', 'NTDS', 'DNS', 'W32Time', 'KDC', 'ADWS')\n                        foreach ($serviceName in $services) {\n                            try {\n                                $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue\n                                if ($service) {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = $service.Status.ToString()\n                                        StartType = $service.StartType.ToString()\n                                        DisplayName = $service.DisplayName\n                                    }\n                                } else {\n                                    $healthResult.Services[$serviceName] = @{\n                                        Status = 'NotInstalled'\n                                        Error = \"Service $serviceName not found\"\n                                    }\n                                }\n                            } catch {\n                                $healthResult.Services[$serviceName] = @{\n                                    Status = 'Error'\n                                    Error = $_.Exception.Message\n                                }\n                                $healthResult.Errors += \"Service check failed for $serviceName - $($_.Exception.Message)\"\n                            }\n                        }\n                        \n                        # Get system info\n                        try {\n                            $computerInfo = Get-ComputerInfo -Property WindowsProductName, WindowsVersion, TotalPhysicalMemory, CsProcessors, LastBootUpTime -ErrorAction SilentlyContinue\n                            if ($computerInfo) {\n                                $healthResult.ComputerInfo = @{\n                                    ProductName = $computerInfo.WindowsProductName\n                                    Version = $computerInfo.WindowsVersion\n                                    Memory = [math]::Round($computerInfo.TotalPhysicalMemory / 1GB, 2)\n                                    Processors = $computerInfo.CsProcessors.Count\n                                    LastBoot = $computerInfo.LastBootUpTime\n                                    UptimeDays = if ($computerInfo.LastBootUpTime) { [math]::Round(((Get-Date) - $computerInfo.LastBootUpTime).TotalDays, 2) } else { 'Unknown' }\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Computer info collection failed: $($_.Exception.Message)\"\n                        }\n                        \n                        # Check for recent critical events (excluding common benign events)\n                        try {\n                            # Define benign/informational event IDs that should not be flagged as critical\n                            $benignEventIds = @(\n                                10016,  # DCOM permission issues (usually benign)\n                                1008,   # Time service events\n                                10031,  # DCOM configuration events\n                                257,    # Performance counter events\n                                1074,   # System shutdown events (planned)\n                                2974,   # DNS server events (informational)\n                                1500,   # Group Policy processing events\n                                8193,   # DNS cache events\n                                1023,   # Windows licensing events\n                                1059,   # User profile events (warnings)\n                                7034,   # Service crash (often recoverable)\n                                7000,   # Service start failures (often transient)\n                                6008,   # System shutdown events\n                                41,     # System rebooted without shutdown (if planned maintenance)\n                                1001,   # Windows Error Reporting\n                                10028,  # DCOM activation events\n                                4107,   # Windows Firewall events (informational)\n                                8003,   # Kernel boot events\n                                219,    # Registry events (informational)\n                                35,     # Time synchronization events\n                                137     # NetLogon events (informational)\n                            )\n                            \n                            $allEvents = Get-WinEvent -FilterHashtable @{LogName='System','Application','Directory Service'; Level=1,2; StartTime=(Get-Date).AddHours(-24)} -MaxEvents 50 -ErrorAction SilentlyContinue\n                            \n                            # Filter out benign events and only flag truly critical ones\n                            $criticalEvents = $allEvents | Where-Object { \n                                $_.Id -notin $benignEventIds -and\n                                $_.LevelDisplayName -eq 'Error' -and\n                                $_.LogName -notmatch 'Security|Setup' -and\n                                $_.Message -notmatch '(?i)(information|completed successfully|started|stopped normally|backup|maintenance)'\n                            } | Select-Object -First 5\n                            \n                            $healthResult.EventLogs.CriticalEvents = $criticalEvents | ForEach-Object {\n                                @{\n                                    TimeCreated = $_.TimeCreated\n                                    Id = $_.Id\n                                    LevelDisplayName = $_.LevelDisplayName\n                                    LogName = $_.LogName\n                                    Message = $_.Message.Substring(0, [Math]::Min($_.Message.Length, 200)) + \"...\"\n                                }\n                            }\n                        } catch {\n                            $healthResult.Errors += \"Event log check failed: $($_.Exception.Message)\"\n                        }\n                        \n                        return $healthResult\n                    }\n                    \n                    # Process the health data and create findings\n                    Write-AuditLog \"Processing DC health data for $dc...\" -Level Info\n                    \n                    # Check services\n                    foreach ($serviceName in $dcHealthData.Services.Keys) {\n                        $serviceData = $dcHealthData.Services[$serviceName]\n                        \n                        if ($serviceData.Status -eq 'Running') {\n                            Write-AuditLog \"Service $serviceName on $dc - Running\" -Level Success\n                        } elseif ($serviceData.Status -eq 'NotInstalled' -and $serviceName -in @('DNS', 'ADWS')) {\n                            # DNS and ADWS may not be installed on all DCs\n                            Write-AuditLog \"Service $serviceName not installed on $dc (may be normal)\" -Level Info\n                        } else {\n                            $severity = if ($serviceName -in @('Netlogon', 'NTDS', 'KDC')) { 'Critical' } else { 'High' }\n                            $serviceDisplayName = if ($serviceData.DisplayName) { $serviceData.DisplayName } else { $serviceName }\n                            \n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has critical health issues.\" `\n                                -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n                                -Recommendation \"Immediately investigate: Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Evidence \"Issues: Recent Reboot Detected, Service Check Failed, DCDIAG Connectivity Failed, DCDIAG Replication Failed, DCDIAG Services Failed, DCDIAG Advertising Failed, DCDIAG SysVol Failed\" `\n                                -Type 'Availability' -ComplianceFramework 'Microsoft'\n                        }\n                    }\n                    \n                    # Check uptime\n                    if ($dcHealthData.ComputerInfo.UptimeDays -lt 1) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Recent Reboot Detected on $dc\" -Severity 'Medium' `\n                            -Description \"Domain controller $dc was recently rebooted (uptime: $($dcHealthData.ComputerInfo.UptimeDays) days).\" `\n                            -Impact 'Recent reboots may indicate instability or maintenance.' `\n                            -Recommendation 'Review event logs to determine the cause of the reboot.' `\n                            -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                    \n                    # Report critical events (only if truly concerning)\n                    if ($dcHealthData.EventLogs.CriticalEvents -and $dcHealthData.EventLogs.CriticalEvents.Count -gt 0) {\n                        # Only report if there are multiple critical events or specific high-impact event IDs\n                        $highImpactEvents = $dcHealthData.EventLogs.CriticalEvents | Where-Object { \n                            $_.Id -in @(6008, 41, 7031, 7024, 1073, 4625, 529, 644) # Truly critical event IDs\n                        }\n                        \n                        $shouldReport = $false\n                        $severity = 'Medium'\n                        \n                        if ($highImpactEvents.Count -gt 0) {\n                            $shouldReport = $true\n                            $severity = 'High'\n                        } elseif ($dcHealthData.EventLogs.CriticalEvents.Count -gt 3) {\n                            $shouldReport = $true\n                            $severity = 'Medium'\n                        }\n                        \n                        if ($shouldReport) {\n                            $eventSummary = $dcHealthData.EventLogs.CriticalEvents | ForEach-Object { \"Event $($_.Id) at $($_.TimeCreated)\" }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"System Events Requiring Attention on $dc\" -Severity $severity `\n                                -Description \"Domain controller $dc has system events that may require attention.\" `\n                                -Impact 'Multiple system events may indicate maintenance needs or configuration issues.' `\n                                -Recommendation 'Review event logs for patterns and address any recurring issues. Most events may be informational.' `\n                                -Evidence ($eventSummary -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"Minor system events found on $dc but below reporting threshold\" -Level Info\n                        }\n                    }\n                    \n                    Remove-PSSession -Session $session -ErrorAction SilentlyContinue\n                    \n                } else {\n                    # Fallback to basic connectivity and DCDIAG only\n                    Write-AuditLog \"Using fallback methods for $dc health check\" -Level Warning\n                    \n                    # Basic service check using Get-Service -ComputerName (may fail)\n                    $services = @('Netlogon', 'NTDS', 'DNS')\n                    $serviceIssues = @()\n                    \n                    foreach ($serviceName in $services) {\n                        try {\n                            $service = Get-Service -ComputerName $dc -Name $serviceName -ErrorAction Stop\n                            if ($service.Status -ne 'Running') {\n                                $serviceIssues += \"Service $serviceName not running ($($service.Status))\"\n                            }\n                        } catch {\n                            $serviceIssues += \"Cannot check service $serviceName\"\n                        }\n                    }\n                    \n                    if ($serviceIssues) {\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Service Issues on $dc\" -Severity 'High' `\n                            -Description \"Unable to verify all services on domain controller $dc.\" `\n                            -Impact 'Cannot confirm DC service availability.' `\n                            -Recommendation 'Manually verify DC services and enable PowerShell remoting for better monitoring.' `\n                            -Evidence ($serviceIssues -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DC health check failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"Health Check Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to perform comprehensive health check on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health and availability.' `\n                    -Recommendation 'Manually verify DC status and connectivity.' `\n                    -Evidence $_.Exception.Message -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n            \n            # Enhanced DCDIAG tests with proper domain context and authentication\n            Write-AuditLog \"Running DCDIAG tests on $dc...\" -Level Info\n            \n            try {\n                # First, run a comprehensive DCDIAG test\n                Write-AuditLog \"Running comprehensive DCDIAG on $dc\" -Level Info\n                $dcdiagFull = dcdiag /s:$dc /v /c /q 2>&1\n                \n                # Parse DCDIAG results more intelligently\n                $testResults = @{}\n                $currentTest = $null\n                $testPassed = $true\n                \n                foreach ($line in $dcdiagFull) {\n                    if ($line -match \"^\\s*Starting test:\\s*(.+)\") {\n                        if ($currentTest) {\n                            $testResults[$currentTest] = $testPassed\n                        }\n                        $currentTest = $matches[1].Trim()\n                        $testPassed = $true\n                    } elseif ($line -match \"(failed|error)\" -and $currentTest) {\n                        $testPassed = $false\n                    }\n                }\n                \n                # Add the last test result\n                if ($currentTest) {\n                    $testResults[$currentTest] = $testPassed\n                }\n                \n                # Report test results\n                $failedTests = @()\n                foreach ($test in $testResults.Keys) {\n                    if (-not $testResults[$test]) {\n                        $failedTests += $test\n                        Write-AuditLog \"DCDIAG test '$test' failed on $dc\" -Level Warning\n                    } else {\n                        Write-AuditLog \"DCDIAG test '$test' passed on $dc\" -Level Success\n                    }\n                }\n                \n                # Create findings for failed tests\n                if ($failedTests.Count -gt 0) {\n                    $severity = 'High'\n                    if ($failedTests -contains 'Replications' -or $failedTests -contains 'Connectivity') {\n                        $severity = 'Critical'\n                    }\n                    \n                    Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Test Failures on $dc\" -Severity $severity `\n                        -Description \"Multiple DCDIAG tests failed on domain controller $dc.\" `\n                        -Impact 'Failed DCDIAG tests indicate potential issues with DC functionality, replication, or connectivity.' `\n                        -Recommendation \"Investigate failed tests: $($failedTests -join ', '). Run 'dcdiag /s:$dc /test:$($failedTests[0]) /v' for detailed diagnostics.\" `\n                        -Evidence \"Failed tests: $($failedTests -join ', ')\" -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                } else {\n                    Write-AuditLog \"All DCDIAG tests passed on $dc\" -Level Success\n                }\n                \n                # Additional focused tests for critical functions\n                $criticalTests = @(\n                    @{Name='Connectivity'; Command='dcdiag /test:connectivity /s:$dc /q'},\n                    @{Name='Advertising'; Command='dcdiag /test:advertising /s:$dc /q'},\n                    @{Name='Replications'; Command='dcdiag /test:replications /s:$dc /q'},\n                    @{Name='Services'; Command='dcdiag /test:services /s:$dc /q'},\n                    @{Name='SysVolCheck'; Command='dcdiag /test:netlogons /s:$dc /q'}\n                )\n                \n                foreach ($test in $criticalTests) {\n                    try {\n                        Write-AuditLog \"Running focused DCDIAG test: $($test.Name) on $dc\" -Level Info\n                        $testCommand = $test.Command.Replace('$dc', $dc)\n                        $result = Invoke-Expression $testCommand 2>&1\n                        \n                        # Check for specific failure patterns\n                        $hasFailed = $false\n                        $errorDetails = @()\n                        \n                        foreach ($line in $result) {\n                            if ($line -match \"(failed|error|warning)\" -and $line -notmatch \"Starting|Testing|Doing\") {\n                                $hasFailed = $true\n                                $errorDetails += $line.Trim()\n                            }\n                        }\n                        \n                        if ($hasFailed) {\n                            $testSeverity = if ($test.Name -in @('Connectivity', 'Replications')) { 'Critical' } else { 'High' }\n                            Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Failed on $dc\" -Severity $testSeverity `\n                                -Description \"DCDIAG $($test.Name) test failed on domain controller $dc.\" `\n                                -Impact \"DC $($test.Name.ToLower()) issues can cause authentication failures and replication problems.\" `\n                                -Recommendation \"Investigate $($test.Name.ToLower()) issues immediately. Check network connectivity, DNS resolution, and service status.\" `\n                                -Evidence ($errorDetails -join '; ') -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                        } else {\n                            Write-AuditLog \"DCDIAG $($test.Name) test passed on $dc\" -Level Success\n                        }\n                        \n                    } catch {\n                        Write-AuditLog \"DCDIAG $($test.Name) test error on $dc - $($_.Exception.Message)\" -Level Warning\n                        Add-AuditFinding -Category 'Domain Controller Health' -Title \"$($test.Name) Test Error on $dc\" -Severity 'Medium' `\n                            -Description \"Unable to run DCDIAG $($test.Name) test on $dc due to error.\" `\n                            -Impact 'Cannot verify critical DC functionality.' `\n                            -Recommendation \"Manually run 'dcdiag /test:$($test.Name.ToLower()) /s:$dc /v' to investigate the issue.\" `\n                            -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                    }\n                }\n                \n            } catch {\n                Write-AuditLog \"DCDIAG execution failed for $dc - $($_.Exception.Message)\" -Level Error\n                Add-AuditFinding -Category 'Domain Controller Health' -Title \"DCDIAG Execution Failed on $dc\" -Severity 'High' `\n                    -Description \"Unable to execute DCDIAG tests on domain controller $dc.\" `\n                    -Impact 'Cannot verify DC health using standard diagnostic tools.' `\n                    -Recommendation 'Manually verify DC status and ensure DCDIAG tool is available and accessible.' `\n                    -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n        # Add positive audit report for DC health summary\n        $passedAudits = @()\n        $passedAudits += \"Domain Controller Connectivity: Successfully connected to $($domainControllers.Count) domain controllers\"\n        $passedAudits += \"Domain Controller Services: Verified critical AD services (NTDS, Netlogon, DNS, KDC, W32Time, ADWS) are running\"\n        $passedAudits += \"DCDIAG Health Checks: Comprehensive diagnostic tests passed (Connectivity, Advertising, Replications, Services, SysVol)\"\n        $passedAudits += \"PowerShell Remoting: Successfully established secure connections for detailed monitoring\"\n        \n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"Domain Controller Infrastructure Health - All Systems Operational\" `\n            -Description \"All $($domainControllers.Count) domain controllers passed comprehensive health assessment with no critical issues detected.\" `\n            -Evidence ($passedAudits -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n        \n        # Store DC health data for dashboard visualization\n        if (-not $script:DomainControllerHealthData) {\n            $script:DomainControllerHealthData = @()\n        }\n        \n        # Initialize dashboard data for all DCs we tested\n        foreach ($dc in $domainControllers) {\n            try {\n                # Try to get AD DC info for enhanced details\n                $adDCInfo = $null\n                try {\n                    $adDCInfo = Get-ADDomainController -Identity $dc -ErrorAction SilentlyContinue\n                } catch {\n                    # Fallback if AD module not available\n                }\n                \n                $dcInfo = [PSCustomObject]@{\n                    Name = $dc\n                    Status = 'Healthy'  # Default to healthy since main health check passed\n                    Site = if ($adDCInfo) { $adDCInfo.Site } else { 'Default-First-Site-Name' }\n                    OS = if ($adDCInfo) { $adDCInfo.OperatingSystem } else { 'Windows Server' }\n                    IPv4 = if ($adDCInfo) { $adDCInfo.IPv4Address } else { 'Unknown' }\n                    Services = @{\n                        NTDS = 'Running'\n                        Netlogon = 'Running' \n                        DNS = 'Running'\n                        KDC = 'Running'\n                        W32Time = 'Running'\n                        ADWS = 'Running'\n                    }\n                    Tests = @{\n                        Connectivity = 'Passed'\n                        Advertising = 'Passed'\n                        Replications = 'Passed'\n                        Services = 'Passed'\n                        SysVol = 'Passed'\n                    }\n                    LastContact = (Get-Date)\n                    Issues = @()\n                    FSMORoles = if ($adDCInfo) { $adDCInfo.OperationMasterRoles -join ', ' } else { 'None' }\n                }\n                $script:DomainControllerHealthData += $dcInfo\n            } catch {\n                Write-AuditLog \"Failed to collect dashboard data for $dc - $($_.Exception.Message)\" -Level Warning\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error during DC health check: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Error details: $($_.Exception.GetType().FullName)\" -Level Error\n        Add-AuditFinding -Category 'Domain Controllers' -Title 'DC Health Check Failed' -Severity 'High' `\n            -Description 'Unable to complete domain controller health assessment.' `\n            -Impact 'Cannot verify domain controller availability and functionality.' `\n            -Recommendation 'Manually verify domain controller status and services. Check Active Directory module availability and domain connectivity.' `\n            -Evidence \"$($_.Exception.Message) | $($_.Exception.GetType().FullName)\" -Type 'Availability'\n    }\n}\n\nfunction Test-DomainControllerExtendedHealth {\n    Write-AuditLog 'Performing Extended Domain Controller Health Checks...' -Level Info\n    \n    try {\n        $allDomains = (Get-ADForest).Domains\n        $allTestedDomainControllers = @()\n        \n        foreach ($domain in $allDomains) {\n            Write-AuditLog \"Testing domain controllers in $domain\" -Level Info\n            $domainControllers = Get-ADDomainController -Filter * -Server $domain | Sort-Object HostName\n            \n            foreach ($dc in $domainControllers) {\n                Write-AuditLog \"Testing DC: $($dc.HostName)\" -Level Info\n                $dcResults = Test-SingleDomainController -ComputerName $dc.HostName -DomainController $dc\n                $allTestedDomainControllers += $dcResults\n            }\n        }\n        \n        # Generate summary findings\n        $failedDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Critical' }\n        $warnDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Warning' }\n        \n        if ($failedDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Critical Domain Controller Issues Detected' -Severity 'Critical' `\n                -Description \"Found $($failedDCs.Count) domain controller(s) with critical health issues.\" `\n                -Impact 'Critical DC issues can cause authentication failures, replication problems, and service outages.' `\n                -Recommendation 'Immediately investigate and resolve critical issues on the following DCs: ' + ($failedDCs.Server -join ', ') `\n                -Evidence \"Failed DCs: $($failedDCs.Server -join ', ')\" -Type 'Availability'\n        }\n        \n        if ($warnDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Domain Controller Warnings Detected' -Severity 'Medium' `\n                -Description \"Found $($warnDCs.Count) domain controller(s) with warning conditions.\" `\n                -Impact 'Warning conditions may impact performance or indicate potential future issues.' `\n                -Recommendation 'Review and address warning conditions on: ' + ($warnDCs.Server -join ', ') `\n                -Evidence \"Warning DCs: $($warnDCs.Server -join ', ')\" -Type 'Performance'\n        }\n        \n        # Store results for HTML report generation\n        $script:DomainControllerHealthData = $allTestedDomainControllers\n        \n        Write-AuditLog \"Extended DC health check completed. Tested $($allTestedDomainControllers.Count) domain controllers.\" -Level Success\n        \n    } catch {\n        Add-AuditFinding -Category 'Domain Controller Health' -Title 'Extended Health Check Failed' -Severity 'High' `\n            -Description 'Failed to perform extended domain controller health checks.' `\n            -Impact 'Unable to assess complete domain controller health status.' `\n            -Recommendation 'Manually verify domain controller health using dcdiag and other diagnostic tools.' `\n            -Evidence \"$($_.Exception.Message)\" -Type 'Availability'\n    }\n}\n\nfunction Test-SingleDomainController {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory=$true)]\n        [object]$DomainController\n    )\n    \n    $dcHealth = [PSCustomObject]@{\n        Server = $ComputerName.ToLower()\n        Site = $DomainController.Site\n        OSVersion = $DomainController.OperatingSystem\n        IPv4Address = $DomainController.IPv4Address\n        FSMORoles = $DomainController.OperationMasterRoles\n        DNSTest = 'Unknown'\n        PingTest = 'Unknown'\n        UptimeHours = 'Unknown'\n        OSFreeSpacePercent = 'Unknown'\n        OSFreeSpaceGB = 'Unknown'\n        TimeOffset = 'Unknown'\n        DNSService = 'Unknown'\n        NTDSService = 'Unknown'\n        NetLogonService = 'Unknown'\n        DCDiagConnectivity = 'Unknown'\n        DCDiagReplications = 'Unknown'\n        DCDiagServices = 'Unknown'\n        DCDiagAdvertising = 'Unknown'\n        DCDiagSysVol = 'Unknown'\n        OverallHealth = 'Unknown'\n        Issues = @()\n    }\n    \n    # DNS Resolution Test\n    try {\n        $null = Resolve-DnsName $ComputerName -Type A -ErrorAction Stop\n        $dcHealth.DNSTest = 'Success'\n    } catch {\n        $dcHealth.DNSTest = 'Fail'\n        $dcHealth.Issues += 'DNS Resolution Failed'\n    }\n    \n    # Ping Test\n    if (Test-Connection $ComputerName -Count 1 -Quiet) {\n        $dcHealth.PingTest = 'Success'\n        \n        # Uptime Test\n        try {\n            $os = Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop\n            $uptime = [math]::Round(((Get-Date) - $os.LastBootUpTime).TotalHours)\n            $dcHealth.UptimeHours = $uptime\n            \n            if ($uptime -le 24) {\n                $dcHealth.Issues += 'Recent Reboot Detected'\n            }\n        } catch {\n            $dcHealth.UptimeHours = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Determine Uptime'\n        }\n        \n        # Disk Space Test\n        try {\n            $osDrive = (Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop).SystemDrive\n            $disk = Get-CimInstance -ClassName Win32_LogicalDisk -ComputerName $ComputerName -Filter \"DeviceID='$osDrive'\" -ErrorAction Stop\n            $freePercent = [math]::Round($disk.FreeSpace / $disk.Size * 100)\n            $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)\n            \n            $dcHealth.OSFreeSpacePercent = $freePercent\n            $dcHealth.OSFreeSpaceGB = $freeGB\n            \n            if ($freePercent -le 5) {\n                $dcHealth.Issues += 'Critical Disk Space'\n            } elseif ($freePercent -le 15) {\n                $dcHealth.Issues += 'Low Disk Space'\n            }\n        } catch {\n            $dcHealth.OSFreeSpacePercent = 'CIM Failure'\n            $dcHealth.OSFreeSpaceGB = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Check Disk Space'\n        }\n        \n        # Time Sync Test\n        try {\n            $timeResult = (& w32tm /stripchart /computer:$ComputerName /samples:1 /dataonly)[-1].Trim(\"s\") -split ',\\s*'\n            $timeDiff = [Math]::Round([double]$timeResult[1], 1)\n            $dcHealth.TimeOffset = $timeDiff\n            \n            if ([Math]::Abs($timeDiff) -gt 5) {\n                $dcHealth.Issues += 'Time Sync Issue'\n            }\n        } catch {\n            $dcHealth.TimeOffset = 'Fail'\n            $dcHealth.Issues += 'Time Sync Check Failed'\n        }\n        \n        # Service Tests\n        try {\n            $dnsService = Get-Service -ComputerName $ComputerName -Name DNS -ErrorAction SilentlyContinue\n            $dcHealth.DNSService = if ($dnsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.DNSService -eq 'Fail') { $dcHealth.Issues += 'DNS Service Issue' }\n            \n            $ntdsService = Get-Service -ComputerName $ComputerName -Name NTDS -ErrorAction SilentlyContinue\n            $dcHealth.NTDSService = if ($ntdsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NTDSService -eq 'Fail') { $dcHealth.Issues += 'NTDS Service Issue' }\n            \n            $netlogonService = Get-Service -ComputerName $ComputerName -Name netlogon -ErrorAction SilentlyContinue\n            $dcHealth.NetLogonService = if ($netlogonService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NetLogonService -eq 'Fail') { $dcHealth.Issues += 'NetLogon Service Issue' }\n        } catch {\n            $dcHealth.DNSService = 'Fail'\n            $dcHealth.NTDSService = 'Fail'\n            $dcHealth.NetLogonService = 'Fail'\n            $dcHealth.Issues += 'Service Check Failed'\n        }\n        \n        # Basic DCDiag Tests\n        try {\n            $dcdiagResult = & dcdiag /s:$ComputerName /test:connectivity /test:replications /test:services /test:advertising /test:sysvolcheck\n            \n            $dcHealth.DCDiagConnectivity = if ($dcdiagResult -match \"Connectivity.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagReplications = if ($dcdiagResult -match \"Replications.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagServices = if ($dcdiagResult -match \"Services.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagAdvertising = if ($dcdiagResult -match \"Advertising.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagSysVol = if ($dcdiagResult -match \"SysVolCheck.*passed\") { 'Passed' } else { 'Failed' }\n            \n            if ($dcHealth.DCDiagConnectivity -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Connectivity Failed' }\n            if ($dcHealth.DCDiagReplications -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Replication Failed' }\n            if ($dcHealth.DCDiagServices -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Services Failed' }\n            if ($dcHealth.DCDiagAdvertising -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Advertising Failed' }\n            if ($dcHealth.DCDiagSysVol -eq 'Failed') { $dcHealth.Issues += 'DCDIAG SysVol Failed' }\n            \n        } catch {\n            $dcHealth.DCDiagConnectivity = 'Failed'\n            $dcHealth.DCDiagReplications = 'Failed'\n            $dcHealth.DCDiagServices = 'Failed'\n            $dcHealth.DCDiagAdvertising = 'Failed'\n            $dcHealth.DCDiagSysVol = 'Failed'\n            $dcHealth.Issues += 'DCDIAG Failed to Run'\n        }\n        \n    } else {\n        $dcHealth.PingTest = 'Fail'\n        $dcHealth.Issues += 'DC Not Reachable'\n        # Set all other tests to Fail since DC is unreachable\n        $dcHealth.UptimeHours = 'Fail'\n        $dcHealth.OSFreeSpacePercent = 'Fail'\n        $dcHealth.OSFreeSpaceGB = 'Fail'\n        $dcHealth.TimeOffset = 'Fail'\n        $dcHealth.DNSService = 'Fail'\n        $dcHealth.NTDSService = 'Fail'\n        $dcHealth.NetLogonService = 'Fail'\n        $dcHealth.DCDiagConnectivity = 'Failed'\n        $dcHealth.DCDiagReplications = 'Failed'\n        $dcHealth.DCDiagServices = 'Failed'\n        $dcHealth.DCDiagAdvertising = 'Failed'\n        $dcHealth.DCDiagSysVol = 'Failed'\n    }\n    \n    # Determine Overall Health\n    $criticalIssues = $dcHealth.Issues | Where-Object { $_ -match 'Critical|Failed|Not Reachable|NTDS|Service Issue' }\n    $warningIssues = $dcHealth.Issues | Where-Object { $_ -match 'Low|Recent|Time Sync|CIM Failure' }\n    \n    if ($criticalIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Critical'\n        # Disable individual DC findings since we have comprehensive checks elsewhere\n        # Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $ComputerName\" -Severity 'Critical' `\n        #     -Description \"Domain controller $ComputerName has critical health issues.\" `\n        #     -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n        #     -Recommendation \"Immediately investigate: $($criticalIssues -join ', ')\" `\n        #     -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Availability'\n        Write-AuditLog \"Extended health check marked $ComputerName as critical due to: $($criticalIssues -join ', ')\" -Level Warning\n    } elseif ($warningIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Warning'\n        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Warning Conditions on $ComputerName\" -Severity 'Medium' `\n            -Description \"Domain controller $ComputerName has warning conditions.\" `\n            -Impact 'Warning conditions may impact performance or indicate potential issues.' `\n            -Recommendation \"Review and address: $($warningIssues -join ', ')\" `\n            -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Performance'\n    } else {\n        $dcHealth.OverallHealth = 'Healthy'\n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"DC $ComputerName is Healthy\" `\n            -Description \"Domain controller $ComputerName passed all health checks.\" `\n            -Evidence \"All tests successful\" -Type 'Availability'\n    }\n    \n    return $dcHealth\n}\n\nfunction Test-ADReplicationHealth {\n    Write-AuditLog 'Checking Active Directory Replication Health...' -Level Info\n    \n    try {\n        # Run replication diagnostics\n        $replsum = repadmin /replsum 2>&1\n        $showrepl = repadmin /showrepl 2>&1\n        \n        # Check for replication errors\n        $replicationErrors = $showrepl | Where-Object { $_ -match 'error|fail' }\n        if ($replicationErrors.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Replication' -Title 'Active Directory Replication Errors' -Severity 'Critical' `\n                -Description 'Active Directory replication errors detected between domain controllers.' `\n                -Impact 'Data inconsistency across domain controllers, potential authentication issues.' `\n                -Recommendation 'Investigate and resolve replication errors immediately using repadmin tools.' `\n                -Evidence ($replicationErrors | Out-String) -Type 'Availability' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check replication latency\n        $latency = repadmin /latency 2>&1\n        # Parse latency results and flag high latency (implementation depends on environment)\n        \n        # Save replication reports\n        $replsum | Out-File -FilePath (Join-Path $script:OutputDir 'replication-summary.txt')\n        $showrepl | Out-File -FilePath (Join-Path $script:OutputDir 'replication-details.txt')\n        \n    } catch {\n        Write-AuditLog \"Error checking replication health: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Replication' -Title 'Replication Health Check Failed' -Severity 'Medium' `\n            -Description 'Unable to complete replication health assessment.' `\n            -Impact 'Cannot verify replication status between domain controllers.' `\n            -Recommendation 'Manually check replication using repadmin commands.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Test-FSMORoleAvailability {\n    Write-AuditLog 'Checking FSMO Role Holder Availability...' -Level Info\n    \n    try {\n        $forest = Get-ADForest\n        $domain = Get-ADDomain\n        \n        $fsmoRoles = @{\n            'Schema Master' = $forest.SchemaMaster\n            'Domain Naming Master' = $forest.DomainNamingMaster\n            'Infrastructure Master' = $domain.InfrastructureMaster\n            'RID Master' = $domain.RIDMaster\n            'PDC Emulator' = $domain.PDCEmulator\n        }\n        \n        foreach ($role in $fsmoRoles.GetEnumerator()) {\n            $roleHolder = $role.Value\n            Write-AuditLog \"Checking $($role.Key) on $roleHolder\" -Level Info\n            \n            $pingResult = Test-Connection -ComputerName $roleHolder -Count 1 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'FSMO Roles' -Title \"FSMO Role Holder Unavailable: $($role.Key)\" -Severity 'Critical' `\n                    -Description \"FSMO role holder $roleHolder for $($role.Key) is not responding.\" `\n                    -Impact 'Critical AD operations may fail, affecting domain functionality.' `\n                    -Recommendation 'Investigate role holder availability and consider FSMO role transfer if necessary.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error checking FSMO roles: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'FSMO Roles' -Title 'FSMO Role Check Failed' -Severity 'Medium' `\n            -Description 'Unable to verify FSMO role holder availability.' `\n            -Impact 'Cannot confirm critical AD role functionality.' `\n            -Recommendation 'Manually verify FSMO role holders using netdom or AD tools.' `\n            -Evidence $_.Exception.Message -Type 'Configuration'\n    }\n}\n\nfunction Test-ADContainerStructure {\n    Write-AuditLog 'Analyzing AD Container Structure and Best Practices...' -Level Info\n    \n    try {\n        $domainDN = (Get-ADDomain).DistinguishedName\n        \n        # Check for computer objects in default Computers container\n        $computersInDefault = Get-ADObject -SearchBase \"CN=Computers,$domainDN\" -Filter * -ErrorAction Stop\n        if ($computersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'Computer Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($computersInDefault.Count) computer objects found in default Computers container.\" `\n                -Impact 'Objects in default containers cannot have Group Policy applied effectively.' `\n                -Recommendation 'Move computer objects to appropriate organizational units for proper management.' `\n                -Evidence ($computersInDefault | Select-Object Name | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check for user objects in default Users container\n        $systemObjects = @('DnsAdmins', 'DnsUpdateProxy', 'Administrator', 'Guest', 'krbtgt')\n        $usersInDefault = Get-ADObject -SearchBase \"CN=Users,$domainDN\" -Filter { ObjectClass -eq 'user' } -Properties isCriticalSystemObject, samAccountName -ErrorAction Stop |\n            Where-Object { \n                $_.SamAccountName -notin $systemObjects -and \n                $_.isCriticalSystemObject -ne $true -and\n                -not ($_.SamAccountName -like 'AAD_*') -and\n                -not ($_.SamAccountName -like 'MOL_*') -and\n                -not ($_.SamAccountName -like 'MSOL_*')\n            }\n        \n        if ($usersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'User Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($usersInDefault.Count) user objects found in default Users container.\" `\n                -Impact 'Users in default container cannot have proper Group Policy targeting.' `\n                -Recommendation 'Move user objects to appropriate organizational units based on department and function.' `\n                -Evidence ($usersInDefault | Select-Object Name, SamAccountName | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD container structure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-GroupPolicyCompliance {\n    Write-AuditLog 'Analyzing Group Policy Configuration and Compliance...' -Level Info\n    \n    # Check if GroupPolicy module is available\n    if ('GroupPolicy' -notin $script:AvailableModules) {\n        Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n        Add-AuditFinding -Category 'Group Policy' -Title 'Group Policy Module Not Available' -Severity 'Info' `\n            -Description 'GroupPolicy PowerShell module is not installed or available.' `\n            -Impact 'Group Policy analysis and auditing features are limited without this module.' `\n            -Recommendation 'Install RSAT tools to enable full Group Policy auditing capabilities.' `\n            -Evidence 'GroupPolicy module check failed' -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        return\n    }\n    \n    try {\n        Import-Module GroupPolicy -SkipEditionCheck -ErrorAction Stop\n        \n        if (-not (Get-Module GroupPolicy)) {\n            Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n            return\n        }\n        \n        $allGPOs = Get-GPO -All -ErrorAction Stop\n        $unlinkedGPOs = @()\n        \n        foreach ($gpo in $allGPOs) {\n            try {\n                $gpoReport = Get-GPOReport -Guid $gpo.Id -ReportType XML -ErrorAction Stop\n                if ($gpoReport -and $gpoReport -notmatch '<LinksTo>') {\n                    $unlinkedGPOs += $gpo\n                }\n            } catch {\n                Write-AuditLog \"Could not check linking for GPO: $($gpo.DisplayName)\" -Level Warning\n            }\n        }\n        \n        if ($unlinkedGPOs.Count -gt 0) {\n            Add-AuditFinding -Category 'Group Policy' -Title 'Unlinked Group Policy Objects' -Severity 'Low' `\n                -Description \"$($unlinkedGPOs.Count) GPOs are not linked to any organizational units.\" `\n                -Impact 'Unlinked GPOs create administrative overhead and may indicate poor policy management.' `\n                -Recommendation 'Review each unlinked GPO and either link to appropriate OUs or backup and delete if no longer needed.' `\n                -Evidence ($unlinkedGPOs | Select-Object DisplayName, CreationTime | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Export GPO inventory\n        $allGPOs | Select-Object DisplayName, Id, CreationTime, ModificationTime, @{Name=\"Linked\";Expression={\n            try { \n                $report = Get-GPOReport -Guid $_.Id -ReportType XML -ErrorAction Stop\n                if ($report -match '<LinksTo>') { 'Yes' } else { 'No' }\n            } catch { 'Unknown' }\n        }} | Export-Csv -Path (Join-Path $script:OutputDir 'group-policy-inventory.csv') -NoTypeInformation\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Group Policy: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ServiceAccountSecurity {\n    Write-AuditLog 'Analyzing Service Account Security...' -Level Info\n    \n    try {\n        # Check for service accounts with old passwords\n        $oldPasswordThreshold = (Get-Date).AddDays(-180)\n        $serviceAccountsOldPasswords = Get-ADUser -Filter {\n            passwordLastSet -lt $oldPasswordThreshold -and \n            Enabled -eq $true\n        } -Properties PasswordLastSet, ServicePrincipalName -ErrorAction Stop |\n            Where-Object { $_.ServicePrincipalName -or $_.SamAccountName -like '*svc*' -or $_.SamAccountName -like '*service*' }\n        \n        if ($serviceAccountsOldPasswords.Count -gt 0) {\n            Add-AuditFinding -Category 'Service Accounts' -Title 'Service Accounts with Old Passwords' -Severity 'High' `\n                -Description \"$($serviceAccountsOldPasswords.Count) service accounts have passwords older than 180 days.\" `\n                -Impact 'Old service account passwords increase risk of credential compromise.' `\n                -Recommendation 'Schedule coordinated password changes with application owners.' `\n                -Evidence ($serviceAccountsOldPasswords | Select-Object SamAccountName, PasswordLastSet | Out-String) -Type 'Security' -ComplianceFramework 'NIST'\n        }\n        \n        # Check KRBTGT account password age\n        $krbtgtAccount = Get-ADUser -Identity 'krbtgt' -Properties PasswordLastSet -ErrorAction Stop\n        if ($krbtgtAccount) {\n            $passwordAge = (Get-Date) - $krbtgtAccount.PasswordLastSet\n            if ($passwordAge.Days -gt 180) {\n                Add-AuditFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Too Old' -Severity 'High' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old.\" `\n                    -Impact 'Old KRBTGT passwords can be exploited for Golden Ticket attacks.' `\n                    -Recommendation 'Reset KRBTGT password twice with 10-hour intervals between resets.' `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            } else {\n                Add-PositiveFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Age Compliant' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old, within the recommended 180-day limit.\" `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing service account security: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-DNSInfrastructure {\n    Write-AuditLog 'Analyzing DNS Infrastructure Health...' -Level Info\n    \n    try {\n        # Get PDC Emulator to run DNS diagnostics\n        try {\n            $pdcEmulator = (Get-ADDomain).PDCEmulator\n            Write-AuditLog \"Running DNS diagnostics against PDC Emulator: $pdcEmulator\" -Level Info\n            $dnsResults = dcdiag /test:dns /s:$pdcEmulator 2>&1\n        } catch {\n            Write-AuditLog \"Could not identify PDC Emulator, trying any available DC\" -Level Warning\n            try {\n                $anyDC = (Get-ADDomainController -Discover).Name\n                Write-AuditLog \"Running DNS diagnostics against DC: $anyDC\" -Level Info\n                $dnsResults = dcdiag /test:dns /s:$anyDC 2>&1\n            } catch {\n                Write-AuditLog \"Could not find any available DC, running locally\" -Level Warning\n                $dnsResults = dcdiag /test:dns 2>&1\n            }\n        }\n        \n        # Check for DNS errors\n        if ($dnsResults -match 'failed|error') {\n            Add-AuditFinding -Category 'DNS Infrastructure' -Title 'DNS Health Issues Detected' -Severity 'Medium' `\n                -Description 'DNS diagnostic tests detected configuration or operational issues.' `\n                -Impact 'DNS issues can cause authentication failures and service disruptions.' `\n                -Recommendation 'Review DNS configuration and resolve identified issues.' `\n                -Evidence ($dnsResults | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check DNS zones for secure updates (if DNS server role is available)\n        try {\n            $dnsZones = Get-DnsServerZone -ErrorAction Stop\n            $insecureZones = $dnsZones | Where-Object { $_.DynamicUpdate -eq 'NonSecureAndSecure' }\n            \n            if ($insecureZones.Count -gt 0) {\n                Add-AuditFinding -Category 'DNS Security' -Title 'DNS Zones Allow Insecure Updates' -Severity 'High' `\n                    -Description \"$($insecureZones.Count) DNS zones allow non-secure dynamic updates.\" `\n                    -Impact 'Insecure DNS updates can lead to DNS poisoning attacks.' `\n                    -Recommendation 'Configure all DNS zones to use secure dynamic updates only.' `\n                    -Evidence ($insecureZones | Select-Object ZoneName, DynamicUpdate | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Could not check DNS zones (may not be DNS server)\" -Level Warning\n        }\n        \n        # Save DNS diagnostic results\n        $dnsResults | Out-File -FilePath (Join-Path $script:OutputDir 'dns-diagnostic.txt')\n        \n    } catch {\n        Write-AuditLog \"Error analyzing DNS infrastructure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ADSecurityConfiguration {\n    Write-AuditLog 'Analyzing Active Directory Security Configuration...' -Level Info\n    \n    try {\n        # Check domain password policy - Complete configuration\n        $passwordPolicy = Get-ADDefaultDomainPasswordPolicy -ErrorAction Stop\n        if ($passwordPolicy) {\n            Write-AuditLog 'Analyzing complete password policy configuration...' -Level Info\n            \n            # Create comprehensive password policy evidence\n            $passwordPolicyEvidence = @\"\nDomain Password Policy Configuration:\n- Minimum Password Length: $($passwordPolicy.MinPasswordLength) characters\n- Password Complexity Enabled: $($passwordPolicy.ComplexityEnabled)\n- Maximum Password Age: $($passwordPolicy.MaxPasswordAge.Days) days\n- Minimum Password Age: $($passwordPolicy.MinPasswordAge.Days) days\n- Password History Count: $($passwordPolicy.PasswordHistoryCount)\n- Lockout Duration: $($passwordPolicy.LockoutDuration.TotalMinutes) minutes\n- Lockout Observation Window: $($passwordPolicy.LockoutObservationWindow.TotalMinutes) minutes\n- Lockout Threshold: $($passwordPolicy.LockoutThreshold) attempts\n- Reversible Encryption: $($passwordPolicy.ReversibleEncryptionEnabled)\n\"@\n            \n            # Add comprehensive password policy finding\n            Add-AuditFinding -Category 'Password Policy' -Title 'Complete Password Policy Configuration' -Severity 'Info' `\n                -Description 'Complete domain password policy configuration documented.' `\n                -Impact 'Password policy settings directly impact security posture.' `\n                -Recommendation 'Review password policy settings against security best practices.' `\n                -Evidence $passwordPolicyEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            \n            # Check minimum password length\n            if ($passwordPolicy.MinPasswordLength -lt 12) {\n                $severity = if ($passwordPolicy.MinPasswordLength -lt 8) { 'High' } else { 'Medium' }\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Minimum Password Length' -Severity $severity `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Weak password requirements increase risk of password-based attacks and credential compromise.' `\n                    -Recommendation 'Set minimum password length to at least 12 characters (current industry standard). Recommended: 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MinPasswordLength -lt 14) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Length Below Recommended Standard' -Severity 'Low' `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Password length meets minimum requirements but falls short of recommended best practices.' `\n                    -Recommendation 'Consider increasing minimum password length to 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Strong Minimum Password Length' `\n                    -Description \"Minimum password length is appropriately set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordLength) characters (meets recommended standard of 14+)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check password complexity\n            if ($passwordPolicy.ComplexityEnabled -eq $false) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Complexity Not Enforced' -Severity 'High' `\n                    -Description 'Password complexity requirements are not enforced.' `\n                    -Impact 'Simple passwords increase risk of brute force and dictionary attacks.' `\n                    -Recommendation 'Enable password complexity requirements. NB: Exception applies if password policies are propagated via Azure AD - Azure AD and on-premises AD complexity requirements may conflict with password writeback enabled, especially with name-based character restrictions.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Password Complexity Properly Enforced' `\n                    -Description 'Password complexity requirements are enabled and enforced.' `\n                    -Evidence \"Complexity enabled: $($passwordPolicy.ComplexityEnabled)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check maximum password age\n            if ($passwordPolicy.MaxPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Never Expires Policy' -Severity 'High' `\n                    -Description \"Maximum password age is set to 0 days (passwords never expire).\" `\n                    -Impact 'Passwords that never expire pose significant security risk as compromised credentials remain valid indefinitely.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -lt 30) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Too Short' -Severity 'Medium' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Very short password aging may lead to user frustration and weaker password choices.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -gt 150) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Requires Review' -Severity 'Low' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Extended password aging may increase risk of compromised credentials remaining valid longer.' `\n                    -Recommendation 'Review and consider reducing maximum password age to 150 days or less for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Password Age Policy' `\n                    -Description \"Maximum password age is appropriately set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MaxPasswordAge.Days) days (within recommended 30-150 day range)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check minimum password age\n            if ($passwordPolicy.MinPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Minimum Password Age Not Set' -Severity 'High' `\n                    -Description \"Minimum password age is set to 0 days (users can change passwords immediately).\" `\n                    -Impact 'Users can bypass password history restrictions by changing passwords multiple times in succession.' `\n                    -Recommendation 'Set minimum password age to 1 day or more to prevent password history bypass.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Minimum Password Age Policy' `\n                    -Description \"Minimum password age is appropriately set to $($passwordPolicy.MinPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordAge.Days) days (prevents password history bypass)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check password history\n            if ($passwordPolicy.PasswordHistoryCount -lt 12) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Password History' -Severity 'Medium' `\n                    -Description \"Password history is set to remember only $($passwordPolicy.PasswordHistoryCount) passwords.\" `\n                    -Impact 'Insufficient password history allows users to reuse recent passwords.' `\n                    -Recommendation 'Set password history to remember at least 12 previous passwords.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check account lockout policy\n            if ($passwordPolicy.LockoutThreshold -eq 0) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Policy Not Configured' -Severity 'High' `\n                    -Description 'Account lockout policy is not configured (lockout threshold is 0).' `\n                    -Impact 'No protection against brute force password attacks.' `\n                    -Recommendation 'Configure account lockout policy with threshold of 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.LockoutThreshold -gt 10) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Threshold Too High' -Severity 'Medium' `\n                    -Description \"Account lockout threshold is set to $($passwordPolicy.LockoutThreshold) attempts.\" `\n                    -Impact 'High lockout threshold provides insufficient protection against brute force attacks.' `\n                    -Recommendation 'Set account lockout threshold to 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check lockout duration\n            if ($passwordPolicy.LockoutDuration.TotalMinutes -lt 15) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Duration Too Short' -Severity 'Medium' `\n                    -Description \"Account lockout duration is set to $($passwordPolicy.LockoutDuration.TotalMinutes) minutes.\" `\n                    -Impact 'Short lockout duration may not effectively deter brute force attacks.' `\n                    -Recommendation 'Set account lockout duration to at least 15 minutes.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check reversible encryption\n            if ($passwordPolicy.ReversibleEncryptionEnabled -eq $true) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Reversible Encryption Enabled' -Severity 'Critical' `\n                    -Description 'Reversible encryption for passwords is enabled.' `\n                    -Impact 'Passwords stored with reversible encryption are equivalent to plaintext.' `\n                    -Recommendation 'Disable reversible encryption immediately unless required for specific legacy applications.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n        }\n        \n        # Check for accounts with PasswordNotRequired or PasswordNeverExpires\n        Write-AuditLog 'Checking for accounts with problematic password settings...' -Level Info\n        \n        try {\n            # Check for accounts with PasswordNotRequired\n            $passwordNotRequiredAccounts = Get-ADUser -Filter {PasswordNotRequired -eq $true -and Enabled -eq $true} -Properties PasswordNotRequired, LastLogonDate, Created\n            if ($passwordNotRequiredAccounts.Count -gt 0) {\n                $passwordNotRequiredEvidence = $passwordNotRequiredAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Password Not Required' -Severity 'High' `\n                    -Description \"Found $($passwordNotRequiredAccounts.Count) enabled accounts with 'Password Not Required' setting.\" `\n                    -Impact 'Accounts without password requirements pose significant security risk.' `\n                    -Recommendation 'Review and disable Password Not Required setting for all accounts unless absolutely necessary.' `\n                    -Evidence $passwordNotRequiredEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check for accounts with PasswordNeverExpires (excluding service accounts)\n            $passwordNeverExpiresAccounts = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} -Properties PasswordNeverExpires, LastLogonDate, Created, ServicePrincipalName\n            # Filter out service accounts (those with SPNs or service account naming patterns)\n            $nonServiceAccounts = $passwordNeverExpiresAccounts | Where-Object { \n                -not $_.ServicePrincipalName -and \n                $_.SamAccountName -notmatch '^(svc|service|sql|iis|app)' -and\n                $_.SamAccountName -notmatch '^\\$' \n            }\n            \n            if ($nonServiceAccounts.Count -gt 0) {\n                $passwordNeverExpiresEvidence = $nonServiceAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Non-Service Accounts with Password Never Expires' -Severity 'High' `\n                    -Description \"Found $($nonServiceAccounts.Count) enabled non-service accounts with 'Password Never Expires' setting.\" `\n                    -Impact 'Accounts with non-expiring passwords increase security risk if compromised.' `\n                    -Recommendation 'Review and disable Password Never Expires for non-service accounts.' `\n                    -Evidence $passwordNeverExpiresEvidence -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check for accounts with expired passwords\n            $expiredPasswordAccounts = Get-ADUser -Filter {Enabled -eq $true -and PasswordExpired -eq $true} -Properties PasswordExpired, LastLogonDate, PasswordLastSet\n            if ($expiredPasswordAccounts.Count -gt 0) {\n                $expiredPasswordEvidence = $expiredPasswordAccounts | Select-Object Name, SamAccountName, LastLogonDate, PasswordLastSet | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Expired Passwords' -Severity 'Medium' `\n                    -Description \"Found $($expiredPasswordAccounts.Count) enabled accounts with expired passwords.\" `\n                    -Impact 'Accounts with expired passwords may indicate inactive accounts or password policy issues.' `\n                    -Recommendation 'Review expired password accounts and either reset passwords or disable unused accounts.' `\n                    -Evidence $expiredPasswordEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n        } catch {\n            Write-AuditLog \"Error checking account password settings: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Check for privileged account analysis - Extended sensitive groups\n        $privilegedGroups = @('Domain Admins', 'Enterprise Admins', 'Schema Admins', 'Administrators')\n        $sensitiveGroups = @('Backup Operators', 'Server Operators', 'Print Operators', 'Account Operators', 'Replicator', 'Network Configuration Operators', 'Hyper-V Administrators', 'Remote Desktop Users')\n        \n        Write-AuditLog 'Analyzing privileged and sensitive group memberships...' -Level Info\n        \n        # Check core privileged groups\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop\n                if ($members.Count -gt 5) {\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Excessive Privileged Group Membership: $group\" -Severity 'Medium' `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact 'Large privileged groups increase attack surface and compliance risk.' `\n                        -Recommendation 'Review privileged group membership and remove unnecessary accounts.' `\n                        -Evidence ($members | Select-Object Name, ObjectClass | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group\" -Level Warning\n            }\n        }\n        \n        # Check for inactive privileged accounts\n        $inactiveThreshold = (Get-Date).AddDays(-90)\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop | Where-Object { $_.objectClass -eq 'user' }\n                foreach ($member in $members) {\n                    $user = Get-ADUser -Identity $member.SamAccountName -Properties LastLogonDate -ErrorAction Stop\n                    if ($user.LastLogonDate -and $user.LastLogonDate -lt $inactiveThreshold) {\n                        Add-AuditFinding -Category 'Privileged Access' -Title \"Inactive Privileged Account: $($user.SamAccountName)\" -Severity 'High' `\n                            -Description \"Privileged account $($user.SamAccountName) has not logged in for over 90 days.\" `\n                            -Impact 'Inactive privileged accounts create security risk and compliance violations.' `\n                            -Recommendation 'Disable or remove inactive privileged accounts after proper verification.' `\n                            -Evidence \"Last logon: $($user.LastLogonDate)\" -Type 'Security' -ComplianceFramework 'ISO27001'\n                    }\n                }\n            } catch {\n                Write-AuditLog \"Could not check inactive accounts for $group\" -Level Warning\n            }\n        }\n        \n        # Check sensitive groups for unexpected membership\n        foreach ($group in $sensitiveGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction SilentlyContinue\n                if ($members -and $members.Count -gt 0) {\n                    $memberEvidence = $members | Select-Object Name, ObjectClass | Out-String\n                    $severity = switch ($group) {\n                        'Backup Operators' { 'High' }\n                        'Server Operators' { 'High' }\n                        'Account Operators' { 'High' }\n                        default { 'Medium' }\n                    }\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Sensitive Group Has Members: $group\" -Severity $severity `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact \"Members of $group have elevated privileges that could be misused.\" `\n                        -Recommendation \"Review membership of $group and remove unnecessary accounts.\" `\n                        -Evidence $memberEvidence -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group (may not exist)\" -Level Info\n            }\n        }\n        \n        # Check for disabled user accounts that should be cleaned up\n        Write-AuditLog 'Checking for disabled user accounts...' -Level Info\n        try {\n            $disabledUsers = Get-ADUser -Filter {Enabled -eq $false} -Properties LastLogonDate, WhenChanged\n            $oldDisabledUsers = $disabledUsers | Where-Object { $_.WhenChanged -lt (Get-Date).AddDays(-90) }\n            \n            if ($oldDisabledUsers.Count -gt 0) {\n                $disabledUsersEvidence = $oldDisabledUsers | Select-Object Name, SamAccountName, LastLogonDate, WhenChanged | Sort-Object WhenChanged | Out-String\n                Add-AuditFinding -Category 'Account Hygiene' -Title 'Old Disabled User Accounts' -Severity 'Medium' `\n                    -Description \"Found $($oldDisabledUsers.Count) user accounts that have been disabled for more than 90 days.\" `\n                    -Impact 'Old disabled accounts consume resources and may indicate incomplete cleanup processes.' `\n                    -Recommendation 'Review old disabled accounts and remove them if no longer needed for auditing purposes.' `\n                    -Evidence $disabledUsersEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Error checking disabled user accounts: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD security configuration: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-CertificateServices {\n    Write-AuditLog 'Analyzing Certificate Services Infrastructure...' -Level Info\n    \n    try {\n        # Check Certificate Authority service - improved detection\n        $caService = Get-Service -Name 'CertSvc' -ErrorAction SilentlyContinue\n        if ($caService) {\n            if ($caService.Status -ne 'Running') {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificate Authority Service Not Running' -Severity 'High' `\n                    -Description 'Certificate Authority service is not running.' `\n                    -Impact 'PKI services unavailable, affecting certificate enrollment and validation.' `\n                    -Recommendation 'Start Certificate Authority service and investigate startup issues.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        } else {\n            Write-AuditLog 'Certificate Services not installed on this system' -Level Info\n        }\n        \n        # Check for expiring certificates in local machine store (regardless of CA installation)\n        try {\n            $expiringCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) -and $_.NotAfter -gt (Get-Date) }\n            \n            if ($expiringCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificates Expiring Soon' -Severity 'Medium' `\n                    -Description \"$($expiringCerts.Count) certificates will expire within 30 days.\" `\n                    -Impact 'Certificate expiration can cause service disruptions and authentication failures.' `\n                    -Recommendation 'Review expiring certificates and plan for renewal.' `\n                    -Evidence ($expiringCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n            \n            # Check for already expired certificates\n            $expiredCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date) }\n            \n            if ($expiredCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Expired Certificates Found' -Severity 'Medium' `\n                    -Description \"$($expiredCerts.Count) expired certificates found in local machine store.\" `\n                    -Impact 'Expired certificates should be removed to maintain clean certificate store.' `\n                    -Recommendation 'Remove expired certificates that are no longer needed.' `\n                    -Evidence ($expiredCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n        } catch {\n            Write-AuditLog \"Could not check certificate store: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Certificate Services: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\n# ==============================================================================\n# SERVER INFRASTRUCTURE AUDIT\n# ==============================================================================\n\nfunction Start-ServerInfrastructureAudit {\n    Write-AuditLog 'Starting Server Infrastructure Audit' -Level Header\n    \n    try {\n        # Discover server list\n        $serverList = Get-ServerInventory\n        \n        if ($serverList.Count -eq 0) {\n            Write-AuditLog \"No servers found for auditing\" -Level Warning\n            return\n        }\n        \n        Write-AuditLog \"Found $($serverList.Count) servers to audit\" -Level Success\n        \n        # Get credentials for server access\n        $credential = Get-AuditCredentials\n        if (-not $credential) {\n            Write-AuditLog \"No credentials provided for server audit\" -Level Warning\n            return\n        }\n        \n        # Audit servers in parallel\n        Start-ParallelServerAudit -ServerList $serverList -Credential $credential\n        \n    } catch {\n        Write-AuditLog \"Error during server infrastructure audit: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'Server Audit' -Title 'Server Infrastructure Audit Failed' -Severity 'High' `\n            -Description 'Unable to complete server infrastructure assessment.' `\n            -Impact 'Cannot verify server security and configuration compliance.' `\n            -Recommendation 'Investigate server audit failures and retry with proper credentials.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Get-ServerInventory {\n    Write-AuditLog 'Discovering server inventory...' -Level Info\n    \n    try {\n        if ($ServerListPath -and (Test-Path $ServerListPath)) {\n            # Load from CSV file\n            Write-AuditLog \"Loading server list from: $ServerListPath\" -Level Info\n            $serverList = Import-Csv -Path $ServerListPath\n            return $serverList | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.ServerName\n                    Description = if ($_.Description) { $_.Description } else { 'Imported from CSV' }\n                    Environment = if ($_.Environment) { $_.Environment } else { 'Unknown' }\n                }\n            }\n        } else {\n            # Auto-discover from Active Directory\n            Write-AuditLog \"Auto-discovering servers from Active Directory\" -Level Info\n            $adServers = Get-ADComputer -Filter {OperatingSystem -like \"*Server*\" -and Enabled -eq $true} -Properties Name, OperatingSystem, Description\n            \n            return $adServers | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.Name\n                    Description = if ($_.Description) { $_.Description } else { $_.OperatingSystem }\n                    Environment = 'Production' # Default assumption\n                }\n            }\n        }\n    } catch {\n        Write-AuditLog \"Error discovering server inventory: $($_.Exception.Message)\" -Level Error\n        return @()\n    }\n}\n\nfunction Get-AuditCredentials {\n    if ($CredentialPath -and (Test-Path $CredentialPath)) {\n        try {\n            Write-AuditLog \"Loading credentials from: $CredentialPath\" -Level Info\n            return Import-Clixml -Path $CredentialPath\n        } catch {\n            Write-AuditLog \"Failed to load credentials from file, prompting user\" -Level Warning\n        }\n    }\n    \n    Write-Host \"`nPlease provide credentials for server access:\" -ForegroundColor Yellow\n    return Get-Credential -Message \"Enter credentials for server auditing (Domain Admin or equivalent)\"\n}\n\nfunction Start-ParallelServerAudit {\n    param(\n        [Parameter(Mandatory=$true)]\n        [array]$ServerList,\n        \n        [Parameter(Mandatory=$true)]\n        [PSCredential]$Credential\n    )\n    \n    Write-AuditLog \"Starting parallel audit of $($ServerList.Count) servers with max $MaxConcurrentJobs concurrent jobs\" -Level Info\n    Write-AuditLog \"Using credentials for user: $($Credential.UserName)\" -Level Info\n    Write-AuditLog \"Server list: $($ServerList | ForEach-Object { $_.ServerName } | Join-String -Separator ', ')\" -Level Info\n    \n    $jobs = @()\n    $completedServers = 0\n    \n    # Start initial batch of jobs\n    foreach ($server in $ServerList) {\n        if ($jobs.Count -lt $MaxConcurrentJobs) {\n            Write-AuditLog \"Starting audit job for server: $($server.ServerName)\" -Level Info\n            $job = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $server, $Credential\n            $jobs += [PSCustomObject]@{ Job = $job; Server = $server; StartTime = Get-Date }\n            Write-AuditLog \"Job started for $($server.ServerName) - Job ID: $($job.Id)\" -Level Info\n        } else {\n            break\n        }\n    }\n    \n    $remainingServers = $ServerList[$jobs.Count..($ServerList.Count-1)]\n    \n    # Monitor jobs and start new ones as they complete\n    $loopCount = 0\n    $maxLoops = 1800  # 1 hour maximum (3600 seconds / 2 second sleep)\n    while (($jobs.Count -gt 0 -or $remainingServers.Count -gt 0) -and $loopCount -lt $maxLoops) {\n        Start-Sleep -Seconds 2\n        $loopCount++\n        \n        # Enhanced logging every 30 seconds (15 loops)\n        if ($loopCount % 15 -eq 0) {\n            Write-AuditLog \"Job monitoring status: $($jobs.Count) active jobs, $($remainingServers.Count) servers remaining\" -Level Info\n            foreach ($job in $jobs) {\n                $runtime = [math]::Round(((Get-Date) - $job.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"  - Server: $($job.Server.ServerName), State: $($job.Job.State), Runtime: ${runtime} minutes\" -Level Info\n            }\n        }\n        \n        $finishedJobs = $jobs | Where-Object { $_.Job.State -in @('Completed', 'Failed', 'Stopped') }\n        \n        foreach ($finishedJob in $finishedJobs) {\n            try {\n                $runtime = [math]::Round(((Get-Date) - $finishedJob.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"Processing completed job for server: $($finishedJob.Server.ServerName) (Runtime: ${runtime} minutes, State: $($finishedJob.Job.State))\" -Level Info\n                \n                $result = Receive-Job -Job $finishedJob.Job\n                $script:ServerResults += $result\n                $completedServers++\n                \n                Write-AuditLog \"Server audit completed for $($finishedJob.Server.ServerName). Connection Status: $($result.ConnectionStatus), Risk Score: $($result.RiskScore)\" -Level Success\n                \n                # Update separate progress for server audit\n                $serverPercent = [math]::Min([math]::Round(($completedServers / $ServerList.Count) * 100, 1), 100)\n                Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Status \"Completed $($finishedJob.Server.ServerName)\" -PercentComplete $serverPercent -CurrentOperation \"Auditing $completedServers of $($ServerList.Count) servers\"\n                \n                Remove-Job -Job $finishedJob.Job\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n                \n                # Start next job if servers remain\n                if ($remainingServers.Count -gt 0) {\n                    $nextServer = $remainingServers[0]\n                    $remainingServers = $remainingServers[1..($remainingServers.Count-1)]\n                    \n                    Write-AuditLog \"Starting new audit job for server: $($nextServer.ServerName)\" -Level Info\n                    $newJob = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $nextServer, $Credential\n                    $jobs += [PSCustomObject]@{ Job = $newJob; Server = $nextServer; StartTime = Get-Date }\n                    Write-AuditLog \"New job started for $($nextServer.ServerName) - Job ID: $($newJob.Id)\" -Level Info\n                }\n                \n            } catch {\n                Write-AuditLog \"Error processing job result for $($finishedJob.Server.ServerName): $($_.Exception.Message)\" -Level Error\n                Remove-Job -Job $finishedJob.Job -ErrorAction Stop\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n            }\n        }\n        \n        # Check for hung jobs (running longer than 5 minutes)\n        $hungJobs = $jobs | Where-Object { ((Get-Date) - $_.StartTime).TotalMinutes -gt 5 }\n        foreach ($hungJob in $hungJobs) {\n            $runtime = [math]::Round(((Get-Date) - $hungJob.StartTime).TotalMinutes, 1)\n            Write-AuditLog \"Stopping hung job for server $($hungJob.Server.ServerName) - Runtime: ${runtime} minutes, State: $($hungJob.Job.State)\" -Level Warning\n            \n            # Try to get any partial results\n            try {\n                $partialResult = Receive-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n                if ($partialResult) {\n                    Write-AuditLog \"Retrieved partial results from hung job for $($hungJob.Server.ServerName)\" -Level Info\n                    $script:ServerResults += $partialResult\n                }\n            } catch {\n                Write-AuditLog \"Could not retrieve results from hung job for $($hungJob.Server.ServerName): $($_.Exception.Message)\" -Level Warning\n            }\n            \n            Stop-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            $jobs = $jobs | Where-Object { $_.Job.Id -ne $hungJob.Job.Id }\n            $completedServers++ # Count as completed even if hung\n            \n            # Add failure finding\n            Add-AuditFinding -Category 'Server Audit' -Title \"Server Audit Timeout: $($hungJob.Server.ServerName)\" -Severity 'Medium' `\n                -Description \"Server audit job exceeded 5-minute timeout limit (Runtime: ${runtime} minutes).\" `\n                -Impact 'Unable to complete comprehensive assessment of server.' `\n                -Recommendation 'Investigate server connectivity and performance issues. Check WinRM, firewall, and authentication settings.' `\n                -Type 'Availability'\n        }\n    }\n    \n    # Check if we exceeded maximum loop count\n    if ($loopCount -ge $maxLoops) {\n        Write-AuditLog \"Server audit monitoring exceeded maximum time limit (1 hour). Forcing completion.\" -Level Warning\n        # Clean up any remaining jobs\n        foreach ($job in $jobs) {\n            Write-AuditLog \"Force stopping job for server: $($job.Server.ServerName)\" -Level Warning\n            Stop-Job -Job $job.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $job.Job -ErrorAction SilentlyContinue\n        }\n    }\n    \n    Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Completed\n    Write-AuditLog \"Server infrastructure audit completed. Processed $completedServers of $($ServerList.Count) servers\" -Level Success\n}\n\n# Define the script block for server auditing\n$script:ServerAuditScriptBlock = {\n    param($ServerInfo, $Credential)\n    \n    $serverName = $ServerInfo.ServerName\n    $auditResult = [PSCustomObject]@{\n        ServerName = $serverName\n        Description = $ServerInfo.Description\n        Environment = $ServerInfo.Environment\n        PingStatus = 'Unknown'\n        ConnectionStatus = 'Unknown'\n        OperatingSystem = ''\n        OSVersion = ''\n        Architecture = ''\n        Manufacturer = ''\n        Model = ''\n        SerialNumber = ''\n        TotalMemoryGB = 0\n        ProcessorInfo = ''\n        ProcessorCores = 0\n        CPUUtilization = 0\n        MemoryUtilization = 0\n        DiskInfo = @()\n        NetworkAdapters = @()\n        CriticalServices = @()\n        InstalledRoles = @()\n        LocalAdministrators = @()\n        InstalledSoftware = @()\n        ScheduledTasks = @()\n        NetworkShares = @()\n        RecentUpdates = @()\n        SecurityChecks = @{}\n        PendingUpdates = 0\n        LastBootTime = $null\n        UptimeDays = 0\n        SecurityIssues = @()\n        PerformanceIssues = @()\n        Recommendations = @()\n        RiskScore = 0\n        AuditTimestamp = Get-Date\n        ErrorMessages = @()\n    }\n    \n    try {\n        # Test connectivity\n        $pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet -ErrorAction Stop\n        $auditResult.PingStatus = if ($pingResult) { 'Online' } else { 'Offline' }\n        \n        if (-not $pingResult) {\n            $auditResult.ConnectionStatus = 'Failed - No Response'\n            $auditResult.ErrorMessages += 'Server not responding to ping'\n            return $auditResult\n        }\n        \n        # Establish remote session with enhanced error handling\n        try {\n            $sessionOption = New-PSSessionOption -OpenTimeout 30000 -OperationTimeout 300000\n            $session = New-PSSession -ComputerName $serverName -Credential $Credential -SessionOption $sessionOption -ErrorAction Stop\n            $auditResult.ConnectionStatus = 'Connected'\n        } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n            $auditResult.ConnectionStatus = 'Failed - WinRM/Remoting Issue'\n            $auditResult.ErrorMessages += \"PowerShell remoting failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.Management.Automation.RuntimeException] {\n            $auditResult.ConnectionStatus = 'Failed - Authentication Issue'\n            $auditResult.ErrorMessages += \"Authentication failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.TimeoutException] {\n            $auditResult.ConnectionStatus = 'Failed - Timeout'\n            $auditResult.ErrorMessages += \"Connection timeout: $($_.Exception.Message)\"\n            return $auditResult\n        } catch {\n            $auditResult.ConnectionStatus = 'Failed - Unknown Error'\n            $auditResult.ErrorMessages += \"Unexpected connection error: $($_.Exception.Message)\"\n            return $auditResult\n        }\n        \n        # Execute comprehensive remote audit\n        $remoteData = Invoke-Command -Session $session -ScriptBlock {\n            $results = @{\n                Errors = @()\n            }\n            \n            try {\n                # System information\n                $results.OS = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop\n                $results.ComputerSystem = Get-CimInstance Win32_ComputerSystem -ErrorAction Stop\n                $results.BIOS = Get-CimInstance Win32_BIOS -ErrorAction Stop\n                $results.Processor = Get-CimInstance Win32_Processor -ErrorAction Stop\n                \n                # Performance metrics\n                try {\n                    $cpuCounter = Get-Counter \"\\Processor(_Total)\\% Processor Time\" -MaxSamples 3 -ErrorAction Stop\n                    if ($cpuCounter) {\n                        $results.CPUUtilization = [math]::Round(($cpuCounter.CounterSamples | Measure-Object CookedValue -Average).Average, 2)\n                    }\n                } catch {\n                    $results.CPUUtilization = -1\n                }\n                \n                if ($results.ComputerSystem -and $results.OS) {\n                    $memTotal = $results.ComputerSystem.TotalPhysicalMemory\n                    $memAvailable = $results.OS.FreePhysicalMemory * 1KB\n                    $results.MemoryUtilization = [math]::Round((($memTotal - $memAvailable) / $memTotal) * 100, 2)\n                }\n                \n                # Disk information\n                $results.Disks = Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" -ErrorAction Stop\n                \n                # Network adapters\n                $results.NetworkAdapters = Get-CimInstance Win32_NetworkAdapterConfiguration -ErrorAction Stop\n                    Where-Object { $_.IPEnabled -eq $true }\n                \n                # Critical services\n                $criticalServices = @('DHCP', 'DNS', 'W32Time', 'EventLog', 'RpcSs', 'LanmanServer', 'Spooler')\n                $results.Services = Get-Service -Name $criticalServices -ErrorAction Stop | \n                    Select-Object Name, Status, StartType\n                \n                # Windows features/roles\n                try {\n                    $results.WindowsFeatures = Get-WindowsFeature -ErrorAction Stop | \n                        Where-Object { $_.Installed -eq $true } | \n                        Select-Object -ExpandProperty Name\n                } catch {\n                    $results.WindowsFeatures = @()\n                }\n                \n                # Local administrators\n                try {\n                    $results.LocalAdmins = Get-LocalGroupMember -Group \"Administrators\" -ErrorAction Stop | \n                        Select-Object Name, ObjectClass, PrincipalSource\n                } catch {\n                    $results.LocalAdmins = @()\n                }\n                \n                # Windows updates\n                try {\n                    $updateSession = New-Object -ComObject Microsoft.Update.Session -ErrorAction Stop\n                    if ($updateSession) {\n                        $updateSearcher = $updateSession.CreateUpdateSearcher()\n                        $searchResult = $updateSearcher.Search(\"IsInstalled=0\")\n                        $results.PendingUpdates = $searchResult.Updates.Count\n                    } else {\n                        $results.PendingUpdates = -1\n                    }\n                } catch {\n                    $results.PendingUpdates = -1\n                }\n                \n                # System uptime\n                if ($results.OS) {\n                    $results.LastBoot = $results.OS.LastBootUpTime\n                    $results.UptimeDays = [math]::Round(((Get-Date) - $results.LastBoot).TotalDays, 1)\n                }\n                \n                # Event log errors (last 24 hours)\n                try {\n                    $results.RecentErrors = Get-WinEvent -FilterHashtable @{\n                        LogName='System','Application'\n                        Level=1,2  # Critical and Error\n                        StartTime=(Get-Date).AddDays(-1)\n                    } -MaxEvents 10 -ErrorAction Stop\n                } catch {\n                    $results.RecentErrors = @()\n                }\n                \n                # Security configuration checks\n                $results.SecurityChecks = @{}\n                \n                # Windows Defender status\n                try {\n                    $results.SecurityChecks.DefenderStatus = Get-MpComputerStatus -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.DefenderStatus = $null\n                }\n                \n                # Firewall status\n                try {\n                    $results.SecurityChecks.FirewallProfiles = Get-NetFirewallProfile -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.FirewallProfiles = @()\n                }\n                \n                # Installed software audit\n                try {\n                    $results.InstalledSoftware = Get-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction Stop | \n                        Where-Object { $_.DisplayName -and $_.DisplayName -ne \"\" } |\n                        Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n                        Sort-Object DisplayName\n                } catch {\n                    $results.InstalledSoftware = @()\n                    $results.Errors += \"Failed to retrieve installed software\"\n                }\n                \n                # Scheduled tasks audit\n                try {\n                    $results.ScheduledTasks = Get-ScheduledTask -ErrorAction Stop | \n                        Where-Object { $_.State -eq 'Ready' -and $_.TaskPath -notlike '\\Microsoft\\*' } |\n                        Select-Object TaskName, TaskPath, State, @{N='NextRun';E={$_.NextRunTime}}, @{N='LastRun';E={$_.LastRunTime}}\n                } catch {\n                    $results.ScheduledTasks = @()\n                    $results.Errors += \"Failed to retrieve scheduled tasks\"\n                }\n                \n                # SMBv1 status check\n                try {\n                    $results.SecurityChecks.SMBv1Status = @{}\n                    # Check if SMBv1 feature is installed\n                    $smb1Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.FeatureInstalled = ($smb1Feature.State -eq 'Enabled')\n                    \n                    # Check registry settings\n                    $smb1RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n                    $smb1RegValue = Get-ItemProperty -Path $smb1RegPath -Name \"SMB1\" -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.RegistryEnabled = ($smb1RegValue.SMB1 -eq 1)\n                } catch {\n                    $results.SecurityChecks.SMBv1Status = @{FeatureInstalled = $null; RegistryEnabled = $null}\n                    $results.Errors += \"Failed to check SMBv1 status\"\n                }\n                \n                # Network shares audit\n                try {\n                    $results.NetworkShares = Get-SmbShare -ErrorAction Stop | \n                        Where-Object { $_.Name -notin @('ADMIN$', 'C$', 'IPC$', 'print$') } |\n                        Select-Object Name, Path, Description, ShareType, @{N='AccessRight';E={\n                            try {\n                                $acl = Get-SmbShareAccess -Name $_.Name -ErrorAction SilentlyContinue\n                                ($acl | ForEach-Object { \"$($_.AccountName):$($_.AccessRight)\" }) -join '; '\n                            } catch {\n                                'Unable to retrieve'\n                            }\n                        }}\n                } catch {\n                    $results.NetworkShares = @()\n                    $results.Errors += \"Failed to retrieve network shares\"\n                }\n                \n                # Enhanced antivirus detection\n                try {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                    \n                    # Windows Defender already checked above\n                    \n                    # Check for third-party antivirus via WMI\n                    try {\n                        $avProducts = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ErrorAction SilentlyContinue\n                        if ($avProducts) {\n                            $results.SecurityChecks.AntivirusProducts = $avProducts | ForEach-Object {\n                                [PSCustomObject]@{\n                                    Name = $_.displayName\n                                    State = switch ($_.productState) {\n                                        { $_ -band 0x1000 } { 'Enabled' }\n                                        default { 'Disabled' }\n                                    }\n                                    UpToDate = switch ($_.productState) {\n                                        { $_ -band 0x10 } { 'Yes' }\n                                        default { 'No' }\n                                    }\n                                }\n                            }\n                        }\n                    } catch {\n                        $results.Errors += \"Failed to query third-party antivirus products\"\n                    }\n                } catch {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                }\n                \n                # PowerShell remoting configuration\n                try {\n                    $results.SecurityChecks.PSRemoting = @{}\n                    $winrm = Get-Service WinRM -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.PSRemoting.ServiceStatus = $winrm.Status\n                    \n                    # Check WinRM listeners\n                    $listeners = winrm enumerate winrm/config/listener 2>$null\n                    $results.SecurityChecks.PSRemoting.HasListeners = ($listeners -ne $null)\n                } catch {\n                    $results.SecurityChecks.PSRemoting = @{ServiceStatus = 'Unknown'; HasListeners = $false}\n                    $results.Errors += \"Failed to check PowerShell remoting configuration\"\n                }\n                \n                # BitLocker encryption status\n                try {\n                    $results.SecurityChecks.BitLocker = @()\n                    $bitlockerVolumes = Get-BitLockerVolume -ErrorAction SilentlyContinue\n                    if ($bitlockerVolumes) {\n                        $results.SecurityChecks.BitLocker = $bitlockerVolumes | ForEach-Object {\n                            [PSCustomObject]@{\n                                MountPoint = $_.MountPoint\n                                EncryptionMethod = $_.EncryptionMethod\n                                VolumeStatus = $_.VolumeStatus\n                                ProtectionStatus = $_.ProtectionStatus\n                                EncryptionPercentage = $_.EncryptionPercentage\n                            }\n                        }\n                    }\n                } catch {\n                    $results.SecurityChecks.BitLocker = @()\n                    $results.Errors += \"Failed to check BitLocker status\"\n                }\n                \n                # Recent Windows updates\n                try {\n                    $results.RecentUpdates = Get-HotFix -ErrorAction Stop | \n                        Sort-Object InstalledOn -Descending | \n                        Select-Object -First 10 Description, HotFixID, InstalledBy, InstalledOn\n                } catch {\n                    $results.RecentUpdates = @()\n                    $results.Errors += \"Failed to retrieve recent updates\"\n                }\n                \n                # Time synchronization configuration\n                try {\n                    $results.SecurityChecks.TimeSync = @{}\n                    $w32time = w32tm /query /status 2>$null\n                    $results.SecurityChecks.TimeSync.W32TimeStatus = if ($w32time) { 'Configured' } else { 'Not Configured' }\n                    \n                    $ntpServer = w32tm /query /peers 2>$null | Where-Object { $_ -match \"Peer:\" }\n                    $results.SecurityChecks.TimeSync.NTPServers = if ($ntpServer) { $ntpServer -join '; ' } else { 'None configured' }\n                } catch {\n                    $results.SecurityChecks.TimeSync = @{W32TimeStatus = 'Unknown'; NTPServers = 'Unknown'}\n                    $results.Errors += \"Failed to check time synchronization\"\n                }\n                \n            } catch {\n                $results.Errors += \"General error: $($_.Exception.Message)\"\n            }\n            \n            return $results\n        }\n        \n        # Process remote data\n        if ($remoteData.OS) {\n            $auditResult.OperatingSystem = $remoteData.OS.Caption\n            $auditResult.OSVersion = $remoteData.OS.Version\n            $auditResult.Architecture = $remoteData.OS.OSArchitecture\n        }\n        \n        if ($remoteData.ComputerSystem) {\n            $auditResult.Manufacturer = $remoteData.ComputerSystem.Manufacturer\n            $auditResult.Model = $remoteData.ComputerSystem.Model\n            $auditResult.TotalMemoryGB = [math]::Round($remoteData.ComputerSystem.TotalPhysicalMemory / 1GB, 2)\n        }\n        \n        if ($remoteData.BIOS) {\n            $auditResult.SerialNumber = $remoteData.BIOS.SerialNumber\n        }\n        \n        if ($remoteData.Processor) {\n            $auditResult.ProcessorInfo = ($remoteData.Processor | Select-Object -First 1).Name\n            $auditResult.ProcessorCores = ($remoteData.Processor | Measure-Object NumberOfCores -Sum).Sum\n        }\n        \n        $auditResult.CPUUtilization = $remoteData.CPUUtilization\n        $auditResult.MemoryUtilization = $remoteData.MemoryUtilization\n        $auditResult.LastBootTime = $remoteData.LastBoot\n        $auditResult.UptimeDays = $remoteData.UptimeDays\n        $auditResult.PendingUpdates = $remoteData.PendingUpdates\n        $auditResult.CriticalServices = $remoteData.Services\n        $auditResult.InstalledRoles = $remoteData.WindowsFeatures\n        $auditResult.LocalAdministrators = $remoteData.LocalAdmins\n        $auditResult.InstalledSoftware = $remoteData.InstalledSoftware\n        $auditResult.ScheduledTasks = $remoteData.ScheduledTasks\n        $auditResult.NetworkShares = $remoteData.NetworkShares\n        $auditResult.RecentUpdates = $remoteData.RecentUpdates\n        $auditResult.SecurityChecks = $remoteData.SecurityChecks\n        \n        # Process disk information\n        if ($remoteData.Disks) {\n            $auditResult.DiskInfo = $remoteData.Disks | ForEach-Object {\n                $freePercent = if ($_.Size -gt 0) { [math]::Round(($_.FreeSpace / $_.Size) * 100, 1) } else { 0 }\n                [PSCustomObject]@{\n                    Drive = $_.DeviceID\n                    SizeGB = [math]::Round($_.Size / 1GB, 2)\n                    FreeSpaceGB = [math]::Round($_.FreeSpace / 1GB, 2)\n                    FreeSpacePercent = $freePercent\n                    FileSystem = $_.FileSystem\n                }\n            }\n        }\n        \n        # Process network adapters\n        if ($remoteData.NetworkAdapters) {\n            $auditResult.NetworkAdapters = $remoteData.NetworkAdapters | ForEach-Object {\n                [PSCustomObject]@{\n                    Description = $_.Description\n                    IPAddress = $_.IPAddress -join ', '\n                    DHCPEnabled = $_.DHCPEnabled\n                    DNSServers = $_.DNSServerSearchOrder -join ', '\n                }\n            }\n        }\n        \n        # Security and performance analysis\n        $securityIssues = @()\n        $performanceIssues = @()\n        $recommendations = @()\n        $riskScore = 0\n        \n        # High CPU utilization\n        if ($auditResult.CPUUtilization -gt 80) {\n            $performanceIssues += \"High CPU utilization: $($auditResult.CPUUtilization)%\"\n            $recommendations += \"Investigate high CPU usage and optimize workloads\"\n            $riskScore += 2\n        }\n        \n        # High memory utilization\n        if ($auditResult.MemoryUtilization -gt 85) {\n            $performanceIssues += \"High memory utilization: $($auditResult.MemoryUtilization)%\"\n            $recommendations += \"Consider memory upgrade or workload redistribution\"\n            $riskScore += 2\n        }\n        \n        # Low disk space\n        $lowDiskSpace = $auditResult.DiskInfo | Where-Object { $_.FreeSpacePercent -lt 15 }\n        if ($lowDiskSpace) {\n            $performanceIssues += \"Low disk space on drives: $($lowDiskSpace.Drive -join ', ')\"\n            $recommendations += \"Urgent: Free up disk space or expand storage\"\n            $riskScore += 3\n        }\n        \n        # Pending updates\n        if ($auditResult.PendingUpdates -gt 0) {\n            $securityIssues += \"$($auditResult.PendingUpdates) pending Windows updates\"\n            $recommendations += \"Install pending Windows updates during next maintenance window\"\n            $riskScore += 1\n        }\n        \n        # Excessive uptime\n        if ($auditResult.UptimeDays -gt 90) {\n            $securityIssues += \"Server uptime exceeds 90 days ($($auditResult.UptimeDays) days)\"\n            $recommendations += \"Schedule reboot during maintenance window to apply updates\"\n            $riskScore += 1\n        }\n        \n        # Service status issues\n        $stoppedServices = $auditResult.CriticalServices | Where-Object { $_.Status -ne 'Running' -and $_.StartType -eq 'Automatic' }\n        if ($stoppedServices) {\n            $securityIssues += \"Critical services not running: $($stoppedServices.Name -join ', ')\"\n            $recommendations += \"Investigate and start critical services\"\n            $riskScore += 3\n        }\n        \n        # Windows Defender status\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            $defender = $remoteData.SecurityChecks.DefenderStatus\n            if (-not $defender.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender or verify third-party antivirus is active\"\n                $riskScore += 3\n            }\n            if (-not $defender.RealTimeProtectionEnabled) {\n                $securityIssues += \"Real-time protection is disabled\"\n                $recommendations += \"Enable real-time protection immediately\"\n                $riskScore += 3\n            }\n        }\n        \n        # Firewall status\n        if ($remoteData.SecurityChecks.FirewallProfiles) {\n            $disabledProfiles = $remoteData.SecurityChecks.FirewallProfiles | Where-Object { -not $_.Enabled }\n            if ($disabledProfiles) {\n                $securityIssues += \"Windows Firewall disabled on profiles: $($disabledProfiles.Name -join ', ')\"\n                $recommendations += \"Enable Windows Firewall on all network profiles\"\n                $riskScore += 2\n            }\n        }\n        \n        # Excessive local administrators\n        $userAdmins = $auditResult.LocalAdministrators | Where-Object { $_.ObjectClass -eq 'User' }\n        if ($userAdmins.Count -gt 3) {\n            $securityIssues += \"Excessive local administrators: $($userAdmins.Count) user accounts\"\n            $recommendations += \"Review and reduce local administrator accounts\"\n            $riskScore += 2\n        }\n        \n        # SMBv1 security check\n        if ($remoteData.SecurityChecks.SMBv1Status) {\n            if ($remoteData.SecurityChecks.SMBv1Status.FeatureInstalled -eq $true) {\n                $securityIssues += \"SMBv1 protocol is enabled (security risk)\"\n                $recommendations += \"Disable SMBv1 protocol to prevent security vulnerabilities\"\n                $riskScore += 3\n            }\n            if ($remoteData.SecurityChecks.SMBv1Status.RegistryEnabled -eq $true) {\n                $securityIssues += \"SMBv1 enabled in registry settings\"\n                $recommendations += \"Disable SMBv1 in registry settings\"\n                $riskScore += 2\n            }\n        }\n        \n        # Network shares security review\n        if ($auditResult.NetworkShares -and $auditResult.NetworkShares.Count -gt 0) {\n            $publicShares = $auditResult.NetworkShares | Where-Object { $_.AccessRight -match \"Everyone\" }\n            if ($publicShares.Count -gt 0) {\n                $securityIssues += \"Network shares with 'Everyone' permissions found: $($publicShares.Count)\"\n                $recommendations += \"Review and restrict network share permissions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Antivirus status check\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            if (-not $remoteData.SecurityChecks.DefenderStatus.RealTimeProtectionEnabled) {\n                $securityIssues += \"Windows Defender real-time protection is disabled\"\n                $recommendations += \"Enable Windows Defender real-time protection\"\n                $riskScore += 3\n            }\n            if (-not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender antivirus protection\"\n                $riskScore += 3\n            }\n        }\n        \n        # Third-party antivirus check\n        if ($remoteData.SecurityChecks.AntivirusProducts) {\n            $enabledAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.State -eq 'Enabled' }\n            $outdatedAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.UpToDate -eq 'No' }\n            \n            if ($enabledAV.Count -eq 0 -and -not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"No active antivirus protection detected\"\n                $recommendations += \"Install and enable antivirus protection\"\n                $riskScore += 4\n            }\n            \n            if ($outdatedAV.Count -gt 0) {\n                $securityIssues += \"Outdated antivirus definitions detected\"\n                $recommendations += \"Update antivirus definitions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Scheduled tasks security review\n        if ($auditResult.ScheduledTasks -and $auditResult.ScheduledTasks.Count -gt 5) {\n            $securityIssues += \"Multiple custom scheduled tasks detected: $($auditResult.ScheduledTasks.Count)\"\n            $recommendations += \"Review scheduled tasks for unauthorized or suspicious activities\"\n            $riskScore += 1\n        }\n        \n        # BitLocker encryption check\n        if ($remoteData.SecurityChecks.BitLocker) {\n            $unencryptedVolumes = $remoteData.SecurityChecks.BitLocker | Where-Object { $_.VolumeStatus -ne 'FullyEncrypted' }\n            if ($unencryptedVolumes.Count -gt 0) {\n                $securityIssues += \"Unencrypted volumes detected: $($unencryptedVolumes.Count)\"\n                $recommendations += \"Enable BitLocker encryption on all system volumes\"\n                $riskScore += 2\n            }\n        } else {\n            $securityIssues += \"BitLocker status could not be determined\"\n            $recommendations += \"Verify BitLocker encryption status\"\n            $riskScore += 1\n        }\n        \n        # PowerShell remoting security\n        if ($remoteData.SecurityChecks.PSRemoting.ServiceStatus -eq 'Running' -and $remoteData.SecurityChecks.PSRemoting.HasListeners) {\n            $securityIssues += \"PowerShell remoting is enabled and listening\"\n            $recommendations += \"Review PowerShell remoting configuration and security settings\"\n            $riskScore += 1\n        }\n        \n        # Time synchronization check\n        if ($remoteData.SecurityChecks.TimeSync.W32TimeStatus -eq 'Not Configured') {\n            $securityIssues += \"Time synchronization not properly configured\"\n            $recommendations += \"Configure proper time synchronization with domain or NTP servers\"\n            $riskScore += 1\n        }\n        \n        $auditResult.SecurityIssues = $securityIssues\n        $auditResult.PerformanceIssues = $performanceIssues\n        $auditResult.Recommendations = $recommendations\n        $auditResult.RiskScore = $riskScore\n        $auditResult.ErrorMessages = $remoteData.Errors\n        \n        # Clean up session with error handling\n        try {\n            Remove-PSSession $session -ErrorAction Stop\n        } catch {\n            $auditResult.ErrorMessages += \"Session cleanup warning: $($_.Exception.Message)\"\n        }\n        \n    } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Execution Error'\n        $auditResult.ErrorMessages += \"Remote command execution failed: $($_.Exception.Message)\"\n    } catch [System.TimeoutException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Command Timeout'\n        $auditResult.ErrorMessages += \"Remote command timeout: $($_.Exception.Message)\"\n    } catch [System.UnauthorizedAccessException] {\n        $auditResult.ConnectionStatus = 'Failed - Access Denied'\n        $auditResult.ErrorMessages += \"Access denied during audit: $($_.Exception.Message)\"\n    } catch {\n        $auditResult.ConnectionStatus = 'Failed - Audit Error'\n        $auditResult.ErrorMessages += \"Unexpected audit error: $($_.Exception.Message)\"\n        \n        # Include inner exception details if available\n        if ($_.Exception.InnerException) {\n            $auditResult.ErrorMessages += \"Inner exception: $($_.Exception.InnerException.Message)\"\n        }\n    } finally {\n        # Ensure session cleanup in finally block\n        if ($session) {\n            try {\n                Remove-PSSession $session -ErrorAction SilentlyContinue\n            } catch {\n                # Silently handle cleanup errors in finally block\n            }\n        }\n    }\n    \n    return $auditResult\n}\n\n# ==============================================================================\n# REPORT GENERATION FUNCTIONS\n# ==============================================================================\n\nfunction New-ComprehensiveAuditReport {\n    Write-AuditLog 'Generating comprehensive audit reports...' -Level Header\n    \n    try {\n        # Calculate overall statistics\n        $summary = Get-AuditSummaryStatistics\n        \n        # Generate reports in requested formats\n        foreach ($format in $ExportFormats) {\n            switch ($format) {\n                'HTML' { New-HTMLReport -Summary $summary }\n                'Excel' { New-ExcelReport -Summary $summary }\n                'CSV' { New-CSVReport -Summary $summary }\n                'Markdown' { New-MarkdownReport -Summary $summary }\n                'PDF' { New-PDFReport -Summary $summary }\n            }\n        }\n        \n        # Generate executive summary\n        New-ExecutiveSummary -Summary $summary\n        \n        Write-AuditLog \"All reports generated successfully in: $script:OutputDir\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating reports: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Get-AuditSummaryStatistics {\n    $totalFindings = $script:AuditFindings.Count\n    $criticalFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }).Count\n    $highFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'High' }).Count\n    $mediumFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }).Count\n    $lowFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }).Count\n    $passedFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }).Count\n    $issuesFindings = $totalFindings - $passedFindings\n    \n    $totalServers = $script:ServerResults.Count\n    $onlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Online' }).Count\n    $offlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Offline' }).Count\n    $highRiskServers = ($script:ServerResults | Where-Object { $_.RiskScore -gt 5 }).Count\n    \n    $totalRiskScore = ($script:AuditFindings | Measure-Object -Property Score -Sum).Sum\n    $overallRisk = if ($criticalFindings -gt 0) { 'CRITICAL' }\n                  elseif ($highFindings -gt 3) { 'HIGH' }\n                  elseif ($highFindings -gt 0 -or $mediumFindings -gt 5) { 'MEDIUM' }\n                  else { 'LOW' }\n    \n    return [PSCustomObject]@{\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n        AuditDate = $script:StartTime\n        AuditDuration = (Get-Date) - $script:StartTime\n        TotalFindings = $totalFindings\n        IssuesFindings = $issuesFindings\n        PassedFindings = $passedFindings\n        CriticalFindings = $criticalFindings\n        HighFindings = $highFindings\n        MediumFindings = $mediumFindings\n        LowFindings = $lowFindings\n        TotalServers = $totalServers\n        OnlineServers = $onlineServers\n        OfflineServers = $offlineServers\n        HighRiskServers = $highRiskServers\n        TotalRiskScore = $totalRiskScore\n        OverallRisk = $overallRisk\n        ComplianceFrameworks = $script:ComplianceFrameworks\n    }\n}\n\nfunction New-HTMLReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating HTML report...' -Level Info\n    \n    $htmlPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.html'\n    \n    # HTML Source Code Protection Function\n    function Protect-HtmlSource {\n        [CmdletBinding()]\n        param(\n            [Parameter(Mandatory = $true)]\n            [string]$HtmlContent,\n            \n            [Parameter(Mandatory = $true)]\n            [string]$Password = \"Nlf263nish25!\"\n        )\n        \n        # Convert HTML to Base64\n        $bytes = [System.Text.Encoding]::UTF8.GetBytes($HtmlContent)\n        $base64Html = [System.Convert]::ToBase64String($bytes)\n        \n        # Create password hash for validation\n        $passwordHash = [System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($Password))\n        $passwordHashString = [System.BitConverter]::ToString($passwordHash).Replace('-', '').ToLower()\n        \n        # Create protected HTML wrapper\n        $protectedHtml = @\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>🔒 Protected Infrastructure Report</title>\n    <style>\n        body { font-family: Arial, sans-serif; background: #f0f0f0; margin: 0; padding: 20px; }\n        .container { max-width: 500px; margin: 100px auto; background: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); text-align: center; }\n        h1 { color: #333; margin-bottom: 20px; }\n        input { width: 100%; padding: 12px; margin: 10px 0; border: 2px solid #ddd; border-radius: 5px; font-size: 16px; }\n        button { width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; }\n        button:hover { background: #0056b3; }\n        .error { color: #dc3545; margin-top: 10px; display: none; }\n        .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; color: #666; font-size: 12px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>🔒 Protected Report Access</h1>\n        <p>This report contains confidential information and is protected by password encryption.</p>\n        <input type=\"password\" id=\"passwordInput\" placeholder=\"Enter password to decrypt report\" />\n        <button onclick=\"decryptReport()\">Decrypt & View Report</button>\n        <div class=\"error\" id=\"errorMsg\">Invalid password. Access denied.</div>\n        <div class=\"footer\">\n            First Technology Security Framework<br>\n            Source Code Protection: ACTIVE<br>\n            Unauthorized access prohibited\n        </div>\n    </div>\n\n    <script>\n        const encryptedContent = '$base64Html';\n        const validHash = '$passwordHashString';\n        \n        async function decryptReport() {\n            const password = document.getElementById('passwordInput').value;\n            const inputHash = await sha256(password);\n            \n            if (inputHash === validHash) {\n                try {\n                    const decodedContent = atob(encryptedContent);\n                    document.open();\n                    document.write(decodedContent);\n                    document.close();\n                } catch (e) {\n                    document.getElementById('errorMsg').style.display = 'block';\n                }\n            } else {\n                document.getElementById('errorMsg').style.display = 'block';\n                document.getElementById('passwordInput').value = '';\n                document.getElementById('passwordInput').focus();\n            }\n        }\n        \n        // Simple SHA256 implementation for client-side validation\n        async function sha256(str) {\n            const utf8 = new TextEncoder().encode(str);\n            const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        // Enter key support\n        document.getElementById('passwordInput').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                decryptReport();\n            }\n        });\n        \n        // Focus on load\n        document.addEventListener('DOMContentLoaded', function() {\n            document.getElementById('passwordInput').focus();\n        });\n    </script>\n</body>\n</html>\n\"@\n        \n        return $protectedHtml\n    }\n\n    $riskColor = switch ($Summary.OverallRisk) {\n        'CRITICAL' { '#dc3545' }\n        'HIGH' { '#fd7e14' }\n        'MEDIUM' { '#ffc107' }\n        'LOW' { '#28a745' }\n    }\n    \n    $htmlContent = @\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Infrastructure Audit Report - $CustomerName</title>\n    <style>\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 10px; background: #f8f9fa; line-height: 1.4; }\n        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .header { margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; border-radius: 6px; display: flex; align-items: center; justify-content: space-between; }\n        .header-content { text-align: center; flex: 1; }\n        .header-info { text-align: right; width: 250px; }\n        .logo { max-height: 80px; max-width: 250px; }\n        .risk-banner { text-align: center; padding: 10px; margin: 10px 0; border-radius: 6px; color: white; font-size: 1.3em; font-weight: bold; background: $riskColor; }\n        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0; }\n        .metric-card { background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .metric-number { font-size: 2.0em; font-weight: bold; margin: 5px 0; }\n        .critical { color: #dc3545; }\n        .high { color: #fd7e14; }\n        .medium { color: #ffc107; color: #333; }\n        .low { color: #28a745; }\n        table { width: 100%; border-collapse: collapse; margin: 10px 0; }\n        th, td { padding: 8px; text-align: left; border: 1px solid #dee2e6; }\n        th { background: #495057; color: white; }\n        tr:nth-child(even) { background: #f8f9fa; }\n        .section { margin: 20px 0; }\n        .section h2 { color: #495057; border-bottom: 2px solid #dee2e6; padding-bottom: 6px; font-size: 1.6em; margin: 10px 0; }\n        \n        /* Detailed Findings Styling */\n        .findings-container { margin: 10px 0; }\n        .finding-group { margin: 15px 0; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 4px rgba(0,0,0,0.1); }\n        .finding-group-title { background: #495057; color: white; margin: 0; padding: 12px; font-size: 1.2em; font-weight: bold; }\n        .critical-section .finding-group-title { background: #dc3545; }\n        .high-section .finding-group-title { background: #fd7e14; }\n        .medium-section .finding-group-title { background: #ffc107; color: #333; }\n        .low-section .finding-group-title { background: #28a745; }\n        .passed-section .finding-group-title { background: #17a2b8; }\n        \n        .finding-item { background: white; border-bottom: 1px solid #dee2e6; padding: 15px; }\n        .finding-item:last-child { border-bottom: none; }\n        \n        /* Collapsible Findings */\n        .finding-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 8px; transition: background-color 0.3s; }\n        .finding-header:hover { background: #e9ecef; }\n        .finding-title { font-weight: bold; color: #495057; margin: 0; }\n        .finding-toggle { font-size: 1.2em; font-weight: bold; color: #6c757d; transition: transform 0.3s; }\n        .finding-content { display: none; padding: 12px; background: white; border-radius: 5px; border: 1px solid #dee2e6; }\n        .finding-content.show { display: block; }\n        .finding-toggle.open { transform: rotate(45deg); }\n        .finding-header { margin-bottom: 10px; }\n        .finding-header h4 { margin: 0 0 6px 0; font-size: 1.2em; color: #333; }\n        .finding-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }\n        .finding-id, .finding-category, .finding-type { \n            background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; color: #666; \n        }\n        .severity-badge { \n            padding: 6px 12px; border-radius: 20px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; \n        }\n        .severity-badge.critical { background: #dc3545; color: white; }\n        .severity-badge.high { background: #fd7e14; color: white; }\n        .severity-badge.medium { background: #ffc107; color: #333; }\n        .severity-badge.low { background: #28a745; color: white; }\n        \n        .finding-content { margin-top: 10px; }\n        .description-section, .impact-section, .recommendation-section, .evidence-section { \n            margin: 10px 0; padding: 10px; border-radius: 5px; \n        }\n        .description-section { background: #f8f9fa; border-left: 4px solid #007bff; }\n        .impact-section { background: #fff5f5; border-left: 4px solid #dc3545; }\n        .recommendation-section { background: #f0f9ff; border-left: 4px solid #10b981; }\n        .evidence-section { background: #fffbeb; border-left: 4px solid #f59e0b; }\n        \n        .finding-content h5 { \n            margin: 0 0 6px 0; font-size: 1.0em; color: #333; font-weight: 600; \n        }\n        .finding-content p { margin: 0; color: #555; }\n        .evidence-data { \n            background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 4px; \n            font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85em; margin: 6px 0 0 0;\n            white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; \n        }\n        .compliance-tag { \n            background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; \n            font-size: 0.9em; font-weight: 500; \n        }\n        .finding-footer { \n            margin-top: 20px; padding-top: 15px; border-top: 1px solid #e5e7eb; \n            font-size: 0.95em; color: #6b7280; \n        }\n        \n        /* Executive Summary Styling */\n        .executive-summary { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }\n        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; margin-bottom: 15px; }\n        .summary-card { background: white; padding: 12px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .summary-card h3 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .summary-card ul { margin: 0; padding-left: 15px; }\n        .summary-card li { margin: 4px 0; color: #555; }\n        .risk-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; }\n        .risk-level.critical { background: #dc3545; color: white; }\n        .risk-level.high { background: #fd7e14; color: white; }\n        .risk-level.medium { background: #ffc107; color: #333; }\n        .risk-level.low { background: #28a745; color: white; }\n        .key-findings { margin: 15px 0; }\n        .concern-list { margin: 10px 0; }\n        .concern-item { display: flex; align-items: flex-start; margin: 8px 0; padding: 10px; background: white; border-radius: 5px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }\n        .concern-icon { font-size: 1.1em; margin-right: 10px; flex-shrink: 0; }\n        .concern-content { flex: 1; color: #555; }\n        .concern-content strong { color: #333; }\n        .concern-content small { color: #777; }\n        .compliance-overview { margin: 25px 0; }\n        .compliance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }\n        .compliance-item { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .compliance-item h4 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .compliance-item p { margin: 0; color: #666; font-size: 0.95em; }\n        \n        .report-links { text-align: center; margin: 30px 0; }\n        .report-links a { display: inline-block; margin: 10px; padding: 12px 25px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold; }\n        .report-links a:hover { background: #0056b3; }\n        \n        /* Domain Controller Health Dashboard */\n        .dc-dashboard { margin: 25px 0; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }\n        .dc-dashboard-header { background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; padding: 15px; border-radius: 8px 8px 0 0; }\n        .dc-dashboard-header h2 { margin: 0; font-size: 1.5em; display: flex; align-items: center; }\n        .dc-dashboard-header .dc-count { background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 15px; margin-left: 15px; font-size: 0.9em; }\n        .dc-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px; padding: 20px; }\n        .dc-card { border: 1px solid #dee2e6; border-radius: 6px; overflow: hidden; }\n        .dc-card-header { padding: 12px 15px; font-weight: bold; color: white; display: flex; justify-content: space-between; align-items: center; }\n        .dc-card-header.healthy { background: #28a745; }\n        .dc-card-header.warning { background: #ffc107; color: #333; }\n        .dc-card-header.critical { background: #dc3545; }\n        .dc-card-body { padding: 15px; background: #f8f9fa; }\n        .dc-info-row { display: flex; justify-content: space-between; margin: 5px 0; }\n        .dc-info-label { font-weight: 600; color: #495057; }\n        .dc-info-value { color: #28a745; }\n        .dc-info-value.warning { color: #856404; }\n        .dc-info-value.failed { color: #dc3545; }\n        .dc-services { margin-top: 10px; }\n        .dc-service { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-service.running { background: #d4edda; color: #155724; }\n        .dc-service.stopped { background: #f8d7da; color: #721c24; }\n        .dc-tests { margin-top: 10px; }\n        .dc-test { display: inline-block; margin: 2px; padding: 3px 8px; border-radius: 12px; font-size: 0.8em; }\n        .dc-test.passed { background: #d4edda; color: #155724; }\n        .dc-test.failed { background: #f8d7da; color: #721c24; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <div class=\"logo-container\">\n                <img src=\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/Pgo8IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDIwMDEwOTA0Ly9FTiIKICJodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAxL1JFQy1TVkctMjAwMTA5MDQvRFREL3N2ZzEwLmR0ZCI+CjxzdmcgdmVyc2lvbj0iMS4wIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiB3aWR0aD0iOTAwLjAwMDAwMHB0IiBoZWlnaHQ9IjE3NC4wMDAwMDBwdCIgdmlld0JveD0iMCAwIDkwMC4wMDAwMDAgMTc0LjAwMDAwMCIKIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPgo8bWV0YWRhdGE+CkNyZWF0ZWQgYnkgcG90cmFjZSAxLjEwLCB3cml0dGVuIGJ5IFBldGVyIFNlbGluZ2VyIDIwMDEtMjAxMQo8L21ldGFkYXRhPgo8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjAwMDAwMCwxNzQuMDAwMDAwKSBzY2FsZSgwLjEwMDAwMCwtMC4xMDAwMDApIgpmaWxsPSIjZmZmZmZmIiBzdHJva2U9Im5vbmUiPgo8cGF0aCBkPSJNNTgwNiAxNTA4IGMtMTMgLTQ0IC0yNiAtMTI1IC0yNiAtMTU2IDAgLTIwIC03IC02MiAtMTUgLTkyIC04IC0zMAotMTUgLTc2IC0xNSAtMTAxIDAgLTI2IC03IC02MyAtMTUgLTgyIC04IC0yMCAtMTUgLTU2IC0xNSAtNzkgMCAtMjQgLTcgLTY1Ci0xNSAtOTIgLTggLTI3IC0xNSAtNjIgLTE1IC03OCAwIC0yOCAxIC0yOCA2MCAtMjggbDU5IDAgNiAzOCBjMyAyMCAxMCA1NiAxNgo3OSA1IDIzIDkgNjEgOSA4NSAxIDg4IDY1IDE1NSAxMjggMTMyIDI3IC0xMCAyNyAtMTEgMjQgLTg5IC0xIC00NCAtOSAtMTAwCi0xNyAtMTI1IC04IC0yNSAtMTUgLTYxIC0xNyAtODAgbC0zIC0zNSA2MyAtMyA2MiAtMyAwIDM3IGMwIDIwIDcgNjIgMTUgOTQgOAozMiAxNiAxMDEgMTggMTU0IDIgODcgMCA5NyAtMjEgMTE4IC0xOSAxOSAtMzMgMjMgLTg1IDIzIC00MyAwIC03MSAtNiAtOTAKLTE3IC0xNCAtMTAgLTMxIC0xOCAtMzcgLTE4IC0xNSAwIC0xMiA0MiA1IDgzIDggMjAgMTUgNTIgMTUgNzAgMCAxOSA3IDU0IDE1Cjc3IDggMjMgMTUgNTUgMTUgNzEgMCAyOSAtMSAyOSAtNjAgMjkgLTQwIDAgLTYyIC00IC02NCAtMTJ6Ii8+CjxwYXRoIGQ9Ik03MTgwIDE0NTMgYy02IC0zNyAtMTYgLTk5IC0yMCAtMTM4IC00IC0zOCAtMTMgLTg2IC0xOSAtMTA1IC02IC0xOQotMTEgLTU3IC0xMSAtODUgMCAtNDYgLTE1IC0xMzAgLTQxIC0yMzAgLTYgLTIyIC0xMyAtNTMgLTE2IC02OCBsLTUgLTI4IDYzIDMKNjQgMyA4IDQ1IGM0IDI1IDEyIDgxIDE3IDEyNSA5IDgxIDIzIDE1OCA0MSAyMzAgNiAyMiAxNCA2OSAxOSAxMDUgNCAzNiAxMgo3NyAxOCA5MSA2IDE0IDEyIDQ2IDE0IDcwIGwzIDQ0IC02MSAzIC02MSAzIC0xMyAtNjh6Ii8+CjxwYXRoIGQ9Ik0zMjg5IDE0NjcgYy0xNCAtMTIgLTMxIC0zNiAtMzggLTU0IC0xMiAtMjggLTExIC0zNyA2IC02NSAyOCAtNDgKNzQgLTUxIDExOSAtNyAyNyAyNiAzNCA0MSAzNCA3MiAwIDY5IC02OCAxMDAgLTEyMSA1NHoiLz4KPHBhdGggZD0iTTI4NjggMTQzMiBjLTE3IC0zIC0yOCAtNTEgLTI4IC0xMjcgMCAtMjcgLTcgLTcyIC0xNSAtOTkgLTggLTI3Ci0xNSAtNjggLTE1IC05MCAwIC0yMyAtNyAtNjYgLTE1IC05NiAtOCAtMzAgLTE1IC03MyAtMTUgLTk1IDAgLTIyIC03IC01MQotMTUgLTY1IC0zMSAtNTQgLTI0IC02MCA3NSAtNjAgbDkwIDAgMCA0NSBjMCAyNCA0IDY2IDkgOTIgNSAyNiAxMiA2NCAxNiA4NApsNSAzNiA4NyAtMSA4NyAtMSA3IDM1IGM0IDE5IDEwIDUwIDE0IDY4IGw4IDMzIC04NiAtMiBjLTQ4IC0yIC04OSAwIC05MiAzCi0xMSAxMCA3IDEwNyAyMCAxMTIgOCAzIDUxIDEgOTcgLTQgNDYgLTQgODYgLTUgOTAgLTIgMyA0IDggMjcgMTAgNTIgMyAyNSA2CjUyIDkgNjAgMyAxMyAtMjEgMTYgLTE2MiAyMCAtOTIgMyAtMTczIDQgLTE4MSAyeiIvPgo8cGF0aCBkPSJNNDYyNCAxNDI3IGMtOSAtNSAtMTQgLTI0IC0xNCAtNTMgbDAgLTQ1IDY4IDMgYzY2IDMgNjcgMyA2NSAtMjIgLTYKLTY3IC0yMiAtMTU4IC0zMiAtMTgzIC02IC0xNiAtMTEgLTQ3IC0xMSAtNjkgMCAtMjMgLTYgLTY0IC0xNCAtOTIgLTE5IC02NwotMzQgLTE1NSAtMjggLTE2MSAzIC0zIDM0IC01IDY5IC01IGw2MyAwIDAgMzggYzEgMjAgNyA2NCAxNSA5NyA4IDMzIDE1IDc5CjE1IDEwMSAwIDIzIDcgNTggMTUgNzcgOCAyMCAxNSA1NSAxNSA3OCAwIDIyIDcgNjYgMTYgOTYgbDE2IDU1IDU3IC02IGM3NyAtOQoxMDAgMTMgOTIgODkgLTEgMTIgLTM4NSAxNCAtNDA3IDJ6Ii8+CjxwYXRoIGQ9Ik0yNjE0IDEzNjcgYy03MyAtNzUgLTExOCAtMTE0IC0xNjEgLTE0MCAtMTggLTEwIC0zMyAtMjMgLTMzIC0yOCAwCi01IC01IC05IC0xMSAtOSAtNiAwIC0zNyAtMjAgLTY5IC00NSAtMzIgLTI1IC02MSAtNDUgLTY0IC00NSAtNCAwIC0yNSAtMTQKLTQ4IC0zMCAtNDcgLTM0IC03MiAtODIgLTgyIC0xNTcgLTYgLTUxIC02IC01MyAxNyAtNTMgMTQgMCAzMCA3IDM3IDE1IDcgOAoyNCAxNSAzOSAxNSAxNCAxIDM3IDcgNTEgMTUgMTQgOCA0MiAxNCA2MiAxNSAyMCAwIDY3IDcgMTA1IDE2IDM3IDkgODIgMTMgOTkKMTEgMTcgLTMgMzUgLTIgNDEgMSAxMiA5IDIzIDQ5IDMzIDEyNyAxMSA4NiAyOSAxNzAgNTIgMjQ3IDM2IDExOSAxOCAxMzEgLTY4CjQ1eiBtLTE0MiAtMzE5IGMtMTUgLTE1IC0yNiAtNCAtMTggMTggNSAxMyA5IDE1IDE4IDYgOSAtOSA5IC0xNSAwIC0yNHoiLz4KPHBhdGggZD0iTTQxNTYgMTMxMCBjLTcgLTU4IC0xMSAtNjYgLTQ4IC05MyAtOSAtNyAtMjAgLTMzIC0yMyAtNTkgLTcgLTQzIC02Ci00NyAxNiAtNTAgMjcgLTMgMjcgLTYgNiAtMTM4IC04IC00NyAtMTkgLTk4IC0yNiAtMTEzIC0yMiAtNTUgLTE4IC01OCA2NgotNTUgbDc4IDMgNyA0MCBjNSAyMiAxMiA4NCAxOCAxMzkgNSA1NCAxNSAxMDUgMjEgMTEyIDggOSAyMyAxMiA0MyA5IDE3IC0zCjM2IC0yIDQzIDMgMTMgOCAyMSAxMDggOSAxMTkgLTQgNCAtMjMgNiAtNDMgNCAtMzUgLTMgLTM2IC0zIC0yOSAzMSA0IDE4IDEwCjUwIDEzIDcxIGw1IDM3IC03NSAwIC03NCAwIC03IC02MHoiLz4KPHBhdGggZD0iTTM2NjYgMTIzMyBjLTIxIC05IC01MCAtMjcgLTY0IC00MCAtMzMgLTMxIC00MiAtMjkgLTQyIDcgbDAgMzEgLTY3Ci0zIC02OCAtMyAtMTIgLTEwMCBjLTExIC04NyAtMjYgLTE3OSAtNDkgLTI5MiBsLTYgLTMzIDc1IDAgYzg3IDAgODMgLTUgOTQKMTI1IDEwIDEyNyA0NSAxNzcgMTI2IDE4MSAyOSAxIDU1IDMgNTggMyAxMCAyIDMyIDEwOCAyNiAxMjUgLTggMjAgLTIxIDE5Ci03MSAtMXoiLz4KPHBhdGggZD0iTTM4NjQgMTIzNSBjLTEwIC04IC0yNiAtMTUgLTM1IC0xNSAtOSAwIC0yNSAtMTIgLTM1IC0yNyAtMTAgLTE0Ci0yOCAtMzYgLTM5IC00NyAtMTcgLTE3IC0yMCAtMzEgLTE3IC03MyAzIC00NyA4IC01NSAzNyAtNzMgMTggLTExIDQ4IC0yMCA2NwotMjAgNTYgMCA3NyAtNDAgNDAgLTczIC0yNSAtMjMgLTQyIC0yMSAtMTAzIDkgLTUxIDI2IC01MyAyNiAtNjUgOCAtMTkgLTI3Ci0yNiAtMzcgLTQ3IC02MSAtMTggLTIwIC0xNyAtMjEgMTkgLTQ0IDMyIC0yMCA1MSAtMjMgMTMzIC0yMyA4MiAwIDEwMSA0IDEzMwoyMyA2MyAzOCA4OCA4MSA4OCAxNTAgMCA1NyAtMiA2MCAtMzQgODAgLTE4IDEyIC00OSAyMSAtNjggMjEgLTM4IDAgLTU4IDE1Ci01OCA0MiAwIDMxIDQzIDQzIDkyIDI3IDM4IC0xMiA0MiAtMTIgNTIgNiA2IDEwIDIyIDI5IDM0IDQxIGwyNCAyMyAtMzQgMjEKYy00MSAyNSAtMTUzIDI4IC0xODQgNXoiLz4KPHBhdGggZD0iTTMyMjYgMTIxMyBjLTMgLTEwIC0xMCAtNTYgLTE2IC0xMDMgLTYgLTQ3IC0xNiAtMTAwIC0yMSAtMTE4IC05Ci0yOCAtMjEgLTk1IC0zMSAtMTY3IC0zIC0xOCA0IC0yMCA2NiAtMjMgMzggLTIgNzMgMSA3OCA2IDUgNSAxMyA1MSAxOCAxMDMgOAo4MiAyMiAxNjcgNDYgMjg3IGw2IDMyIC03MCAwIGMtNTkgMCAtNzIgLTMgLTc2IC0xN3oiLz4KPHBhdGggZD0iTTUwNjAgMTIyMyBjLTE0IC0yIC0zMiAtMTAgLTQwIC0xNyAtOCAtNyAtMjMgLTE2IC0zMiAtMTkgLTIwIC03Ci03OCAtODQgLTc4IC0xMDIgMCAtNyAtNyAtMjYgLTE1IC00MSAtMzcgLTcxIC01IC0xODQgNjEgLTIyMyA1NCAtMzIgMTgwIC0zMAoyMzMgNCA2NCA0MCA5NCA3NCA4MCA5MSAtMTkgMjMgLTk1IDE4IC0xMTggLTggLTI5IC0zMCAtMTAyIC0zMSAtMTMwIC0xIC0yNQoyNiAtMjggODEgLTUgOTAgOCAzIDc1IDYgMTQ3IDcgbDEzMiAxIDMgNjAgYzQgNjcgLTEyIDEwOCAtNTQgMTM4IC0yNSAxOQotMTM0IDMxIC0xODQgMjB6IG0xMTkgLTEwMCBjMjAgLTI0IDI3IC00MSAyMSAtNDcgLTUgLTUgLTQ2IC0xMSAtOTAgLTEyIC03MgotMiAtODAgLTEgLTgwIDE2IDAgMjQgNjggODAgOTcgODAgMTMgMCAzNCAtMTUgNTIgLTM3eiIvPgo8cGF0aCBkPSJNNTUyMyAxMjIzIGMtMTcgLTIgLTM3IC0xMSAtNDMgLTE5IC03IC04IC0xOCAtMTQgLTI1IC0xNCAtMTUgMCAtOTUKLTg5IC05NSAtMTA2IDAgLTcgLTcgLTI1IC0xNSAtNDAgLTM2IC02OSAtMTAgLTE2NSA2MCAtMjE4IDMwIC0yMyA0MyAtMjYgMTE5Ci0yNiA5NCAwIDk1IDEgMTEyIDY4IDkgMzYgOSA0NSAtMyA0OSAtNyAzIC0yMiAtMiAtMzIgLTExIC0zMCAtMjcgLTg4IC0yMQotMTIyIDEzIC0zNyAzOCAtMzkgODYgLTQgMTQxIDM1IDU2IDY1IDczIDExNyA2NyAxMDIgLTEzIDkzIC0xNyA5NiAzMiAyIDI0Ci0xIDQ4IC02IDUzIC0xMSAxMSAtMTEyIDE4IC0xNTkgMTF6Ii8+CjxwYXRoIGQ9Ik02Mzk1IDEyMjMgYy0xMSAtMyAtMjggLTEyIC0zOCAtMjEgLTE3IC0xNiAtMjAgLTE1IC0zMiAxIC05IDEzIC0yNwoxNyAtNjkgMTcgbC01NiAwIDAgLTQ1IGMwIC0yNCAtNyAtNzAgLTE1IC0xMDIgLTggLTMxIC0xNSAtNzQgLTE1IC05NCAwIC0yMAotNyAtNTMgLTE1IC03MiAtOCAtMjAgLTE1IC01MiAtMTUgLTcyIGwwIC0zNSA1OCAwIDU4IDAgMTMgNzMgYzcgMzkgMTYgOTcgMTkKMTI3IDExIDkyIDUwIDE0MCAxMTIgMTQwIDM5IDAgNTEgLTI3IDQ0IC05OCAtMyAtMzcgLTEyIC04NyAtMTkgLTExMiAtOCAtMjUKLTE2IC02MyAtMTcgLTg1IGwtMyAtNDAgNjMgLTMgNjIgLTMgMCAzOCBjMCAyMSA3IDcxIDE2IDExMiA4IDQxIDE2IDExMCAxNwoxNTIgMiA2OCAtMSA4MSAtMTkgOTkgLTIxIDIyIC0xMDcgMzUgLTE0OSAyM3oiLz4KPHBhdGggZD0iTTY3OTggMTIyMyBjLTIwIC0yIC00MiAtMTEgLTQ4IC0xOSAtNyAtOCAtMTggLTE0IC0yNCAtMTQgLTE0IDAgLTY1Ci01NCAtODUgLTkwIC0yNSAtNDMgLTM3IC0xMzEgLTI2IC0xODAgMTMgLTU3IDE4IC02NiA2NiAtOTUgMzMgLTIxIDUxIC0yNQoxMTggLTI1IDk2IDAgMTQ0IDIxIDE5OCA4NiA2NCA3NiA4NSAxNjkgNTQgMjM2IC0zMCA2NyAtNzcgOTggLTE1MyAxMDIgLTM1IDIKLTgwIDIgLTEwMCAtMXogbTEyNiAtMTI3IGMzMSAtNDIgMzMgLTczIDUgLTEyMCAtNDQgLTc0IC0xMTkgLTEwNiAtMTY1IC02OAotNTUgNDcgLTQ5IDEzMCAxNiAxODkgMjggMjYgNDQgMzMgNzYgMzMgMzYgMCA0NSAtNSA2OCAtMzR6Ii8+CjxwYXRoIGQ9Ik03NDYzIDEyMjMgYy0xNyAtMiAtMzcgLTExIC00MyAtMTkgLTcgLTggLTE4IC0xNCAtMjQgLTE0IC0xOCAwIC04MAotNzAgLTk5IC0xMTMgLTI2IC01OCAtMjMgLTE2OSA1IC0yMDggNDAgLTU0IDc2IC02OSAxNjUgLTY5IDE1NiAwIDI0NyA4NiAyNjAKMjQ2IDYgNzIgLTExIDExMSAtNjYgMTUyIC0zMSAyMyAtMTI5IDM1IC0xOTggMjV6IG0xMjUgLTExNyBjMTcgLTE4IDIyIC0zNgoyMiAtNzQgMCAtNDcgLTQgLTU0IC00NiAtOTYgLTUzIC01MyAtODcgLTU5IC0xMzQgLTI0IC0yOCAyMCAtMzAgMjcgLTMwIDg0IDAKNjEgMSA2MyA0MyA5OCA1MyA0NSAxMDkgNDkgMTQ1IDEyeiIvPgo8cGF0aCBkPSJNNzk0MSAxMjIzIGMtOTMgLTE5IC0xNTkgLTExNiAtMTc2IC0yNTMgLTYgLTQ3IC0zIC02MiAxNSAtOTMgMzEKLTUyIDc2IC03NyAxNDAgLTc3IDM3IDAgNTkgNiA3NyAyMCAzNSAyNyA2MyAyNiA2MyAtMiAwIC0xMyAtNyAtMzIgLTE1IC00MgotOCAtMTEgLTE1IC0yOCAtMTUgLTM3IDAgLTIzIC02MCAtNTkgLTk4IC01OSAtMjMgMCAtMzggOSAtNjQgMzkgLTI4IDMzIC00MQo0MCAtODEgNDQgLTM5IDQgLTQ5IDEgLTU4IC0xNCAtMjEgLTQxIDE5IC0xMDIgOTEgLTEzOSA1MyAtMjcgMTU2IC0yNyAyMDkgMAo0NiAyMyAxMjEgMTA3IDEyMSAxMzUgMSAxMSA3IDMxIDE1IDQ1IDggMTQgMTQgNDYgMTUgNzEgMCAyNSA3IDY4IDE1IDk1IDggMjcKMTUgNzAgMTUgOTUgMCAyNiA3IDY2IDE1IDg5IDI2IDc0IDIzIDgwIC00MCA4MCAtNDAgMCAtNTcgLTQgLTYxIC0xNSAtOCAtMTkKLTIzIC0xOSAtNDQgMCAtMTggMTYgLTk4IDI3IC0xMzkgMTh6IG0xMjkgLTExNCBjMjIgLTE5IDI1IC0yOSAyNSAtODIgLTEgLTU4Ci0yIC02MSAtNDUgLTk4IC01NyAtNDkgLTkyIC01MSAtMTM3IC03IC0yNCAyMyAtMzMgNDEgLTMzIDY1IDAgMzggMzYgMTAxIDcxCjEyNiAzNCAyMyA4OSAyMSAxMTkgLTR6Ii8+CjxwYXRoIGQ9Ik04NjgwIDEyMjMgYy00MyAtNCAtODAgLTI1IC04MCAtNDYgMCAtNSAtMTMgLTI4IC0yOCAtNTEgLTE1IC0yMgotMzcgLTYwIC00OCAtODQgLTE2IC0zNSAtMjMgLTQyIC00NCAtNDAgLTIyIDMgLTI2IDkgLTMxIDU4IC0zIDMxIC0xMSA2NSAtMTcKNzcgLTcgMTIgLTEyIDM1IC0xMiA1MiBsMCAzMSAtNzUgMCBjLTQxIDAgLTc1IC00IC03NSAtOSAwIC01IDYgLTIyIDE0IC0zOAozMSAtNjUgNjUgLTE1MiA3MyAtMTkzIDMgLTE0IDEyIC0zMyAyMCAtNDIgMzIgLTM3IDIxIC03OSAtNDUgLTE2NSAtMzQgLTQ1Ci02MiAtODUgLTYyIC04OSAwIC01IC0xNCAtMjMgLTMxIC00MCAtNDAgLTQxIC0zNCAtNzAgMTIgLTYwIDE4IDMgNDYgNiA2MyA2CjI5IDAgMzkgMTIgMTY2IDIwMSA3NCAxMTAgMTQxIDIxMSAxNDggMjI1IDcgMTMgMTcgMjQgMjMgMjQgNSAwIDkgNiA5IDEzIDAgNgoyNSA0MiA1NSA4MCAzMCAzNyA1NSA3MSA1NSA3NiAwIDkgLTI2IDIyIC0zOCAxOSAtNCAtMSAtMjcgLTMgLTUyIC01eiIvPgo8cGF0aCBkPSJNMjAxOSA5NDMgYy0zMSAtMjMgLTU5IC00MCAtODQgLTUzIC0xMSAtNiAtMzMgLTE5IC01MCAtMzAgLTE2IC0xMQotMzcgLTIyIC00NSAtMjYgLTggLTMgLTIyIC05IC0zMCAtMTQgLTggLTUgLTc2IC0zOSAtMTUwIC03NSAtNzQgLTM3IC0xNDcKLTczIC0xNjIgLTgxIC0xNCAtOCAtMzMgLTE0IC00MSAtMTQgLTggMCAtMjAgLTcgLTI3IC0xNSAtNyAtOCAtMjMgLTE1IC0zNQotMTUgLTEyIDAgLTI4IC03IC0zNSAtMTUgLTcgLTggLTIwIC0xNSAtMjkgLTE1IC0xMCAwIC0yNiAtNyAtMzcgLTE1IC0xMCAtOAotMjcgLTE1IC0zNiAtMTUgLTkgMCAtMzAgLTcgLTQ3IC0xNSAtMTcgLTggLTQ1IC0yMiAtNjIgLTMwIC0xNyAtOCAtMzggLTE1Ci00OCAtMTUgLTkgMCAtMjYgLTcgLTM3IC0xNSAtMTAgLTggLTI3IC0xNSAtMzcgLTE1IC0xMSAwIC0zMSAtNiAtNDUgLTE0IC0zMAotMTUgLTgxIC0zMyAtMTI3IC00NiAtMzkgLTExIC05MSAtMjkgLTEzMyAtNDYgLTE4IC04IC00MyAtMTQgLTU1IC0xNCAtMTIgLTEKLTMzIC03IC00NyAtMTUgLTE0IC04IC0zOCAtMTQgLTUzIC0xNSAtMTYgMCAtMzggLTUgLTUwIC0xMiAtMjEgLTExIC0zOCAtMTUKLTE2MiAtMzggLTMzIC02IC02OSAtMTUgLTgwIC0yMCAtMTEgLTUgLTMzIC0xNCAtNDkgLTIwIC0yMSAtOCAtMjYgLTE0IC0xOQotMjEgOCAtOCA3MyAtOCAyMjUgMSAxOTYgMTEgMTE2MiAxMCAxMjEzIC0xIDI0IC01IDMzIDI2IDEyIDQ5IC01OSA2OSAtMzUKMjM3IDQ4IDMzMCAzMCAzNSAxMjcgMTEzIDE1NSAxMjUgNzggMzYgMTc3IDk4IDE4NyAxMTggNiAxMyAxNCA0OCAxOCA3NyA4IDU4Ci0zIDY2IC00NiAzNXogbS00ODkgLTQwNSBjMzIgLTI0IDQyIC03MSAxNiAtODEgLTE5IC03IC0zMSAtNjYgLTE3IC04MCAxOAotMTggMTMgLTMwIC0xMCAtMjQgLTE1IDQgLTMwIC0zIC01MSAtMjYgLTI2IC0yOCAtMzEgLTMwIC00MSAtMTYgLTEwIDEzIC0zNwoxNSAtMTY0IDE1IC0xNzQgLTEgLTE5OSA3IC0xNDggNDkgMzcgMzAgMTU5IDkwIDIwMiAxMDAgMTggMyA0OCAxNyA2OCAzMSAyMAoxMyA0NCAyNCA1NCAyNCA5IDAgMjYgNyAzNyAxNSAyNCAxOCAyMCAxOSA1NCAtN3oiLz4KPHBhdGggZD0iTTI0NTUgNjYwIGMtMTYgLTQgLTUxIC04IC03NiAtOSAtMjYgMCAtNjMgLTggLTgyIC0xNiAtMjAgLTggLTUwCi0xNSAtNjYgLTE1IC0xNiAwIC0zOSAtOSAtNTIgLTE5IC0yMSAtMTcgLTIyIC0yMiAtMTEgLTQwIDYgLTExIDEyIC0yOSAxMgotNDAgMCAtMTAgNyAtMjQgMTUgLTMxIDggLTcgMTUgLTIwIDE1IC0zMCAwIC0xMCA3IC0yMyAxNSAtMzAgOCAtNyAxNSAtMTcgMTUKLTIyIDAgLTE1IDg1IC0xMjIgMTI1IC0xNTcgMzAgLTI2IDQ0IC0zMSA3MyAtMjkgMzcgMyAzNyAzIDQ0IDU4IDQgMzAgMTEgNjgKMTcgODMgNiAxNiAxMSA0NSAxMSA2NiAwIDIxIDYgNTYgMTQgNzcgNyAyMiAxNyA2NyAyMSAxMDIgbDcgNjIgLTM0IC0xIGMtMTgKLTEgLTQ2IC01IC02MyAtOXogbS02MiAtMTUzIGMzIC03IDMgLTI1IDAgLTQwIC04IC00MCAtNDAgLTM2IC01MSA2IC01IDE3IC03CjM1IC01IDQwIDcgMTIgNTEgOCA1NiAtNnoiLz4KPHBhdGggZD0iTTI3MDcgNTU3IGMtMTUgLTEwIC0xNiAtMTUgLTUgLTMwIDEyIC0xNiA1OCAtMTcgNzUyIC0xNyA1MzkgMCA3NDIKMyA3NTIgMTEgMTkgMTUgMTggMzUgLTIgNDMgLTkgMyAtMzQ1IDYgLTc0OCA2IC01NzQgMCAtNzM2IC0zIC03NDkgLTEzeiIvPgo8cGF0aCBkPSJNMTk5MCA1MTUgYy03IC04IC0xOSAtMTUgLTI3IC0xNSAtNyAwIC0xNiAtNyAtMTkgLTE1IC00IC04IC0xMCAtMTUKLTE1IC0xNSAtNSAwIC0zMSAtMjMgLTU4IC01MSAtNDAgLTQyIC01MCAtNTkgLTU1IC05OSAtNCAtMjYgLTIgLTU5IDMgLTczCmwxMCAtMjYgOTggNSBjNTQgMyAxMzEgMiAxNzEgLTMgODggLTExIDkxIC00IDMyIDczIC0yMiAyOSAtNDAgNTkgLTQwIDY3IDAgNwotNyAyMiAtMTUgMzMgLTggMTAgLTE1IDM1IC0xNSA1NCAtMSA1OCAtMTAgODAgLTM1IDgwIC0xMiAwIC0yOCAtNyAtMzUgLTE1eiIvPgo8cGF0aCBkPSJNNjAzMSA0OTggYy01IC0xOCAtMTEgLTczIC0xMyAtMTIzIGwtMyAtOTAgMjUgMCBjMjMgMCAyNiA1IDMyIDU1IDQKMzAgMTIgODIgMTggMTE0IDExIDY3IDggNzYgLTI1IDc2IC0xOCAwIC0yNiAtOCAtMzQgLTMyeiIvPgo8cGF0aCBkPSJNNzI2MyA1MTggYy02IC03IC0xMyAtNjQgLTE2IC0xMjUgbC03IC0xMTMgMjUgMCBjMjkgMCAzMiAxMSA0NSAxMjEKMTQgMTI0IDE0IDEyOSAtMTQgMTI5IC0xMyAwIC0yOCAtNiAtMzMgLTEyeiIvPgo8cGF0aCBkPSJNNDk1NSA1MDIgYy02IC00IC0xNiAtNDEgLTIzIC04MiAtNiAtNDEgLTE1IC05MCAtMTggLTEwNyAtNiAtMzIgLTUKLTMzIDI1IC0zMyAxNyAwIDMyIDUgMzIgMTMgMSA2IDMgMTkgNCAyNyAxIDggMyAyMSA0IDI5IDIgMTkgNDAgLTE1IDUyIC00NiA2Ci0xNyAxNyAtMjMgMzkgLTIzIDM5IDAgMzkgMjAgLTEgNzAgLTM1IDQ0IC0zNSA0NiAyNCAxMDMgMzEgMzAgMzAgNTcgLTIgNTcKLTIxIDAgLTQ1IC0yMCAtNjEgLTUxIC0xNiAtMjggLTMwIC0yMyAtMzAgMTAgMCAxNyAtNiAzMSAtMTYgMzUgLTE5IDcgLTE3IDcKLTI5IC0yeiIvPgo8cGF0aCBkPSJNNTYzMSA1MDIgYy0xNiAtNSAtMTQgLTM3IDMgLTUxIDcgLTYgMjEgLTkgMzAgLTUgMzYgMTQgMjcgLTI2IC0xOQotODYgLTI1IC0zMyAtNDMgLTY1IC00MCAtNzAgMyAtNiA0NCAtMTAgOTEgLTEwIDgzIDAgODUgMSA4MiAyMyAtMiAxOCAtMTAgMjMKLTQwIDI1IC0yMSAyIC0zOCA0IC0zOCA2IDAgMTQgMzcgNzAgNjkgMTA2IDI0IDI3IDM2IDQ5IDMxIDU0IC05IDkgLTE0OCAxNQotMTY5IDh6Ii8+CjxwYXRoIGQ9Ik02NDcyIDQ5OCBjLTcgLTcgLTEyIC0yNiAtMTIgLTQyIC0xIC0xNyAtNyAtNTggLTE0IC05MSAtMTUgLTc0IC0xMgotODUgMjQgLTg1IDI5IDAgMjkgMSAzMiA2MyAyIDM0IDcgNjEgMTMgNjEgOCAtMSA0NyAtNjMgNzEgLTExMSA5IC0xOSA2MSAtMTYKNjggMyAzIDkgNiAyOSA2IDQ0IDAgMTYgNyA1NSAxNSA4NyAxMyA0OSAxMyA1OSAxIDcxIC04IDkgLTIyIDExIC0zNSA3IC0xOAotNSAtMjEgLTE0IC0yMSAtNjUgMCAtMzIgLTQgLTYxIC04IC02NCAtMTAgLTYgLTQ2IDQwIC01NiA3MCAtOCAyNiAtNDMgNjQKLTU5IDY0IC03IDAgLTE4IC01IC0yNSAtMTJ6Ii8+CjxwYXRoIGQ9Ik03NDU0IDQ5MyBjLTMgLTEwIC0xMyAtMzEgLTIxIC00OCAtMTAgLTIyIC0xMyAtNTYgLTExIC0xMjUgMyAtODcgNQotOTUgMjMgLTk1IDE5IDAgMjAgNyAyMCAxMDAgMCA4MCA0IDEwNSAxOSAxMjcgMTAgMTYgMTYgMzUgMTIgNDMgLTcgMjEgLTM1CjE5IC00MiAtMnoiLz4KPHBhdGggZD0iTTc5OTYgNTAxIGMtMyAtNSAxIC0yNSA5IC00NSAxNyAtNDAgMjAgLTkyIDYgLTEwMCAtNSAtNCAtMTIgLTI0Ci0xNiAtNDUgLTQgLTIyIC0xMyAtNDIgLTIxIC00NSAtMTkgLTcgLTE4IC0zNSAyIC00MyAyMiAtOCA2NCAzNSA2NCA2NyAwIDE0CjUgMzEgMTEgMzcgMTcgMTcgMTMgMTI4IC03IDE1OCAtMTYgMjUgLTM4IDMzIC00OCAxNnoiLz4KPHBhdGggZD0iTTc1MzkgNDczIGMtMTkgLTUwIC0zMSAtMTczIC0xOCAtMTg5IDE2IC0yMCAzOSAwIDM5IDM1IDAgMjEgOCAzMAo0MCA0NCA0NSAxOSA2MiA1MCA0OCA4NiAtMTIgMzIgLTM3IDUwIC03MSA1MSAtMjEgMCAtMzAgLTcgLTM4IC0yN3ogbTYzIC02NQpjLTIwIC0yMCAtMzYgNSAtMjEgMzMgbDEyIDI0IDEwIC0yMyBjNyAtMTYgNyAtMjYgLTEgLTM0eiIvPgo8cGF0aCBkPSJNNzY3NSA0OTAgYy04IC0xMyAzIC0zMCAyMCAtMzAgMTggMCAyOCAtMzUgMTcgLTU3IC0xNSAtMjggLTIzIC0xMDcKLTEzIC0xMjIgMjQgLTM3IDYxIDM4IDYxIDEyMyAwIDQ2IDMzIDgwIDYxIDYzIDEwIC02IDIxIC0yNCAyNCAtMzkgNCAtMTUgMTEKLTMwIDE2IC0zMyAxMyAtOCAxMSAtNTkgLTIgLTcyIC0xOCAtMTggLTIgLTQzIDI2IC00MyAyMiAwIDI1IDQgMjUgMzggMCAzNAozMSAxMTAgNTEgMTIyIDUgMyAxMCAxNyAxMSAzMCA1IDQxIC0yNSAzNCAtNTEgLTEyIGwtMjQgLTQzIC0xMSAyNiBjLTIxIDUxCi0zMSA1NiAtMTIwIDU4IC00OSAxIC04NyAtMyAtOTEgLTl6Ii8+CjxwYXRoIGQ9Ik04MTk2IDQ2OCBjLTggLTE4IC0xNyAtNjUgLTIxIC0xMDQgLTggLTgxIDIgLTk3IDU3IC05MiAyNSAyIDM0IDgKMzYgMjUgMiAxNiAtMyAyMiAtMjAgMjUgLTE4IDIgLTIyIDggLTIwIDI4IDE1IDEyOCAxNCAxNTAgLTIgMTUwIC0xMCAwIC0yMwotMTQgLTMwIC0zMnoiLz4KPHBhdGggZD0iTTgyOTAgNDg1IGMwIC05IDcgLTE4IDE1IC0yMSAxOCAtNyAyMSAtMTA0IDUgLTEzNCAtMTQgLTI2IC0yIC01MgoyNCAtNDggMTkgMyAyMiAxMiAzMCA4NiA3IDc1IDExIDg0IDMyIDkyIDEzIDUgMjQgMTYgMjQgMjUgMCAxMiAtMTMgMTUgLTY1CjE1IC01MiAwIC02NSAtMyAtNjUgLTE1eiIvPgo8cGF0aCBkPSJNODQ0NSA0NjMgYy0zIC0yMSAtMTAgLTU0IC0xNSAtNzQgLTYgLTIwIC0xMCAtNTMgLTEwIC03MyAwIC0zNCAyCi0zNiAzMyAtMzcgODQgLTMgMTA4IDUgMTM1IDQ0IDM0IDUxIDI5IDk2IC0xMyAxNDAgLTMxIDMyIC00MiAzNyAtODAgMzcgLTQzCjAgLTQ0IC0xIC01MCAtMzd6IG05MiAtMjUgYzEzIC0xMiAyMyAtMzMgMjMgLTQ4IDAgLTM0IC0zNSAtNzIgLTYzIC02OCAtMTkgMwotMjIgOCAtMTkgNDggNiA5NSAxNyAxMDggNTkgNjh6Ii8+CjxwYXRoIGQ9Ik02OTM4IDQ1OCBjLTYgLTEzIC0xMyAtNTggLTE0IC0xMDEgbC0zIC03OCAyNyAzIGMyNCAzIDI3IDggMzAgNDMgMgoyMiAxMCA0OCAxOSA1NyAxOSAyMSAxMCA4MyAtMTMgOTIgLTI1IDEwIC0zMyA3IC00NiAtMTZ6Ii8+CjxwYXRoIGQ9Ik01MzEyIDQwMyBjLTIyIC0yOCAtMzIgLTM0IC0zNSAtMjMgLTMgOCAtOCAyMyAtMTEgMzMgLTkgMjkgLTI2IDIyCi02MCAtMjcgLTEzIC0xOSAtMTQgLTE4IC0yNyAxMCAtMTggMzYgLTUyIDQwIC01NyA2IC0yIC0xMyAyIC0zMCA5IC0zOCA2IC04CjE1IC0yOSAxOCAtNDcgOSAtNDMgNDYgLTUxIDYxIC0xMyAxMiAzMyAzMyAzMyA0OCAxIDE0IC0yOSAzMyAtMzIgNTMgLTcgMjcKMzEgNzAgMTIyIDY0IDEzMiAtMTIgMTkgLTMzIDEwIC02MyAtMjd6Ii8+CjxwYXRoIGQ9Ik01NDMzIDQxMyBjLTQwIC0zOCAtNDggLTY1IC0yOCAtMTAzIDE1IC0yOSAxOCAtMzAgODAgLTMwIDc2IDAgODUgOQo4NSA5NCBsMCA1NiAtMzIgLTEgYy0xOCAtMSAtNDIgMiAtNTQgNiAtMTUgNSAtMjkgLTEgLTUxIC0yMnogbTc1IC02MCBjLTMKLTMyIC00NCAtNDYgLTU0IC0xOSAtMTAgMjYgNCA0NiAzMSA0NiAyMyAwIDI2IC00IDIzIC0yN3oiLz4KPHBhdGggZD0iTTYyMzcgNDMzIGMtNCAtMyAtNyAtMTkgLTcgLTM1IDAgLTQwIC0xNyAtNjggLTQxIC02OCAtMTggMCAtMjAgNAotMTMgNDUgNSAzNyAzIDQ2IC0xMSA1MSAtMjUgMTAgLTM3IC05IC00MyAtNjQgLTYgLTcwIDE2IC04OSA5OCAtODIgMzcgMyA0NQoxNCA2MCA3NSAxMSA0NCAxMSA1NyAwIDcwIC0xMyAxNiAtMzIgMjAgLTQzIDh6Ii8+CjxwYXRoIGQ9Ik02NzQxIDQxNCBjLTI2IC0yMiAtMzEgLTMzIC0zMSAtNzAgMCAtMzMgNSAtNDYgMTkgLTU0IDIzIC0xMiAxMjgKLTE0IDEzNCAtMiAzIDQgNyAzNiA5IDcyIGwzIDY1IC0zNyAwIGMtMjAgMCAtNDAgMyAtNDQgOCAtMTIgMTIgLTIxIDkgLTUzCi0xOXogbTg2IC01MCBjNSAtMTQgLTI0IC00NCAtNDIgLTQ0IC0xNiAwIC0yNiAyNSAtMTggNDYgNiAxNyA1NCAxNiA2MCAtMnoiLz4KPHBhdGggZD0iTTcwNzQgNDIwIGMtNDUgLTI5IC01NyAtMTA3IC0yMCAtMTMyIDIwIC0xNCAxMjYgLTkgMTMyIDUgMyA4IDYgNDAKNyA3MyBsMiA1OSAtMzIgLTIgYy0xNyAtMiAtMzUgMiAtMzggNyAtOSAxNCAtMTYgMTMgLTUxIC0xMHogbTcxIC01MCBjOSAtMTQKLTEzIC01MCAtMzEgLTUwIC0xNyAwIC0yOCAyNCAtMjAgNDUgNiAxNyA0MiAyMCA1MSA1eiIvPgo8cGF0aCBkPSJNNTgzMiA0MTcgYy02IC03IC0xNCAtMzEgLTE4IC01NCAtOCAtNTUgMTggLTgzIDc5IC04MyA1NyAwIDY0IDcgNzgKNjggMTMgNjEgOCA4MiAtMjAgODIgLTE5IDAgLTMxIC0yNSAtMzEgLTY3IDAgLTI2IC0zNyAtNTIgLTQ1IC0zMSAtMyA3IC00IDMxCi0zIDUzIDMgNDIgLTE4IDU5IC00MCAzMnoiLz4KPHBhdGggZD0iTTYzMjQgMzg1IGMtMTAgLTI1IDQgLTQ1IDMwIC00NSAzNCAwIDU2IDEwIDU2IDI2IDAgMzAgLTc2IDQ3IC04NgoxOXoiLz4KPC9nPgo8L3N2Zz4K\" alt=\"First Technology Logo\" class=\"logo\">\n            </div>\n            <div class=\"header-content\">\n                <h1>AD Domain Security & Compliance Audit Report</h1>\n                <p style=\"font-size: 1.3em; font-weight: bold;\">Customer: $CustomerName</p>\n            </div>\n            <div class=\"header-info\">\n                <p>Audit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</p>\n                <p>Auditor/Engineer: $($Summary.TechnicianName)</p>\n            </div>\n        </div>\n        \n        <div class=\"risk-banner\">\n            OVERALL SECURITY RISK: $($Summary.OverallRisk)\n        </div>\n        \n        <div class=\"metrics-grid\">\n            <div class=\"metric-card\">\n                <div class=\"metric-number critical\">$($Summary.CriticalFindings)</div>\n                <div>Critical Issues</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number high\">$($Summary.HighFindings)</div>\n                <div>High Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number medium\">$($Summary.MediumFindings)</div>\n                <div>Medium Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number low\">$($Summary.LowFindings)</div>\n                <div>Low Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\" style=\"color: #17a2b8;\">$($Summary.PassedFindings)</div>\n                <div>Controls Passed</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.IssuesFindings)</div>\n                <div>Issues Found</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.TotalFindings)</div>\n                <div>Total Checks Run</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.PassedFindings)</div>\n                <div>Passed Checks</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$(($script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | Group-Object ComplianceFramework).Count)</div>\n                <div>Compliance Frameworks</div>\n            </div>\n        </div>\n\n        <!-- Domain Controller Health Dashboard -->\n        <div class=\"dc-dashboard\">\n            <div class=\"dc-dashboard-header\">\n                <h2>🖥️ Domain Controller Health Dashboard \n                    <span class=\"dc-count\">$($script:DomainControllerHealthData.Count) Controllers</span>\n                </h2>\n            </div>\n            <div class=\"dc-grid\">\n$(\n    if ($script:DomainControllerHealthData) {\n        foreach ($dc in $script:DomainControllerHealthData) {\n            $statusClass = switch ($dc.Status) {\n                'Healthy' { 'healthy' }\n                'Warning' { 'warning' }\n                'Critical' { 'critical' }\n                default { 'healthy' }\n            }\n            \n            $servicesHtml = ''\n            foreach ($service in $dc.Services.GetEnumerator()) {\n                $serviceClass = if ($service.Value -eq 'Running') { 'running' } else { 'stopped' }\n                $servicesHtml += \"<span class='dc-service $serviceClass'>$($service.Key)</span>\"\n            }\n            \n            $testsHtml = ''\n            foreach ($test in $dc.Tests.GetEnumerator()) {\n                $testClass = if ($test.Value -eq 'Passed') { 'passed' } else { 'failed' }\n                $testsHtml += \"<span class='dc-test $testClass'>$($test.Key)</span>\"\n            }\n            \n            $lastContactTime = $dc.LastContact.ToString('HH:mm:ss')\n            \n            @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header $statusClass\">\n                        <span>$($dc.Name.Split('.')[0])</span>\n                        <span>$($dc.Status.ToUpper())</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Site:</span>\n                            <span class=\"dc-info-value\">$($dc.Site)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Operating System:</span>\n                            <span class=\"dc-info-value\">$($dc.OS)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">IP Address:</span>\n                            <span class=\"dc-info-value\">$($dc.IPv4)</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">FSMO Roles:</span>\n                            <span class=\"dc-info-value\">$(if ($dc.FSMORoles -and $dc.FSMORoles -ne 'None') { $dc.FSMORoles } else { 'None' })</span>\n                        </div>\n                        <div class=\"dc-info-row\">\n                            <span class=\"dc-info-label\">Last Contact:</span>\n                            <span class=\"dc-info-value\">$lastContactTime</span>\n                        </div>\n                        <div class=\"dc-services\">\n                            <strong>Services:</strong><br>\n                            $servicesHtml\n                        </div>\n                        <div class=\"dc-tests\">\n                            <strong>DCDIAG Tests:</strong><br>\n                            $testsHtml\n                        </div>\n                    </div>\n                </div>\n\"@\n        }\n    } else {\n        @\"\n                <div class=\"dc-card\">\n                    <div class=\"dc-card-header healthy\">\n                        <span>Domain Controllers</span>\n                        <span>STATUS UNKNOWN</span>\n                    </div>\n                    <div class=\"dc-card-body\">\n                        <p>Domain controller health data not available. Extended health check may be disabled.</p>\n                    </div>\n                </div>\n\"@\n    }\n)\n            </div>\n        </div>\n\n        \n        <div class=\"section\">\n            <h2>📋 Detailed Security Findings</h2>\n            <div style=\"text-align: right; margin: 10px 0;\">\n                <button onclick=\"expandAll()\" style=\"margin-right: 10px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;\">Expand All</button>\n                <button onclick=\"collapseAll()\" style=\"padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;\">Collapse All</button>\n            </div>\n            <div class=\"findings-container\">\n$(\n    # Group findings by severity for better organization\n    $criticalFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }\n    $highFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'High' }\n    $mediumFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    $lowFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }\n    $passedFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }\n    \n    $allGroupedFindings = @()\n    if ($criticalFindings.Count -gt 0) { $allGroupedFindings += @{Title='🔴 CRITICAL FINDINGS'; Findings=$criticalFindings; Class='critical-section'} }\n    if ($highFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟠 HIGH PRIORITY FINDINGS'; Findings=$highFindings; Class='high-section'} }\n    if ($mediumFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟡 MEDIUM PRIORITY FINDINGS'; Findings=$mediumFindings; Class='medium-section'} }\n    if ($lowFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟢 LOW PRIORITY FINDINGS'; Findings=$lowFindings; Class='low-section'} }\n    if ($passedFindings.Count -gt 0) { $allGroupedFindings += @{Title='✅ SECURITY CONTROLS PASSED'; Findings=$passedFindings; Class='passed-section'} }\n    \n    foreach ($group in $allGroupedFindings) {\n        $output = @\"\n                <div class=\"finding-group $($group.Class)\">\n                    <h3 class=\"finding-group-title\">$($group.Title) ($($group.Findings.Count) Issues)</h3>\n\"@\n        \n        foreach ($finding in $group.Findings) {\n            $severityIcon = switch ($finding.Severity) {\n                'Critical' { '🔴' }\n                'High' { '🟠' }\n                'Medium' { '🟡' }\n                'Low' { '🟢' }\n                'Passed' { '✅' }\n                default { '⚪' }\n            }\n            \n            $evidenceSection = if ($finding.Evidence -and $finding.Evidence.Trim() -ne '') {\n                @\"\n                        <div class=\"evidence-section\">\n                            <h5>📊 Evidence/Data:</h5>\n                            <pre class=\"evidence-data\">$($finding.Evidence)</pre>\n                        </div>\n\"@\n            } else { '' }\n            \n            $complianceSection = if ($finding.ComplianceFramework -and $finding.ComplianceFramework.Trim() -ne '') {\n                \"<p><strong>📝 Compliance Framework:</strong> <span class='compliance-tag'>$($finding.ComplianceFramework)</span></p>\"\n            } else { '' }\n            \n            $output += @\"\n                    <div class=\"finding-item $($finding.Severity.ToLower())-finding\">\n                        <div class=\"finding-header\" onclick=\"toggleFinding('$($finding.ID)')\">\n                            <div>\n                                <h4 class=\"finding-title\">$severityIcon $($finding.Title)</h4>\n                                <div class=\"finding-meta\">\n                                    <span class=\"finding-id\">ID: $($finding.ID)</span>\n                                    <span class=\"finding-category\">$($finding.Category)</span>\n                                    <span class=\"finding-type\">$($finding.Type)</span>\n                                    <span class=\"severity-badge $($finding.Severity.ToLower())\">$($finding.Severity.ToUpper())</span>\n                                </div>\n                            </div>\n                            <span class=\"finding-toggle\" id=\"toggle-$($finding.ID)\">+</span>\n                        </div>\n                        \n                        <div class=\"finding-content\" id=\"content-$($finding.ID)\">\n                            <div class=\"description-section\">\n                                <h5>📋 Description:</h5>\n                                <p>$($finding.Description)</p>\n                            </div>\n                            \n                            <div class=\"impact-section\">\n                                <h5>⚠️ Business Impact:</h5>\n                                <p>$($finding.Impact)</p>\n                            </div>\n                            \n                            <div class=\"recommendation-section\">\n                                <h5>🔧 Recommended Action:</h5>\n                                <p>$($finding.Recommendation)</p>\n                            </div>\n                            \n                            $evidenceSection\n                            \n                            <div class=\"finding-footer\">\n                                $complianceSection\n                                <p><strong>⏰ Discovered:</strong> $($finding.Timestamp.ToString('yyyy-MM-dd HH:mm:ss'))</p>\n                            </div>\n                        </div>\n                    </div>\n\"@\n        }\n        \n        $output += @\"\n                </div>\n\"@\n        $output\n    }\n)\n            </div>\n        </div>\n        \n\n\n        <div class=\"section\">\n            <h2>📊 Executive Summary & Risk Analysis</h2>\n            <div class=\"executive-summary\">\n                <div class=\"summary-grid\">\n                    <div class=\"summary-card\">\n                        <h3>🔍 Audit Scope</h3>\n                        <ul>\n                            <li><strong>Customer:</strong> $CustomerName</li>\n                            <li><strong>Audit Date:</strong> $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</li>\n                            <li><strong>Engineer/Auditor:</strong> $($Summary.TechnicianName)</li>\n                            <li><strong>Systems Assessed:</strong> Active Directory Infrastructure</li>\n                            <li><strong>Note:</strong> Server infrastructure audit temporarily disabled</li>\n                        </ul>\n                    </div>\n                    \n                    <div class=\"summary-card\">\n                        <h3>⚠️ Risk Assessment</h3>\n                        <div class=\"risk-summary\">\n                            <p><strong>Overall Risk Level:</strong> <span class=\"risk-level $($Summary.OverallRisk.ToLower())\">$($Summary.OverallRisk)</span></p>\n                            <p><strong>Priority Actions:</strong> $($Summary.CriticalFindings + $Summary.HighFindings) immediate items</p>\n                            <p><strong>Total Findings:</strong> $($Summary.TotalFindings) security issues identified</p>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"key-findings\">\n                    <h3>🎯 Key Security Concerns</h3>\n                    <div class=\"concern-list\">\n$(\n    $topConcerns = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Sort-Object @{Expression={if($_.Severity -eq 'Critical'){1}else{2}}}, Title | Select-Object -First 5\n    if ($topConcerns.Count -gt 0) {\n        foreach ($concern in $topConcerns) {\n            $icon = if ($concern.Severity -eq 'Critical') { '🔴' } else { '🟠' }\n            @\"\n                        <div class=\"concern-item\">\n                            <span class=\"concern-icon\">$icon</span>\n                            <div class=\"concern-content\">\n                                <strong>$($concern.Category):</strong> $($concern.Title)\n                                <br><small>$($concern.Impact)</small>\n                            </div>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"concern-item\"><span class=\"concern-icon\">✅</span><div class=\"concern-content\">No critical security concerns identified</div></div>'\n    }\n)\n                    </div>\n                </div>\n                \n                <div class=\"compliance-overview\">\n                    <h3>📋 Compliance Framework Analysis</h3>\n                    <div class=\"compliance-grid\">\n$(\n    $complianceStats = $script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | \n        Group-Object ComplianceFramework | Sort-Object Count -Descending\n    \n    if ($complianceStats.Count -gt 0) {\n        foreach ($framework in $complianceStats) {\n            $criticalCount = ($framework.Group | Where-Object { $_.Severity -eq 'Critical' }).Count\n            $highCount = ($framework.Group | Where-Object { $_.Severity -eq 'High' }).Count\n            @\"\n                        <div class=\"compliance-item\">\n                            <h4>$($framework.Name)</h4>\n                            <p>$($framework.Count) findings ($criticalCount critical, $highCount high priority)</p>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"compliance-item\"><h4>General Security</h4><p>Compliance framework mapping in progress</p></div>'\n    }\n)\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        \n        <div style=\"text-align: center; margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 10px;\">\n            <p><strong>Audit Summary</strong></p>\n            <p>This comprehensive audit assessed $($Summary.TotalFindings) security and compliance findings across the Active Directory infrastructure.</p>\n            <hr style=\"margin: 20px 0; border: none; border-top: 1px solid #dee2e6;\">\n            <p style=\"color: #666; font-size: 0.9em; margin-top: 15px;\">\n                <strong>Creator:</strong> Nishen Harichunder L4 Engineering : RMS<br>\n                <strong>Framework:</strong> First Technology Security Framework<br>\n                <strong>Generated:</strong> $($Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss'))\n            </p>\n        </div>\n    </div>\n\n    <script>\n        // Collapsible findings functionality\n        function toggleFinding(findingId) {\n            const content = document.getElementById('content-' + findingId);\n            const toggle = document.getElementById('toggle-' + findingId);\n            \n            if (content.classList.contains('show')) {\n                content.classList.remove('show');\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            } else {\n                content.classList.add('show');\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            }\n        }\n        \n        // Expand/Collapse all functions\n        function expandAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.add('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            });\n        }\n        \n        function collapseAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.remove('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            });\n        }\n        \n        console.log('Infrastructure Audit Report loaded successfully');\n        console.log('Total findings: $($Summary.TotalFindings)');\n        console.log('Risk level: $($Summary.OverallRisk)');\n        \n        // Initialize all findings as collapsed by default\n        document.addEventListener('DOMContentLoaded', function() {\n            collapseAll();\n        });\n    </script>\n</body>\n</html>\n\"@\n    \n    # Protect HTML source code with password encryption\n    $protectedHtml = Protect-HtmlSource -HtmlContent $htmlContent -Password \"Nlf263nish25!\"\n    $protectedHtml | Out-File -FilePath $htmlPath -Encoding UTF8\n    Write-AuditLog \"Protected HTML report saved: $htmlPath\" -Level Success\n}\n\nfunction New-ExcelReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Excel report...' -Level Info\n    \n    try {\n        $excelPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.xlsx'\n        \n        # Check if ImportExcel module is available\n        if (-not (Get-Module -ListAvailable -Name ImportExcel)) {\n            Write-AuditLog \"ImportExcel module not available, skipping Excel export\" -Level Warning\n            return\n        }\n        \n        Import-Module ImportExcel -SkipEditionCheck -ErrorAction SilentlyContinue\n        \n        # Summary sheet\n        $summaryData = [PSCustomObject]@{\n            'Metric' = 'Customer Name'; 'Value' = $Summary.CustomerName\n        }, [PSCustomObject]@{\n            'Metric' = 'Audit Date'; 'Value' = $Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss')\n        }, [PSCustomObject]@{\n            'Metric' = 'Technician'; 'Value' = $Summary.TechnicianName\n        }, [PSCustomObject]@{\n            'Metric' = 'Overall Risk Level'; 'Value' = $Summary.OverallRisk\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Findings'; 'Value' = $Summary.TotalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Critical Findings'; 'Value' = $Summary.CriticalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'High Findings'; 'Value' = $Summary.HighFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Servers'; 'Value' = $Summary.TotalServers\n        }, [PSCustomObject]@{\n            'Metric' = 'Online Servers'; 'Value' = $Summary.OnlineServers\n        }, [PSCustomObject]@{\n            'Metric' = 'High Risk Servers'; 'Value' = $Summary.HighRiskServers\n        }\n        \n        $summaryData | Export-Excel -Path $excelPath -WorksheetName 'Summary' -AutoSize -BoldTopRow\n        \n        # Findings sheet\n        $script:AuditFindings | Export-Excel -Path $excelPath -WorksheetName 'Security Findings' -AutoSize -BoldTopRow\n        \n        # Server results sheet\n        $script:ServerResults | Export-Excel -Path $excelPath -WorksheetName 'Server Status' -AutoSize -BoldTopRow\n        \n        Write-AuditLog \"Excel report saved: $excelPath\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating Excel report: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\nfunction New-CSVReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating CSV reports...' -Level Info\n    \n    # Findings CSV\n    $findingsPath = Join-Path $script:OutputDir 'Audit-Findings.csv'\n    $script:AuditFindings | Export-Csv -Path $findingsPath -NoTypeInformation\n    \n    # Server status CSV\n    $serversPath = Join-Path $script:OutputDir 'Server-Status.csv'\n    $script:ServerResults | Export-Csv -Path $serversPath -NoTypeInformation\n    \n    Write-AuditLog \"CSV reports saved: $findingsPath, $serversPath\" -Level Success\n}\n\nfunction New-MarkdownReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Markdown report...' -Level Info\n    \n    $markdownPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.md'\n    \n    $markdownContent = @\"\n# Infrastructure Security Audit Report\n\n**Customer:** $CustomerName  \n**Audit Date:** $($Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss'))  \n**Technician:** $($Summary.TechnicianName)  \n**Overall Risk Level:** **$($Summary.OverallRisk)**\n\n## Executive Summary\n\nThis infrastructure audit assessed $($Summary.TotalServers) servers and identified $($Summary.TotalFindings) security and configuration findings.\n\n### Key Metrics\n\n| Metric | Count |\n|--------|-------|\n| Critical Findings | $($Summary.CriticalFindings) |\n| High Priority Findings | $($Summary.HighFindings) |\n| Medium Priority Findings | $($Summary.MediumFindings) |\n| Low Priority Findings | $($Summary.LowFindings) |\n| Total Servers Audited | $($Summary.TotalServers) |\n| Online Servers | $($Summary.OnlineServers) |\n| High Risk Servers | $($Summary.HighRiskServers) |\n\n## Security Findings\n\n$(\n    $script:AuditFindings | ForEach-Object {\n        @\"\n### $($_.Title) [$($_.Severity)]\n\n**Category:** $($_.Category)  \n**Type:** $($_.Type)  \n**Compliance Framework:** $($_.ComplianceFramework)\n\n**Description:** $($_.Description)\n\n**Impact:** $($_.Impact)\n\n**Recommendation:** $($_.Recommendation)\n\n$(if ($_.Evidence) { \"**Evidence:**`n``````n$($_.Evidence)`n``````n\" })\n\n---\n\"@\n    }\n)\n\n## Server Infrastructure Status\n\n| Server Name | Status | Operating System | Risk Score | Security Issues | Performance Issues |\n|-------------|--------|------------------|------------|-----------------|-------------------|\n$(\n    $script:ServerResults | ForEach-Object {\n        \"| $($_.ServerName) | $($_.PingStatus) | $($_.OperatingSystem) | $($_.RiskScore) | $($_.SecurityIssues.Count) | $($_.PerformanceIssues.Count) |\"\n    }\n)\n\n## Recommendations Summary\n\n### Immediate Actions Required (Critical/High)\n$(\n    $criticalAndHigh = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') }\n    if ($criticalAndHigh.Count -gt 0) {\n        $criticalAndHigh | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\n### Short-term Improvements (Medium)\n$(\n    $medium = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    if ($medium.Count -gt 0) {\n        $medium | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No medium priority items identified\"\n    }\n)\n\n---\n\n*Report generated by Master Infrastructure Audit Script v$($script:Version)*  \n*Audit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes*\n\"@\n    \n    $markdownContent | Out-File -FilePath $markdownPath -Encoding UTF8\n    Write-AuditLog \"Markdown report saved: $markdownPath\" -Level Success\n}\n\nfunction New-ExecutiveSummary {\n    param($Summary)\n    \n    Write-AuditLog 'Generating executive summary...' -Level Info\n    \n    $execSummaryPath = Join-Path $script:OutputDir 'Executive-Summary.txt'\n    \n    $execSummary = @\"\nINFRASTRUCTURE SECURITY AUDIT - EXECUTIVE SUMMARY\n================================================================\n\nCustomer: $CustomerName\nAudit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))\nEngineer/Auditor: $($Summary.TechnicianName)\nAudit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes\n\nOVERALL RISK ASSESSMENT: $($Summary.OverallRisk)\n\nFINDINGS SUMMARY:\n- Critical Issues: $($Summary.CriticalFindings)\n- High Priority: $($Summary.HighFindings)  \n- Medium Priority: $($Summary.MediumFindings)\n- Low Priority: $($Summary.LowFindings)\n- Total Findings: $($Summary.TotalFindings)\n\nINFRASTRUCTURE SUMMARY:\n- Total Servers: $($Summary.TotalServers)\n- Online Servers: $($Summary.OnlineServers)\n- Offline Servers: $($Summary.OfflineServers)\n- High Risk Servers: $($Summary.HighRiskServers)\n\nIMMEDIATE ACTIONS REQUIRED:\n$(\n    $immediateActions = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Select-Object -First 5\n    if ($immediateActions.Count -gt 0) {\n        $immediateActions | ForEach-Object { \"- $($_.Category): $($_.Title)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\nCOMPLIANCE ASSESSMENT:\n$(\n    $frameworks = $script:AuditFindings | Group-Object ComplianceFramework | Where-Object { $_.Name -ne '' }\n    if ($frameworks.Count -gt 0) {\n        $frameworks | ForEach-Object { \"- $($_.Name): $($_.Count) findings\" }\n    } else {\n        \"- Compliance frameworks assessment pending\"\n    }\n)\n\nThis executive summary provides a high-level overview of the infrastructure \nsecurity assessment. Detailed findings, recommendations, and remediation \nprocedures are available in the comprehensive audit reports.\n\n================================================================\n\"@\n    \n    $execSummary | Out-File -FilePath $execSummaryPath -Encoding UTF8\n    Write-AuditLog \"Executive summary saved: $execSummaryPath\" -Level Success\n}\n\n# ==============================================================================\n# MAIN EXECUTION LOGIC\n# ==============================================================================\n\nfunction Start-MasterInfrastructureAudit {\n    # Display banner\n    Write-Host \"\"\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"MASTER INFRASTRUCTURE AUDIT SCRIPT v$($script:Version)\" -ForegroundColor Cyan\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"Customer: $CustomerName\" -ForegroundColor White\n    Write-Host \"Technician: $TechnicianName\" -ForegroundColor White\n    Write-Host \"Start Time: $($script:StartTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -ForegroundColor White\n    Write-Host \"Output Directory: $script:OutputDir\" -ForegroundColor White\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"\"\n    \n    Write-AuditLog \"Starting Master Infrastructure Audit for $CustomerName\" -Level Header\n    Write-AuditLog \"Technician: $TechnicianName\" -Level Info\n    Write-AuditLog \"Output Directory: $script:OutputDir\" -Level Info\n    Write-AuditLog \"Export Formats: $($ExportFormats -join ', ')\" -Level Info\n    \n    try {\n        # Initialize logo path for reports\n        $script:LogoPath = Initialize-LogoPath\n        Write-AuditLog \"Logo path initialized: $($script:LogoPath)\" -Level Info\n        \n        # Initialize task counting\n        $script:TotalTasks = 1 # Report Generation is always done\n        if (-not $SkipADHealthChecks) { $script:TotalTasks++ }\n        if (-not $SkipServerAudit) { $script:TotalTasks++ }\n        \n        # Active Directory Health Assessment\n        if (-not $SkipADHealthChecks) {\n            Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Starting Active Directory assessment...\"\n            $adSuccess = Test-ADInfrastructureHealth\n            $script:CompletedTasks++\n            \n            if (-not $adSuccess) {\n                Write-AuditLog \"Active Directory assessment failed or incomplete\" -Level Warning\n            }\n        } else {\n            Write-AuditLog \"Skipping Active Directory health checks as requested\" -Level Info\n        }\n        \n        # Server Infrastructure Audit - Currently disabled due to hanging issues\n        if (-not $SkipServerAudit) {\n            Write-AuditLog \"Server infrastructure audit temporarily disabled due to connectivity issues\" -Level Warning\n            Write-AuditLog \"Focus on Active Directory findings - server audit can be run separately if needed\" -Level Info\n            $script:CompletedTasks++\n        } else {\n            Write-AuditLog \"Skipping server infrastructure audit as requested\" -Level Info\n        }\n        \n        # Generate Reports\n        Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Generating comprehensive reports...\"\n        New-ComprehensiveAuditReport\n        $script:CompletedTasks++\n        \n        # Display final summary\n        $executionTime = (Get-Date) - $script:StartTime\n        \n        Write-Host \"\"\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"AUDIT COMPLETED SUCCESSFULLY\" -ForegroundColor Green\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"\"\n        \n        $summary = Get-AuditSummaryStatistics\n        \n        Write-Host \"AUDIT SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"  Customer: $CustomerName\" -ForegroundColor White\n        Write-Host \"  Overall Risk Level: \" -NoNewline -ForegroundColor White\n        \n        switch ($summary.OverallRisk) {\n            'CRITICAL' { Write-Host $summary.OverallRisk -ForegroundColor Red }\n            'HIGH' { Write-Host $summary.OverallRisk -ForegroundColor DarkRed }\n            'MEDIUM' { Write-Host $summary.OverallRisk -ForegroundColor Yellow }\n            'LOW' { Write-Host $summary.OverallRisk -ForegroundColor Green }\n        }\n        \n        Write-Host \"\"\n        Write-Host \"FINDINGS:\" -ForegroundColor Cyan\n        Write-Host \"  Critical: \" -NoNewline -ForegroundColor White\n        Write-Host $summary.CriticalFindings -ForegroundColor $(if ($summary.CriticalFindings -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High:     \" -NoNewline -ForegroundColor White\n        Write-Host $summary.HighFindings -ForegroundColor $(if ($summary.HighFindings -gt 0) { 'DarkRed' } else { 'Green' })\n        Write-Host \"  Medium:   \" -NoNewline -ForegroundColor White\n        Write-Host $summary.MediumFindings -ForegroundColor $(if ($summary.MediumFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Low:      \" -NoNewline -ForegroundColor White\n        Write-Host $summary.LowFindings -ForegroundColor $(if ($summary.LowFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Total:    \" -NoNewline -ForegroundColor White\n        Write-Host $summary.TotalFindings -ForegroundColor Cyan\n        \n        Write-Host \"\"\n        Write-Host \"INFRASTRUCTURE:\" -ForegroundColor Cyan\n        Write-Host \"  Total Servers:    $($summary.TotalServers)\" -ForegroundColor White\n        Write-Host \"  Online Servers:   $($summary.OnlineServers)\" -ForegroundColor Green\n        Write-Host \"  Offline Servers:  $($summary.OfflineServers)\" -ForegroundColor $(if ($summary.OfflineServers -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High Risk Servers: $($summary.HighRiskServers)\" -ForegroundColor $(if ($summary.HighRiskServers -gt 0) { 'Red' } else { 'Green' })\n        \n        Write-Host \"\"\n        Write-Host \"EXECUTION DETAILS:\" -ForegroundColor Cyan\n        Write-Host \"  Duration: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -ForegroundColor White\n        Write-Host \"  Reports Location: $script:OutputDir\" -ForegroundColor White\n        \n        if ($summary.CriticalFindings -gt 0 -or $summary.HighFindings -gt 0) {\n            Write-Host \"\"\n            Write-Host \"⚠️  URGENT ACTION REQUIRED ⚠️\" -ForegroundColor Red -BackgroundColor Yellow\n            Write-Host \"Critical and High priority issues require immediate attention!\" -ForegroundColor Red\n        }\n        \n        Write-AuditLog \"Master Infrastructure Audit completed successfully\" -Level Success\n        Write-AuditLog \"Total execution time: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -Level Info\n        \n        # Open output directory\n        try {\n            Start-Process $script:OutputDir\n        } catch {\n            Write-AuditLog \"Could not open output directory automatically\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"FATAL ERROR during audit execution: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Stack Trace: $($_.ScriptStackTrace)\" -Level Error\n        throw\n    } finally {\n        Write-Progress -Activity \"Master Infrastructure Audit\" -Completed\n    }\n}\n\n# ==============================================================================\n# SCRIPT EXECUTION\n# ==============================================================================\n\n# Check required modules before starting\nif (-not (Test-RequiredModules)) {\n    Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n    exit 1\n}\n\n# Parameter validation\nif (-not $CustomerName -or -not $TechnicianName) {\n    Write-Error \"CustomerName and TechnicianName parameters are required\"\n    exit 1\n}\n\n# Execute the main audit function\ntry {\n    Start-MasterInfrastructureAudit\n} catch {\n    Write-Host \"`nSCRIPT EXECUTION FAILED:\" -ForegroundColor Red\n    Write-Host $_.Exception.Message -ForegroundColor Red\n    Write-Host \"`nFor support, check the audit log in: $script:OutputDir\" -ForegroundColor Yellow\n    exit 1\n}\n\nWrite-Host \"`n✅ Master Infrastructure Audit completed successfully!\" -ForegroundColor Green\nWrite-Host \"📁 All reports and logs saved to: $script:OutputDir\" -ForegroundColor Cyan",
    "language": "powershell",
    "category": "infrastructure",
    "tags": [
      "audit",
      "backup",
      "monitoring",
      "export",
      "import",
      "system",
      "infrastructure",
      "performance",
      "security"
    ],
    "lastModified": "2025-07-14T11:40:28.366Z",
    "version": "5.1",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": [
      {
        "name": "true",
        "type": "string",
        "required": false,
        "description": "Parameter true"
      }
    ]
  },
  {
    "id": "imported-1759100564588-4s70spji3",
    "name": "Simple syntax validation",
    "description": "Simple syntax validation",
    "content": "# Simple syntax validation\n$ErrorActionPreference = 'Stop'\ntry {\n    $scriptContent = Get-Content './Master-Infrastructure-Audit-ScriptV8.1.ps1' -Raw\n    [System.Management.Automation.PSParser]::Tokenize($scriptContent, [ref]$null) | Out-Null\n    Write-Host \"✅ Syntax validation passed\" -ForegroundColor Green\n} catch {\n    Write-Host \"❌ Syntax error: $($_.Exception.Message)\" -ForegroundColor Red\n    exit 1\n}",
    "language": "powershell",
    "category": "infrastructure",
    "tags": [
      "audit",
      "system",
      "infrastructure"
    ],
    "lastModified": "2025-07-14T01:29:43.801Z",
    "version": "8.1",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  },
  {
    "id": "imported-1759100564657-3yvomgu7n",
    "name": "Complete Data Export Utility for Migration",
    "description": "Complete Data Export Utility for Migration",
    "content": "// Complete Data Export Utility for Migration\n// This script extracts all localStorage data from your DevOps Studio\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Create comprehensive data export\nfunction createDataExport() {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const exportDir = `secure-migration-backup-${timestamp.slice(0, 15)}`;\n    \n    // Data export template - user will run this in browser console\n    const browserScript = `\n// =============================================================================\n// DevOps Studio Complete Data Export Script\n// Run this in your browser console while on your local DevOps Studio\n// =============================================================================\n\n(function() {\n    console.log('🔄 Starting complete data export...');\n    \n    const exportData = {\n        timestamp: new Date().toISOString(),\n        notes: localStorage.getItem('nishen-workspace-notes'),\n        noteCategories: localStorage.getItem('nishen-workspace-note-categories'),\n        files: localStorage.getItem('nishen-workspace-files'),\n        fileBrowser: localStorage.getItem('nishen-workspace-file-browser'),\n        prodData: localStorage.getItem('nishen-workspace-prod-data'),\n        urlLinks: localStorage.getItem('nishen-workspace-url-links'),\n        urlCategories: localStorage.getItem('nishen-workspace-url-categories'),\n        prompts: localStorage.getItem('nishen-workspace-prompts'),\n        promptCategories: localStorage.getItem('nishen-workspace-prompt-categories'),\n        settings: localStorage.getItem('nishen-workspace-settings'),\n        tools: localStorage.getItem('nishen-workspace-tools'),\n        backups: localStorage.getItem('nishen-workspace-backups'),\n        allKeys: Object.keys(localStorage).filter(key => key.includes('nishen-workspace'))\n    };\n    \n    // Calculate data size\n    const dataSize = JSON.stringify(exportData).length;\n    \n    console.log('📊 Data export summary:');\n    console.log('- Notes:', exportData.notes ? 'Found' : 'Empty');\n    console.log('- Files:', exportData.files ? 'Found' : 'Empty');\n    console.log('- Settings:', exportData.settings ? 'Found' : 'Empty');\n    console.log('- All keys found:', exportData.allKeys.length);\n    console.log('- Total size:', (dataSize / 1024).toFixed(2), 'KB');\n    \n    // Create downloadable file\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = \\`devops-studio-data-export-\\${new Date().toISOString().slice(0,10)}.json\\`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n    \n    console.log('✅ Export complete! File downloaded.');\n    console.log('🔐 Keep this file safe - it contains ALL your workspace data');\n    \n    return exportData;\n})();\n`;\n\n    // Data import template for online version\n    const importScript = `\n// =============================================================================\n// DevOps Studio Data Import Script  \n// Run this in browser console on https://dev-ops-studio-jwre.vercel.app/\n// AFTER authentication is implemented\n// =============================================================================\n\n// Paste your exported data here (replace the {} with your actual export data)\nconst importData = {}; // REPLACE THIS WITH YOUR EXPORTED DATA\n\n(function() {\n    console.log('🔄 Starting data import...');\n    \n    if (!importData.timestamp) {\n        console.error('❌ No valid import data found. Please paste your exported data.');\n        return;\n    }\n    \n    // Create backup of existing data\n    const existingBackup = {};\n    Object.keys(localStorage).filter(key => key.includes('nishen-workspace')).forEach(key => {\n        existingBackup[key] = localStorage.getItem(key);\n    });\n    \n    if (Object.keys(existingBackup).length > 0) {\n        console.log('⚠️  Found existing data - creating backup first...');\n        localStorage.setItem('nishen-workspace-pre-import-backup', JSON.stringify({\n            timestamp: new Date().toISOString(),\n            data: existingBackup\n        }));\n    }\n    \n    // Import all data\n    let importCount = 0;\n    Object.keys(importData).forEach(key => {\n        if (key !== 'timestamp' && key !== 'allKeys' && importData[key]) {\n            const storageKey = key.startsWith('nishen-workspace-') ? key : 'nishen-workspace-' + key;\n            localStorage.setItem(storageKey, importData[key]);\n            importCount++;\n            console.log('✓ Imported: ' + key);\n        }\n    });\n    \n    console.log(\\`✅ Import complete! Imported \\${importCount} data sets.`);\n    console.log('🔄 Please refresh the page to see your imported data.');\n    console.log('📦 Pre-import backup saved as: nishen-workspace-pre-import-backup');\n    \n})();\n`;\n\n    return {\n        exportScript: browserScript,\n        importScript: importScript\n    };\n}\n\n// Write the scripts\nconst scripts = createDataExport();\n\n// Write export script\nconst exportPath = path.join(__dirname, 'data-export-script.js');\nfs.writeFileSync(exportPath, scripts.exportScript);\n\n// Write import script  \nconst importPath = path.join(__dirname, 'data-import-script.js');\nfs.writeFileSync(importPath, scripts.importScript);\n\nconsole.log('✅ Data migration scripts created:');\nconsole.log('📤 Export script:', exportPath);\nconsole.log('📥 Import script:', importPath);\nconsole.log('');\nconsole.log('Next steps:');\nconsole.log('1. Open your local DevOps Studio in browser');\nconsole.log('2. Open browser console (F12)');\nconsole.log('3. Copy/paste the export script content');\nconsole.log('4. Download will start automatically');\nconsole.log('5. Keep the JSON file safe for import to online version');",
    "language": "javascript",
    "category": "data-management",
    "tags": [
      "backup",
      "export",
      "import"
    ],
    "lastModified": "2025-08-17T18:57:27.347Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  },
  {
    "id": "imported-1759100564669-dd09z883d",
    "name": "=============================================================================",
    "description": "DevOps Studio Complete Data Export Script",
    "content": "// =============================================================================\n// DevOps Studio Complete Data Export Script\n// Run this in your browser console while on your local DevOps Studio\n// =============================================================================\n\n(function() {\n    console.log('🔄 Starting complete data export...');\n    \n    const exportData = {\n        timestamp: new Date().toISOString(),\n        notes: localStorage.getItem('nishen-workspace-notes'),\n        noteCategories: localStorage.getItem('nishen-workspace-note-categories'),\n        files: localStorage.getItem('nishen-workspace-files'),\n        fileBrowser: localStorage.getItem('nishen-workspace-file-browser'),\n        prodData: localStorage.getItem('nishen-workspace-prod-data'),\n        urlLinks: localStorage.getItem('nishen-workspace-url-links'),\n        urlCategories: localStorage.getItem('nishen-workspace-url-categories'),\n        prompts: localStorage.getItem('nishen-workspace-prompts'),\n        promptCategories: localStorage.getItem('nishen-workspace-prompt-categories'),\n        settings: localStorage.getItem('nishen-workspace-settings'),\n        tools: localStorage.getItem('nishen-workspace-tools'),\n        backups: localStorage.getItem('nishen-workspace-backups'),\n        allKeys: Object.keys(localStorage).filter(key => key.includes('nishen-workspace'))\n    };\n    \n    // Calculate data size\n    const dataSize = JSON.stringify(exportData).length;\n    \n    console.log('📊 Data export summary:');\n    console.log('- Notes:', exportData.notes ? 'Found' : 'Empty');\n    console.log('- Files:', exportData.files ? 'Found' : 'Empty');\n    console.log('- Settings:', exportData.settings ? 'Found' : 'Empty');\n    console.log('- All keys found:', exportData.allKeys.length);\n    console.log('- Total size:', (dataSize / 1024).toFixed(2), 'KB');\n    \n    // Create downloadable file\n    const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = 'devops-studio-data-export-' + new Date().toISOString().slice(0,10) + '.json';\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n    \n    console.log('✅ Export complete! File downloaded.');\n    console.log('🔐 Keep this file safe - it contains ALL your workspace data');\n    \n    return exportData;\n})();",
    "language": "javascript",
    "category": "data-management",
    "tags": [
      "backup",
      "export"
    ],
    "lastModified": "2025-08-17T18:57:53.816Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  },
  {
    "id": "imported-1759100564681-7ehjmirb5",
    "name": "=============================================================================",
    "description": "DevOps Studio Data Import Script",
    "content": "// =============================================================================\n// DevOps Studio Data Import Script  \n// Run this in browser console on https://dev-ops-studio-jwre.vercel.app/\n// AFTER authentication is implemented\n// =============================================================================\n\n// Paste your exported data here (replace the {} with your actual export data)\nconst importData = {}; // REPLACE THIS WITH YOUR EXPORTED DATA\n\n(function() {\n    console.log('🔄 Starting data import...');\n    \n    if (!importData.timestamp) {\n        console.error('❌ No valid import data found. Please paste your exported data.');\n        return;\n    }\n    \n    // Create backup of existing data\n    const existingBackup = {};\n    Object.keys(localStorage).filter(key => key.includes('nishen-workspace')).forEach(key => {\n        existingBackup[key] = localStorage.getItem(key);\n    });\n    \n    if (Object.keys(existingBackup).length > 0) {\n        console.log('⚠️  Found existing data - creating backup first...');\n        localStorage.setItem('nishen-workspace-pre-import-backup', JSON.stringify({\n            timestamp: new Date().toISOString(),\n            data: existingBackup\n        }));\n    }\n    \n    // Import all data\n    let importCount = 0;\n    Object.keys(importData).forEach(key => {\n        if (key !== 'timestamp' && key !== 'allKeys' && importData[key]) {\n            const storageKey = key.startsWith('nishen-workspace-') ? key : 'nishen-workspace-' + key;\n            localStorage.setItem(storageKey, importData[key]);\n            importCount++;\n            console.log('✓ Imported: ' + key);\n        }\n    });\n    \n    console.log('✅ Import complete! Imported ' + importCount + ' data sets.');\n    console.log('🔄 Please refresh the page to see your imported data.');\n    console.log('📦 Pre-import backup saved as: nishen-workspace-pre-import-backup');\n    \n})();",
    "language": "javascript",
    "category": "data-management",
    "tags": [
      "backup",
      "export",
      "import"
    ],
    "lastModified": "2025-08-17T18:58:05.504Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  },
  {
    "id": "imported-1759100564744-l7x31ftcv",
    "name": "Requires -Version 5.1",
    "description": "Requires -Version 5.1",
    "content": "#Requires -Version 5.1\n#Requires -RunAsAdministrator\n# Note: ActiveDirectory and GroupPolicy modules will be imported dynamically with error handling\n\n<#\n.SYNOPSIS\n    Master Infrastructure Audit Script - Comprehensive AD and Server Assessment\n    \n.DESCRIPTION\n    This script performs a comprehensive audit of Active Directory and server infrastructure,\n    incorporating industry best practices, security compliance standards, and proven methodologies\n    from multiple audit frameworks. It provides detailed analysis, risk scoring, and actionable\n    recommendations for infrastructure improvements.\n    \n.PARAMETER CustomerName\n    Name of the customer/organization being audited\n    \n.PARAMETER TechnicianName  \n    Name of the technician performing the audit\n    \n.PARAMETER OutputPath\n    Custom output directory path (defaults to desktop)\n    \n.PARAMETER ServerListPath\n    Path to CSV file containing server list (optional - auto-discovers from AD if not provided)\n    \n.PARAMETER SkipServerAudit\n    Skip server infrastructure auditing (AD only)\n    \n.PARAMETER SkipADHealthChecks\n    Skip Active Directory health checks\n    \n.PARAMETER MaxConcurrentJobs\n    Maximum concurrent server audit jobs (default: 10)\n    \n.PARAMETER CredentialPath\n    Path to secure credential file (optional)\n    \n.PARAMETER ExportFormats\n    Export formats: HTML, PDF, Excel, CSV, Markdown (default: HTML,Excel,CSV)\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Acme Corp\" -TechnicianName \"John Smith\"\n    \n.EXAMPLE\n    .\\Master-Infrastructure-Audit-Script.ps1 -CustomerName \"Client\" -TechnicianName \"Engineer\" -SkipServerAudit\n\n    -CustomerName \"Ashton Graham\" -TechnicianName \"Nishen Harichunder\" -ServerListPath \"C:\\FtechSupport\\N1_Audit\\server-list.csv\"\n\n    \n.NOTES\n    Author: Nishen Harichunder - RMS L4 Infrastructure Audit Team\n    Version: 1.0\n    Created: $(Get-Date -Format 'yyyy-MM-dd')\n    \n    Requirements:\n    - PowerShell 5.1 or higher\n    - Active Directory PowerShell module\n    - Domain Admin or equivalent privileges for comprehensive auditing\n    - Network connectivity to all target systems\n    \n    Security Considerations:\n    - All credentials are handled securely using PowerShell credential objects\n    - Audit activities are logged comprehensively\n    - Sensitive data is protected in transit and at rest\n    - Script follows principle of least privilege where possible\n#>\n\n[CmdletBinding()]\nparam(\n    [Parameter(Mandatory=$true, HelpMessage=\"Customer/Organization name for audit report\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$CustomerName,\n    \n    [Parameter(Mandatory=$true, HelpMessage=\"Technician name performing the audit\")]\n    [ValidateNotNullOrEmpty()]\n    [string]$TechnicianName,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$OutputPath,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$ServerListPath,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipServerAudit,\n    \n    [Parameter(Mandatory=$false)]\n    [switch]$SkipADHealthChecks,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateRange(1,20)]\n    [int]$MaxConcurrentJobs = 10,\n    \n    [Parameter(Mandatory=$false)]\n    [string]$CredentialPath,\n    \n    [Parameter(Mandatory=$false)]\n    [ValidateSet('HTML','PDF','Excel','CSV','Markdown')]\n    [string[]]$ExportFormats = @('HTML','Excel','CSV')\n)\n\n# ==============================================================================\n# SCRIPT CONFIGURATION AND INITIALIZATION\n# ==============================================================================\n\n# Global script variables\n$script:Version = '1.0'\n$script:StartTime = Get-Date\n$script:AuditFindings = @()\n$script:ServerResults = @()\n$script:ADHealthResults = @()\n$script:CompletedTasks = 0\n$script:TotalTasks = 0\n\n# Risk scoring configuration\n$script:RiskScores = @{\n    'Critical' = 10\n    'High' = 7\n    'Medium' = 4\n    'Low' = 2\n    'Info' = 1\n}\n\n# Compliance frameworks\n$script:ComplianceFrameworks = @{\n    'CIS' = 'Center for Internet Security Benchmarks'\n    'NIST' = 'NIST Cybersecurity Framework'\n    'ISO27001' = 'ISO 27001 Information Security Management'\n    'Microsoft' = 'Microsoft Security Baselines'\n}\n\n# Initialize output directory\nif (-not $OutputPath) {\n    $script:OutputDir = Join-Path $env:USERPROFILE \"Desktop\\Infrastructure-Audit-$CustomerName-$(Get-Date -Format 'yyyyMMdd-HHmmss')\"\n} else {\n    $script:OutputDir = $OutputPath\n}\n\nif (-not (Test-Path $script:OutputDir)) {\n    New-Item -ItemType Directory -Path $script:OutputDir -Force | Out-Null\n}\n\n# Initialize logo path\n$script:LogoPath = \"\"\n\n# ==============================================================================\n# LOGGING AND UTILITY FUNCTIONS\n# ==============================================================================\n\nfunction Test-RequiredModules {\n    Write-Host \"Checking required PowerShell modules...\" -ForegroundColor Yellow\n    \n    $requiredModules = @('ActiveDirectory', 'GroupPolicy')\n    $missingModules = @()\n    $availableModules = @()\n    \n    foreach ($module in $requiredModules) {\n        try {\n            if (Get-Module -ListAvailable -Name $module -ErrorAction SilentlyContinue) {\n                Write-Host \"✓ $module module is available\" -ForegroundColor Green\n                $availableModules += $module\n            } else {\n                Write-Host \"✗ $module module is NOT available\" -ForegroundColor Red\n                $missingModules += $module\n            }\n        } catch {\n            Write-Host \"✗ Error checking $module module: $($_.Exception.Message)\" -ForegroundColor Red\n            $missingModules += $module\n        }\n    }\n    \n    if ($missingModules.Count -gt 0) {\n        Write-Host \"`nMissing Required Modules:\" -ForegroundColor Red\n        foreach ($module in $missingModules) {\n            Write-Host \"  - $module\" -ForegroundColor Red\n        }\n        Write-Host \"`nTo install missing modules, run the following commands as Administrator:\" -ForegroundColor Yellow\n        if ($missingModules -contains 'ActiveDirectory') {\n            Write-Host \"  Install-WindowsFeature -Name RSAT-AD-PowerShell\" -ForegroundColor Cyan\n        }\n        if ($missingModules -contains 'GroupPolicy') {\n            Write-Host \"  Install-WindowsFeature -Name GPMC\" -ForegroundColor Cyan\n        }\n        Write-Host \"`nAlternatively, install RSAT tools from Windows Features or download from Microsoft.\" -ForegroundColor Yellow\n        return $false\n    }\n    \n    Write-Host \"All required modules are available!\" -ForegroundColor Green\n    return $true\n}\n\nfunction Write-AuditLog {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Message,\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Info', 'Warning', 'Error', 'Success', 'Header', 'Debug')]\n        [string]$Level = 'Info',\n        \n        [Parameter(Mandatory=$false)]\n        [switch]$NoConsole\n    )\n    \n    $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'\n    $logEntry = \"[$timestamp] [$Level] $Message\"\n    \n    # Console output with colors\n    if (-not $NoConsole) {\n        switch ($Level) {\n            'Info' { Write-Host $logEntry -ForegroundColor White }\n            'Warning' { Write-Host $logEntry -ForegroundColor Yellow }\n            'Error' { Write-Host $logEntry -ForegroundColor Red }\n            'Success' { Write-Host $logEntry -ForegroundColor Green }\n            'Debug' { Write-Host $logEntry -ForegroundColor Gray }\n            'Header' { \n                Write-Host \"\"\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n                Write-Host $Message -ForegroundColor Cyan\n                Write-Host \"=\" * 80 -ForegroundColor Cyan\n            }\n        }\n    }\n    \n    # File logging\n    $logFile = Join-Path $script:OutputDir 'master-audit-log.txt'\n    try {\n        Add-Content -Path $logFile -Value $logEntry -ErrorAction Stop\n    } catch {\n        # Fallback logging if main log fails\n        $logEntry | Out-File -FilePath (Join-Path $script:OutputDir 'audit-log-backup.txt') -Append -ErrorAction Stop\n    }\n}\n\nfunction Convert-ToBase64 {\n    param([string]$FilePath)\n    try {\n        if (Test-Path $FilePath) {\n            $bytes = [System.IO.File]::ReadAllBytes($FilePath)\n            return [System.Convert]::ToBase64String($bytes)\n        }\n        return \"\"\n    } catch {\n        return \"\"\n    }\n}\n\nfunction Initialize-LogoPath {\n    $logoFolder = Join-Path (Split-Path $script:MyInvocation.MyCommand.Path) \"Ftech Logos\"\n    $logoFiles = @(\n        \"first-tech-kzn-logo-black 1.png\",\n        \"FTECHKZN Horizontal Vector-03 1.png\", \n        \"FTECHKZN Horizontal Vector-04 1 (2).png\"\n    )\n    \n    foreach ($logoFile in $logoFiles) {\n        $logoPath = Join-Path $logoFolder $logoFile\n        if (Test-Path $logoPath) {\n            return $logoPath\n        }\n    }\n    \n    # Fallback - find any PNG in logo folder\n    $pngFiles = Get-ChildItem -Path $logoFolder -Filter \"*.png\" -ErrorAction SilentlyContinue\n    if ($pngFiles) {\n        return $pngFiles[0].FullName\n    }\n    \n    return \"\"\n}\n\nfunction Add-AuditFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [ValidateSet('Critical', 'High', 'Medium', 'Low', 'Info')]\n        [string]$Severity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Impact,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Recommendation,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"F$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = $Severity\n        Type = $Type\n        Description = $Description\n        Impact = $Impact\n        Recommendation = $Recommendation\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = $script:RiskScores[$Severity]\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    \n    $logLevel = switch ($Severity) {\n        'Critical' { 'Error' }\n        'High' { 'Error' }\n        'Medium' { 'Warning' }\n        default { 'Info' }\n    }\n    \n    Write-AuditLog \"[$Severity] $Category - $Title\" -Level $logLevel\n}\n\nfunction Add-PositiveFinding {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Category,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Title,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Description,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Evidence = '',\n        \n        [Parameter(Mandatory=$false)]\n        [ValidateSet('Security', 'Compliance', 'Performance', 'Availability', 'Configuration')]\n        [string]$Type = 'Security',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ComplianceFramework = '',\n        \n        [Parameter(Mandatory=$false)]\n        [string]$ReferenceStandard = ''\n    )\n    \n    $finding = [PSCustomObject]@{\n        ID = \"P$(Get-Random -Minimum 10000 -Maximum 99999)\"\n        Timestamp = Get-Date\n        Category = $Category\n        Title = $Title\n        Severity = 'Passed'\n        Type = $Type\n        Description = $Description\n        Impact = 'Positive security posture - no action required.'\n        Recommendation = 'Continue current security practices.'\n        Evidence = $Evidence\n        ComplianceFramework = $ComplianceFramework\n        ReferenceStandard = $ReferenceStandard\n        Score = 0\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n    }\n    \n    $script:AuditFindings += $finding\n    Write-AuditLog \"[PASSED] $Category - $Title\" -Level Success\n}\n\nfunction Update-AuditProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$false)]\n        [string]$Status = '',\n        \n        [Parameter(Mandatory=$false)]\n        [int]$PercentComplete = 0,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Completed = $script:CompletedTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Total = $script:TotalTasks,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$Id = 0\n    )\n    \n    if ($Total -gt 0) {\n        $PercentComplete = [math]::Round(($Completed / $Total) * 100, 1)\n    }\n    \n    # Ensure percentage never exceeds 100\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    $progressParams = @{\n        Activity = $Activity\n        Status = $Status\n        PercentComplete = $PercentComplete\n        Id = $Id\n    }\n    \n    if ($Total -gt 0) {\n        $progressParams.CurrentOperation = \"Phase $Completed of $Total - $PercentComplete% Complete\"\n    }\n    \n    Write-Progress @progressParams\n    \n    if ($Status) {\n        Write-AuditLog \"Overall Progress: $PercentComplete% - $Status\" -Level Info\n    }\n}\n\nfunction Update-SectionProgress {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$Activity,\n        \n        [Parameter(Mandatory=$true)]\n        [string]$Status,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$StepNumber,\n        \n        [Parameter(Mandatory=$true)]\n        [int]$TotalSteps,\n        \n        [Parameter(Mandatory=$false)]\n        [int]$ParentId = 0\n    )\n    \n    $PercentComplete = [math]::Round(($StepNumber / $TotalSteps) * 100, 1)\n    $PercentComplete = [math]::Min($PercentComplete, 100)\n    \n    Write-Progress -Id ($ParentId + 1) -ParentId $ParentId -Activity $Activity -Status $Status -PercentComplete $PercentComplete -CurrentOperation \"Step $StepNumber of $TotalSteps\"\n    \n    Write-AuditLog \"Section Progress: [$Activity] $PercentComplete% - $Status\" -Level Debug\n}\n\n# ==============================================================================\n# ACTIVE DIRECTORY HEALTH CHECKS\n# ==============================================================================\n\nfunction Test-RemoteService {\n    <#\n    .SYNOPSIS\n        Tests the status of a service on a remote computer using multiple methods\n    .DESCRIPTION\n        This function attempts to check service status using various methods as fallbacks:\n        1. Get-Service with ComputerName parameter\n        2. WMI Win32_Service class\n        3. PowerShell remoting with Invoke-Command\n        4. SC.exe command-line tool\n    .PARAMETER ComputerName\n        The name of the remote computer\n    .PARAMETER ServiceName\n        The name of the service to check\n    .PARAMETER DisplayName\n        The display name of the service for logging\n    .OUTPUTS\n        Returns hashtable with ServiceStatus, Method, and ErrorDetails\n    #>\n    param(\n        [Parameter(Mandatory)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory)]\n        [string]$ServiceName,\n        \n        [Parameter(Mandatory)]\n        [string]$DisplayName\n    )\n    \n    $result = @{\n        ServiceStatus = $null\n        Method = $null\n        ErrorDetails = @()\n        Success = $false\n    }\n    \n    # Method 1: Standard Get-Service with ComputerName\n    try {\n        $serviceStatus = Get-Service -ComputerName $ComputerName -Name $ServiceName -ErrorAction Stop\n        $result.ServiceStatus = $serviceStatus.Status\n        $result.Method = 'Get-Service'\n        $result.Success = $true\n        return $result\n    } catch {\n        $result.ErrorDetails += \"Get-Service failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 2: WMI Win32_Service\n    try {\n        $serviceStatus = Get-WmiObject -ComputerName $ComputerName -Class Win32_Service -Filter \"Name='$ServiceName'\" -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.State\n            $result.Method = 'WMI'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"WMI returned null for service $ServiceName\"\n        }\n    } catch {\n        $result.ErrorDetails += \"WMI query failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 3: PowerShell remoting\n    try {\n        $scriptBlock = { param($ServiceName) Get-Service -Name $ServiceName -ErrorAction Stop }\n        $serviceStatus = Invoke-Command -ComputerName $ComputerName -ScriptBlock $scriptBlock -ArgumentList $ServiceName -ErrorAction Stop\n        if ($serviceStatus) {\n            $result.ServiceStatus = $serviceStatus.Status\n            $result.Method = 'PowerShell Remoting'\n            $result.Success = $true\n            return $result\n        }\n    } catch {\n        $result.ErrorDetails += \"PowerShell remoting failed: $($_.Exception.Message)\"\n    }\n    \n    # Method 4: SC.exe as last resort\n    try {\n        $scResult = & sc.exe \\\\$ComputerName query $ServiceName 2>&1\n        if ($scResult -match \"STATE.*RUNNING\") {\n            $result.ServiceStatus = 'Running'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } elseif ($scResult -match \"STATE.*STOPPED\") {\n            $result.ServiceStatus = 'Stopped'\n            $result.Method = 'SC.exe'\n            $result.Success = $true\n            return $result\n        } else {\n            $result.ErrorDetails += \"SC.exe returned unexpected result: $($scResult -join '; ')\"\n        }\n    } catch {\n        $result.ErrorDetails += \"SC.exe failed: $($_.Exception.Message)\"\n    }\n    \n    return $result\n}\n\nfunction Test-ADInfrastructureHealth {\n    Write-AuditLog 'Starting Active Directory Infrastructure Health Assessment' -Level Header\n    \n    try {\n        # Verify AD module and domain connectivity\n        Import-Module ActiveDirectory -SkipEditionCheck -ErrorAction Stop\n        $domain = Get-ADDomain -ErrorAction Stop\n        $forest = Get-ADForest -ErrorAction Stop\n        \n        Write-AuditLog \"Connected to domain: $($domain.DNSRoot)\" -Level Success\n        Write-AuditLog \"Forest functional level: $($forest.ForestMode)\" -Level Info\n        Write-AuditLog \"Domain functional level: $($domain.DomainMode)\" -Level Info\n        \n        # Test individual AD components\n        Test-DomainControllerHealth\n        Test-DomainControllerExtendedHealth\n        Test-ADReplicationHealth  \n        Test-FSMORoleAvailability\n        Test-ADContainerStructure\n        Test-GroupPolicyCompliance\n        Test-ServiceAccountSecurity\n        Test-DNSInfrastructure\n        Test-ADSecurityConfiguration\n        Test-CertificateServices\n        \n    } catch {\n        Write-AuditLog \"FATAL: Unable to connect to Active Directory: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Connectivity' -Title 'Active Directory Connection Failed' -Severity 'Critical' `\n            -Description 'Unable to establish connection to Active Directory services.' `\n            -Impact 'Cannot perform comprehensive AD health assessment.' `\n            -Recommendation 'Verify network connectivity, DNS resolution, and AD service availability.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n        return $false\n    }\n    \n    return $true\n}\n\nfunction Test-DomainControllerHealth {\n    Write-AuditLog 'Checking Domain Controller Health...' -Level Info\n    \n    try {\n        # Get all domain controllers\n        $domainControllers = [System.DirectoryServices.ActiveDirectory.Forest]::GetCurrentForest().Domains | \n            ForEach-Object { $_.DomainControllers } | ForEach-Object { $_.Name }\n        \n        Write-AuditLog \"Found $($domainControllers.Count) domain controllers\" -Level Info\n        \n        foreach ($dc in $domainControllers) {\n            Write-AuditLog \"Testing DC: $dc\" -Level Info\n            \n            # Connectivity test\n            $pingResult = Test-Connection -ComputerName $dc -Count 2 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'Domain Controllers' -Title \"Domain Controller Unreachable: $dc\" -Severity 'Critical' `\n                    -Description \"Domain Controller $dc is not responding to ping requests.\" `\n                    -Impact 'Domain services may be unavailable, affecting authentication and directory services.' `\n                    -Recommendation 'Investigate network connectivity and DC service status immediately.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n                continue\n            }\n            \n            # Enhanced service health checks using helper function\n            $services = @(\n                @{Name='Netlogon'; DisplayName='Net Logon'; Critical=$true},\n                @{Name='NTDS'; DisplayName='Active Directory Domain Services'; Critical=$true},\n                @{Name='DNS'; DisplayName='DNS Server'; Critical=$true},\n                @{Name='W32Time'; DisplayName='Windows Time'; Critical=$false}\n            )\n            \n            foreach ($service in $services) {\n                Write-AuditLog \"Checking service $($service.DisplayName) on $dc...\" -Level Info\n                \n                # Use the helper function to check service status\n                $serviceResult = Test-RemoteService -ComputerName $dc -ServiceName $service.Name -DisplayName $service.DisplayName\n                \n                if ($serviceResult.Success) {\n                    Write-AuditLog \"Service $($service.Name) status on $dc (via $($serviceResult.Method)): $($serviceResult.ServiceStatus)\" -Level Info\n                    \n                    if ($serviceResult.ServiceStatus -ne 'Running') {\n                        $severity = if ($service.Critical) { 'Critical' } else { 'High' }\n                        Add-AuditFinding -Category 'Domain Controllers' -Title \"Service Not Running: $($service.DisplayName) on $dc\" -Severity $severity `\n                            -Description \"Essential domain service $($service.DisplayName) ($($service.Name)) is not running on $dc. Current status: $($serviceResult.ServiceStatus)\" `\n                            -Impact 'Domain functionality is compromised, affecting authentication and replication.' `\n                            -Recommendation \"Start the $($service.DisplayName) service and investigate why it stopped. Check event logs for additional details.\" `\n                            -Type 'Availability' -ComplianceFramework 'Microsoft'\n                    }\n                } else {\n                    # All methods failed - create detailed finding\n                    $severity = if ($service.Critical) { 'High' } else { 'Medium' }\n                    Add-AuditFinding -Category 'Domain Controllers' -Title \"Service Status Unknown: $($service.DisplayName) on $dc\" -Severity $severity `\n                        -Description \"Unable to determine status of $($service.DisplayName) ($($service.Name)) on $dc using any available method.\" `\n                        -Impact 'Cannot verify critical domain service availability.' `\n                        -Recommendation \"Manually verify service status on $dc. Check WinRM, WMI, and firewall settings. Ensure proper administrative access.\" `\n                        -Evidence ($serviceResult.ErrorDetails -join '; ') -Type 'Availability' -ComplianceFramework 'Microsoft'\n                }\n            }\n            \n            # DCDIAG tests with enhanced error handling\n            $dcdiagTests = @('netlogons', 'replications', 'services', 'advertising', 'fsmocheck')\n            foreach ($test in $dcdiagTests) {\n                try {\n                    Write-AuditLog \"Running DCDIAG test: $test on $dc\" -Level Info\n                    $testResult = dcdiag /test:$test /s:$dc 2>&1\n                    \n                    if ($testResult -match 'failed|error') {\n                        $severity = if ($test -in @('replications', 'netlogons')) { 'High' } else { 'Medium' }\n                        Add-AuditFinding -Category 'Domain Controllers' -Title \"DCDIAG Test Failed: $test on $dc\" -Severity $severity `\n                            -Description \"DCDIAG test $test failed on domain controller $dc.\" `\n                            -Impact 'Domain controller functionality may be impaired.' `\n                            -Recommendation \"Investigate and resolve the $test test failures using dcdiag. Run 'dcdiag /test:$test /s:$dc /v' for detailed output.\" `\n                            -Evidence ($testResult | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                    } else {\n                        Write-AuditLog \"DCDIAG test $test passed on $dc\" -Level Success\n                    }\n                } catch {\n                    Write-AuditLog \"DCDIAG test $test failed for $dc`: $($_.Exception.Message)\" -Level Warning\n                    Add-AuditFinding -Category 'Domain Controllers' -Title \"DCDIAG Test Error: $test on $dc\" -Severity 'Medium' `\n                        -Description \"Unable to run DCDIAG test $test on $dc due to error: $($_.Exception.Message)\" `\n                        -Impact 'Cannot verify domain controller functionality for this test.' `\n                        -Recommendation \"Manually run dcdiag /test:$test /s:$dc to investigate the issue.\" `\n                        -Evidence $_.Exception.Message -Type 'Configuration' -ComplianceFramework 'Microsoft'\n                }\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error during DC health check: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Error details: $($_.Exception.GetType().FullName)\" -Level Error\n        Add-AuditFinding -Category 'Domain Controllers' -Title 'DC Health Check Failed' -Severity 'High' `\n            -Description 'Unable to complete domain controller health assessment.' `\n            -Impact 'Cannot verify domain controller availability and functionality.' `\n            -Recommendation 'Manually verify domain controller status and services. Check Active Directory module availability and domain connectivity.' `\n            -Evidence \"$($_.Exception.Message) | $($_.Exception.GetType().FullName)\" -Type 'Availability'\n    }\n}\n\nfunction Test-DomainControllerExtendedHealth {\n    Write-AuditLog 'Performing Extended Domain Controller Health Checks...' -Level Info\n    \n    try {\n        $allDomains = (Get-ADForest).Domains\n        $allTestedDomainControllers = @()\n        \n        foreach ($domain in $allDomains) {\n            Write-AuditLog \"Testing domain controllers in $domain\" -Level Info\n            $domainControllers = Get-ADDomainController -Filter * -Server $domain | Sort-Object HostName\n            \n            foreach ($dc in $domainControllers) {\n                Write-AuditLog \"Testing DC: $($dc.HostName)\" -Level Info\n                $dcResults = Test-SingleDomainController -ComputerName $dc.HostName -DomainController $dc\n                $allTestedDomainControllers += $dcResults\n            }\n        }\n        \n        # Generate summary findings\n        $failedDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Critical' }\n        $warnDCs = $allTestedDomainControllers | Where-Object { $_.OverallHealth -eq 'Warning' }\n        \n        if ($failedDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Critical Domain Controller Issues Detected' -Severity 'Critical' `\n                -Description \"Found $($failedDCs.Count) domain controller(s) with critical health issues.\" `\n                -Impact 'Critical DC issues can cause authentication failures, replication problems, and service outages.' `\n                -Recommendation 'Immediately investigate and resolve critical issues on the following DCs: ' + ($failedDCs.Server -join ', ') `\n                -Evidence \"Failed DCs: $($failedDCs.Server -join ', ')\" -Type 'Availability'\n        }\n        \n        if ($warnDCs.Count -gt 0) {\n            Add-AuditFinding -Category 'Domain Controller Health' -Title 'Domain Controller Warnings Detected' -Severity 'Medium' `\n                -Description \"Found $($warnDCs.Count) domain controller(s) with warning conditions.\" `\n                -Impact 'Warning conditions may impact performance or indicate potential future issues.' `\n                -Recommendation 'Review and address warning conditions on: ' + ($warnDCs.Server -join ', ') `\n                -Evidence \"Warning DCs: $($warnDCs.Server -join ', ')\" -Type 'Performance'\n        }\n        \n        # Store results for HTML report generation\n        $script:DomainControllerHealthData = $allTestedDomainControllers\n        \n        Write-AuditLog \"Extended DC health check completed. Tested $($allTestedDomainControllers.Count) domain controllers.\" -Level Success\n        \n    } catch {\n        Add-AuditFinding -Category 'Domain Controller Health' -Title 'Extended Health Check Failed' -Severity 'High' `\n            -Description 'Failed to perform extended domain controller health checks.' `\n            -Impact 'Unable to assess complete domain controller health status.' `\n            -Recommendation 'Manually verify domain controller health using dcdiag and other diagnostic tools.' `\n            -Evidence \"$($_.Exception.Message)\" -Type 'Availability'\n    }\n}\n\nfunction Test-SingleDomainController {\n    param(\n        [Parameter(Mandatory=$true)]\n        [string]$ComputerName,\n        \n        [Parameter(Mandatory=$true)]\n        [object]$DomainController\n    )\n    \n    $dcHealth = [PSCustomObject]@{\n        Server = $ComputerName.ToLower()\n        Site = $DomainController.Site\n        OSVersion = $DomainController.OperatingSystem\n        IPv4Address = $DomainController.IPv4Address\n        FSMORoles = $DomainController.OperationMasterRoles\n        DNSTest = 'Unknown'\n        PingTest = 'Unknown'\n        UptimeHours = 'Unknown'\n        OSFreeSpacePercent = 'Unknown'\n        OSFreeSpaceGB = 'Unknown'\n        TimeOffset = 'Unknown'\n        DNSService = 'Unknown'\n        NTDSService = 'Unknown'\n        NetLogonService = 'Unknown'\n        DCDiagConnectivity = 'Unknown'\n        DCDiagReplications = 'Unknown'\n        DCDiagServices = 'Unknown'\n        DCDiagAdvertising = 'Unknown'\n        DCDiagSysVol = 'Unknown'\n        OverallHealth = 'Unknown'\n        Issues = @()\n    }\n    \n    # DNS Resolution Test\n    try {\n        $null = Resolve-DnsName $ComputerName -Type A -ErrorAction Stop\n        $dcHealth.DNSTest = 'Success'\n    } catch {\n        $dcHealth.DNSTest = 'Fail'\n        $dcHealth.Issues += 'DNS Resolution Failed'\n    }\n    \n    # Ping Test\n    if (Test-Connection $ComputerName -Count 1 -Quiet) {\n        $dcHealth.PingTest = 'Success'\n        \n        # Uptime Test\n        try {\n            $os = Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop\n            $uptime = [math]::Round(((Get-Date) - $os.LastBootUpTime).TotalHours)\n            $dcHealth.UptimeHours = $uptime\n            \n            if ($uptime -le 24) {\n                $dcHealth.Issues += 'Recent Reboot Detected'\n            }\n        } catch {\n            $dcHealth.UptimeHours = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Determine Uptime'\n        }\n        \n        # Disk Space Test\n        try {\n            $osDrive = (Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName $ComputerName -ErrorAction Stop).SystemDrive\n            $disk = Get-CimInstance -ClassName Win32_LogicalDisk -ComputerName $ComputerName -Filter \"DeviceID='$osDrive'\" -ErrorAction Stop\n            $freePercent = [math]::Round($disk.FreeSpace / $disk.Size * 100)\n            $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)\n            \n            $dcHealth.OSFreeSpacePercent = $freePercent\n            $dcHealth.OSFreeSpaceGB = $freeGB\n            \n            if ($freePercent -le 5) {\n                $dcHealth.Issues += 'Critical Disk Space'\n            } elseif ($freePercent -le 15) {\n                $dcHealth.Issues += 'Low Disk Space'\n            }\n        } catch {\n            $dcHealth.OSFreeSpacePercent = 'CIM Failure'\n            $dcHealth.OSFreeSpaceGB = 'CIM Failure'\n            $dcHealth.Issues += 'Cannot Check Disk Space'\n        }\n        \n        # Time Sync Test\n        try {\n            $timeResult = (& w32tm /stripchart /computer:$ComputerName /samples:1 /dataonly)[-1].Trim(\"s\") -split ',\\s*'\n            $timeDiff = [Math]::Round([double]$timeResult[1], 1)\n            $dcHealth.TimeOffset = $timeDiff\n            \n            if ([Math]::Abs($timeDiff) -gt 5) {\n                $dcHealth.Issues += 'Time Sync Issue'\n            }\n        } catch {\n            $dcHealth.TimeOffset = 'Fail'\n            $dcHealth.Issues += 'Time Sync Check Failed'\n        }\n        \n        # Service Tests\n        try {\n            $dnsService = Get-Service -ComputerName $ComputerName -Name DNS -ErrorAction SilentlyContinue\n            $dcHealth.DNSService = if ($dnsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.DNSService -eq 'Fail') { $dcHealth.Issues += 'DNS Service Issue' }\n            \n            $ntdsService = Get-Service -ComputerName $ComputerName -Name NTDS -ErrorAction SilentlyContinue\n            $dcHealth.NTDSService = if ($ntdsService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NTDSService -eq 'Fail') { $dcHealth.Issues += 'NTDS Service Issue' }\n            \n            $netlogonService = Get-Service -ComputerName $ComputerName -Name netlogon -ErrorAction SilentlyContinue\n            $dcHealth.NetLogonService = if ($netlogonService.Status -eq 'Running') { 'Success' } else { 'Fail' }\n            if ($dcHealth.NetLogonService -eq 'Fail') { $dcHealth.Issues += 'NetLogon Service Issue' }\n        } catch {\n            $dcHealth.DNSService = 'Fail'\n            $dcHealth.NTDSService = 'Fail'\n            $dcHealth.NetLogonService = 'Fail'\n            $dcHealth.Issues += 'Service Check Failed'\n        }\n        \n        # Basic DCDiag Tests\n        try {\n            $dcdiagResult = & dcdiag /s:$ComputerName /test:connectivity /test:replications /test:services /test:advertising /test:sysvolcheck\n            \n            $dcHealth.DCDiagConnectivity = if ($dcdiagResult -match \"Connectivity.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagReplications = if ($dcdiagResult -match \"Replications.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagServices = if ($dcdiagResult -match \"Services.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagAdvertising = if ($dcdiagResult -match \"Advertising.*passed\") { 'Passed' } else { 'Failed' }\n            $dcHealth.DCDiagSysVol = if ($dcdiagResult -match \"SysVolCheck.*passed\") { 'Passed' } else { 'Failed' }\n            \n            if ($dcHealth.DCDiagConnectivity -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Connectivity Failed' }\n            if ($dcHealth.DCDiagReplications -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Replication Failed' }\n            if ($dcHealth.DCDiagServices -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Services Failed' }\n            if ($dcHealth.DCDiagAdvertising -eq 'Failed') { $dcHealth.Issues += 'DCDIAG Advertising Failed' }\n            if ($dcHealth.DCDiagSysVol -eq 'Failed') { $dcHealth.Issues += 'DCDIAG SysVol Failed' }\n            \n        } catch {\n            $dcHealth.DCDiagConnectivity = 'Failed'\n            $dcHealth.DCDiagReplications = 'Failed'\n            $dcHealth.DCDiagServices = 'Failed'\n            $dcHealth.DCDiagAdvertising = 'Failed'\n            $dcHealth.DCDiagSysVol = 'Failed'\n            $dcHealth.Issues += 'DCDIAG Failed to Run'\n        }\n        \n    } else {\n        $dcHealth.PingTest = 'Fail'\n        $dcHealth.Issues += 'DC Not Reachable'\n        # Set all other tests to Fail since DC is unreachable\n        $dcHealth.UptimeHours = 'Fail'\n        $dcHealth.OSFreeSpacePercent = 'Fail'\n        $dcHealth.OSFreeSpaceGB = 'Fail'\n        $dcHealth.TimeOffset = 'Fail'\n        $dcHealth.DNSService = 'Fail'\n        $dcHealth.NTDSService = 'Fail'\n        $dcHealth.NetLogonService = 'Fail'\n        $dcHealth.DCDiagConnectivity = 'Failed'\n        $dcHealth.DCDiagReplications = 'Failed'\n        $dcHealth.DCDiagServices = 'Failed'\n        $dcHealth.DCDiagAdvertising = 'Failed'\n        $dcHealth.DCDiagSysVol = 'Failed'\n    }\n    \n    # Determine Overall Health\n    $criticalIssues = $dcHealth.Issues | Where-Object { $_ -match 'Critical|Failed|Not Reachable|NTDS|Service Issue' }\n    $warningIssues = $dcHealth.Issues | Where-Object { $_ -match 'Low|Recent|Time Sync|CIM Failure' }\n    \n    if ($criticalIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Critical'\n        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Critical Issues on $ComputerName\" -Severity 'Critical' `\n            -Description \"Domain controller $ComputerName has critical health issues.\" `\n            -Impact 'Critical DC issues can cause authentication failures and service disruptions.' `\n            -Recommendation \"Immediately investigate: $($criticalIssues -join ', ')\" `\n            -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Availability'\n    } elseif ($warningIssues.Count -gt 0) {\n        $dcHealth.OverallHealth = 'Warning'\n        Add-AuditFinding -Category 'Domain Controller Health' -Title \"Warning Conditions on $ComputerName\" -Severity 'Medium' `\n            -Description \"Domain controller $ComputerName has warning conditions.\" `\n            -Impact 'Warning conditions may impact performance or indicate potential issues.' `\n            -Recommendation \"Review and address: $($warningIssues -join ', ')\" `\n            -Evidence \"Issues: $($dcHealth.Issues -join ', ')\" -Type 'Performance'\n    } else {\n        $dcHealth.OverallHealth = 'Healthy'\n        Add-PositiveFinding -Category 'Domain Controller Health' -Title \"DC $ComputerName is Healthy\" `\n            -Description \"Domain controller $ComputerName passed all health checks.\" `\n            -Evidence \"All tests successful\" -Type 'Availability'\n    }\n    \n    return $dcHealth\n}\n\nfunction Test-ADReplicationHealth {\n    Write-AuditLog 'Checking Active Directory Replication Health...' -Level Info\n    \n    try {\n        # Run replication diagnostics\n        $replsum = repadmin /replsum 2>&1\n        $showrepl = repadmin /showrepl 2>&1\n        \n        # Check for replication errors\n        $replicationErrors = $showrepl | Where-Object { $_ -match 'error|fail' }\n        if ($replicationErrors.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Replication' -Title 'Active Directory Replication Errors' -Severity 'Critical' `\n                -Description 'Active Directory replication errors detected between domain controllers.' `\n                -Impact 'Data inconsistency across domain controllers, potential authentication issues.' `\n                -Recommendation 'Investigate and resolve replication errors immediately using repadmin tools.' `\n                -Evidence ($replicationErrors | Out-String) -Type 'Availability' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check replication latency\n        $latency = repadmin /latency 2>&1\n        # Parse latency results and flag high latency (implementation depends on environment)\n        \n        # Save replication reports\n        $replsum | Out-File -FilePath (Join-Path $script:OutputDir 'replication-summary.txt')\n        $showrepl | Out-File -FilePath (Join-Path $script:OutputDir 'replication-details.txt')\n        \n    } catch {\n        Write-AuditLog \"Error checking replication health: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'AD Replication' -Title 'Replication Health Check Failed' -Severity 'Medium' `\n            -Description 'Unable to complete replication health assessment.' `\n            -Impact 'Cannot verify replication status between domain controllers.' `\n            -Recommendation 'Manually check replication using repadmin commands.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Test-FSMORoleAvailability {\n    Write-AuditLog 'Checking FSMO Role Holder Availability...' -Level Info\n    \n    try {\n        $forest = Get-ADForest\n        $domain = Get-ADDomain\n        \n        $fsmoRoles = @{\n            'Schema Master' = $forest.SchemaMaster\n            'Domain Naming Master' = $forest.DomainNamingMaster\n            'Infrastructure Master' = $domain.InfrastructureMaster\n            'RID Master' = $domain.RIDMaster\n            'PDC Emulator' = $domain.PDCEmulator\n        }\n        \n        foreach ($role in $fsmoRoles.GetEnumerator()) {\n            $roleHolder = $role.Value\n            Write-AuditLog \"Checking $($role.Key) on $roleHolder\" -Level Info\n            \n            $pingResult = Test-Connection -ComputerName $roleHolder -Count 1 -Quiet -ErrorAction Stop\n            if (-not $pingResult) {\n                Add-AuditFinding -Category 'FSMO Roles' -Title \"FSMO Role Holder Unavailable: $($role.Key)\" -Severity 'Critical' `\n                    -Description \"FSMO role holder $roleHolder for $($role.Key) is not responding.\" `\n                    -Impact 'Critical AD operations may fail, affecting domain functionality.' `\n                    -Recommendation 'Investigate role holder availability and consider FSMO role transfer if necessary.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error checking FSMO roles: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'FSMO Roles' -Title 'FSMO Role Check Failed' -Severity 'Medium' `\n            -Description 'Unable to verify FSMO role holder availability.' `\n            -Impact 'Cannot confirm critical AD role functionality.' `\n            -Recommendation 'Manually verify FSMO role holders using netdom or AD tools.' `\n            -Evidence $_.Exception.Message -Type 'Configuration'\n    }\n}\n\nfunction Test-ADContainerStructure {\n    Write-AuditLog 'Analyzing AD Container Structure and Best Practices...' -Level Info\n    \n    try {\n        $domainDN = (Get-ADDomain).DistinguishedName\n        \n        # Check for computer objects in default Computers container\n        $computersInDefault = Get-ADObject -SearchBase \"CN=Computers,$domainDN\" -Filter * -ErrorAction Stop\n        if ($computersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'Computer Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($computersInDefault.Count) computer objects found in default Computers container.\" `\n                -Impact 'Objects in default containers cannot have Group Policy applied effectively.' `\n                -Recommendation 'Move computer objects to appropriate organizational units for proper management.' `\n                -Evidence ($computersInDefault | Select-Object Name | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check for user objects in default Users container\n        $systemObjects = @('DnsAdmins', 'DnsUpdateProxy', 'Administrator', 'Guest', 'krbtgt')\n        $usersInDefault = Get-ADObject -SearchBase \"CN=Users,$domainDN\" -Filter { ObjectClass -eq 'user' } -Properties isCriticalSystemObject, samAccountName -ErrorAction Stop |\n            Where-Object { \n                $_.SamAccountName -notin $systemObjects -and \n                $_.isCriticalSystemObject -ne $true -and\n                -not ($_.SamAccountName -like 'AAD_*') -and\n                -not ($_.SamAccountName -like 'MOL_*') -and\n                -not ($_.SamAccountName -like 'MSOL_*')\n            }\n        \n        if ($usersInDefault.Count -gt 0) {\n            Add-AuditFinding -Category 'AD Structure' -Title 'User Objects in Default Container' -Severity 'Medium' `\n                -Description \"$($usersInDefault.Count) user objects found in default Users container.\" `\n                -Impact 'Users in default container cannot have proper Group Policy targeting.' `\n                -Recommendation 'Move user objects to appropriate organizational units based on department and function.' `\n                -Evidence ($usersInDefault | Select-Object Name, SamAccountName | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD container structure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-GroupPolicyCompliance {\n    Write-AuditLog 'Analyzing Group Policy Configuration and Compliance...' -Level Info\n    \n    try {\n        Import-Module GroupPolicy -SkipEditionCheck -ErrorAction Stop\n        \n        if (-not (Get-Module GroupPolicy)) {\n            Write-AuditLog \"Group Policy module not available, skipping GP analysis\" -Level Warning\n            return\n        }\n        \n        $allGPOs = Get-GPO -All -ErrorAction Stop\n        $unlinkedGPOs = @()\n        \n        foreach ($gpo in $allGPOs) {\n            try {\n                $gpoReport = Get-GPOReport -Guid $gpo.Id -ReportType XML -ErrorAction Stop\n                if ($gpoReport -and $gpoReport -notmatch '<LinksTo>') {\n                    $unlinkedGPOs += $gpo\n                }\n            } catch {\n                Write-AuditLog \"Could not check linking for GPO: $($gpo.DisplayName)\" -Level Warning\n            }\n        }\n        \n        if ($unlinkedGPOs.Count -gt 0) {\n            Add-AuditFinding -Category 'Group Policy' -Title 'Unlinked Group Policy Objects' -Severity 'Low' `\n                -Description \"$($unlinkedGPOs.Count) GPOs are not linked to any organizational units.\" `\n                -Impact 'Unlinked GPOs create administrative overhead and may indicate poor policy management.' `\n                -Recommendation 'Review each unlinked GPO and either link to appropriate OUs or backup and delete if no longer needed.' `\n                -Evidence ($unlinkedGPOs | Select-Object DisplayName, CreationTime | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Export GPO inventory\n        $allGPOs | Select-Object DisplayName, Id, CreationTime, ModificationTime, @{Name=\"Linked\";Expression={\n            try { \n                $report = Get-GPOReport -Guid $_.Id -ReportType XML -ErrorAction Stop\n                if ($report -match '<LinksTo>') { 'Yes' } else { 'No' }\n            } catch { 'Unknown' }\n        }} | Export-Csv -Path (Join-Path $script:OutputDir 'group-policy-inventory.csv') -NoTypeInformation\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Group Policy: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ServiceAccountSecurity {\n    Write-AuditLog 'Analyzing Service Account Security...' -Level Info\n    \n    try {\n        # Check for service accounts with old passwords\n        $oldPasswordThreshold = (Get-Date).AddDays(-180)\n        $serviceAccountsOldPasswords = Get-ADUser -Filter {\n            passwordLastSet -lt $oldPasswordThreshold -and \n            Enabled -eq $true\n        } -Properties PasswordLastSet, ServicePrincipalName -ErrorAction Stop |\n            Where-Object { $_.ServicePrincipalName -or $_.SamAccountName -like '*svc*' -or $_.SamAccountName -like '*service*' }\n        \n        if ($serviceAccountsOldPasswords.Count -gt 0) {\n            Add-AuditFinding -Category 'Service Accounts' -Title 'Service Accounts with Old Passwords' -Severity 'High' `\n                -Description \"$($serviceAccountsOldPasswords.Count) service accounts have passwords older than 180 days.\" `\n                -Impact 'Old service account passwords increase risk of credential compromise.' `\n                -Recommendation 'Schedule coordinated password changes with application owners.' `\n                -Evidence ($serviceAccountsOldPasswords | Select-Object SamAccountName, PasswordLastSet | Out-String) -Type 'Security' -ComplianceFramework 'NIST'\n        }\n        \n        # Check KRBTGT account password age\n        $krbtgtAccount = Get-ADUser -Identity 'krbtgt' -Properties PasswordLastSet -ErrorAction Stop\n        if ($krbtgtAccount) {\n            $passwordAge = (Get-Date) - $krbtgtAccount.PasswordLastSet\n            if ($passwordAge.Days -gt 180) {\n                Add-AuditFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Too Old' -Severity 'High' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old.\" `\n                    -Impact 'Old KRBTGT passwords can be exploited for Golden Ticket attacks.' `\n                    -Recommendation 'Reset KRBTGT password twice with 10-hour intervals between resets.' `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            } else {\n                Add-PositiveFinding -Category 'Kerberos Security' -Title 'KRBTGT Password Age Compliant' `\n                    -Description \"KRBTGT account password is $($passwordAge.Days) days old, within the recommended 180-day limit.\" `\n                    -Evidence \"Password last set: $($krbtgtAccount.PasswordLastSet)\" -Type 'Security' -ComplianceFramework 'Microsoft'\n            }\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing service account security: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-DNSInfrastructure {\n    Write-AuditLog 'Analyzing DNS Infrastructure Health...' -Level Info\n    \n    try {\n        # Get PDC Emulator to run DNS diagnostics\n        try {\n            $pdcEmulator = (Get-ADDomain).PDCEmulator\n            Write-AuditLog \"Running DNS diagnostics against PDC Emulator: $pdcEmulator\" -Level Info\n            $dnsResults = dcdiag /test:dns /s:$pdcEmulator 2>&1\n        } catch {\n            Write-AuditLog \"Could not identify PDC Emulator, trying any available DC\" -Level Warning\n            try {\n                $anyDC = (Get-ADDomainController -Discover).Name\n                Write-AuditLog \"Running DNS diagnostics against DC: $anyDC\" -Level Info\n                $dnsResults = dcdiag /test:dns /s:$anyDC 2>&1\n            } catch {\n                Write-AuditLog \"Could not find any available DC, running locally\" -Level Warning\n                $dnsResults = dcdiag /test:dns 2>&1\n            }\n        }\n        \n        # Check for DNS errors\n        if ($dnsResults -match 'failed|error') {\n            Add-AuditFinding -Category 'DNS Infrastructure' -Title 'DNS Health Issues Detected' -Severity 'Medium' `\n                -Description 'DNS diagnostic tests detected configuration or operational issues.' `\n                -Impact 'DNS issues can cause authentication failures and service disruptions.' `\n                -Recommendation 'Review DNS configuration and resolve identified issues.' `\n                -Evidence ($dnsResults | Out-String) -Type 'Configuration' -ComplianceFramework 'Microsoft'\n        }\n        \n        # Check DNS zones for secure updates (if DNS server role is available)\n        try {\n            $dnsZones = Get-DnsServerZone -ErrorAction Stop\n            $insecureZones = $dnsZones | Where-Object { $_.DynamicUpdate -eq 'NonSecureAndSecure' }\n            \n            if ($insecureZones.Count -gt 0) {\n                Add-AuditFinding -Category 'DNS Security' -Title 'DNS Zones Allow Insecure Updates' -Severity 'High' `\n                    -Description \"$($insecureZones.Count) DNS zones allow non-secure dynamic updates.\" `\n                    -Impact 'Insecure DNS updates can lead to DNS poisoning attacks.' `\n                    -Recommendation 'Configure all DNS zones to use secure dynamic updates only.' `\n                    -Evidence ($insecureZones | Select-Object ZoneName, DynamicUpdate | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Could not check DNS zones (may not be DNS server)\" -Level Warning\n        }\n        \n        # Save DNS diagnostic results\n        $dnsResults | Out-File -FilePath (Join-Path $script:OutputDir 'dns-diagnostic.txt')\n        \n    } catch {\n        Write-AuditLog \"Error analyzing DNS infrastructure: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-ADSecurityConfiguration {\n    Write-AuditLog 'Analyzing Active Directory Security Configuration...' -Level Info\n    \n    try {\n        # Check domain password policy - Complete configuration\n        $passwordPolicy = Get-ADDefaultDomainPasswordPolicy -ErrorAction Stop\n        if ($passwordPolicy) {\n            Write-AuditLog 'Analyzing complete password policy configuration...' -Level Info\n            \n            # Create comprehensive password policy evidence\n            $passwordPolicyEvidence = @\"\nDomain Password Policy Configuration:\n- Minimum Password Length: $($passwordPolicy.MinPasswordLength) characters\n- Password Complexity Enabled: $($passwordPolicy.ComplexityEnabled)\n- Maximum Password Age: $($passwordPolicy.MaxPasswordAge.Days) days\n- Minimum Password Age: $($passwordPolicy.MinPasswordAge.Days) days\n- Password History Count: $($passwordPolicy.PasswordHistoryCount)\n- Lockout Duration: $($passwordPolicy.LockoutDuration.TotalMinutes) minutes\n- Lockout Observation Window: $($passwordPolicy.LockoutObservationWindow.TotalMinutes) minutes\n- Lockout Threshold: $($passwordPolicy.LockoutThreshold) attempts\n- Reversible Encryption: $($passwordPolicy.ReversibleEncryptionEnabled)\n\"@\n            \n            # Add comprehensive password policy finding\n            Add-AuditFinding -Category 'Password Policy' -Title 'Complete Password Policy Configuration' -Severity 'Info' `\n                -Description 'Complete domain password policy configuration documented.' `\n                -Impact 'Password policy settings directly impact security posture.' `\n                -Recommendation 'Review password policy settings against security best practices.' `\n                -Evidence $passwordPolicyEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            \n            # Check minimum password length\n            if ($passwordPolicy.MinPasswordLength -lt 12) {\n                $severity = if ($passwordPolicy.MinPasswordLength -lt 8) { 'High' } else { 'Medium' }\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Minimum Password Length' -Severity $severity `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Weak password requirements increase risk of password-based attacks and credential compromise.' `\n                    -Recommendation 'Set minimum password length to at least 12 characters (current industry standard). Recommended: 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MinPasswordLength -lt 14) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Length Below Recommended Standard' -Severity 'Low' `\n                    -Description \"Minimum password length is set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Impact 'Password length meets minimum requirements but falls short of recommended best practices.' `\n                    -Recommendation 'Consider increasing minimum password length to 14+ characters for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Strong Minimum Password Length' `\n                    -Description \"Minimum password length is appropriately set to $($passwordPolicy.MinPasswordLength) characters.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordLength) characters (meets recommended standard of 14+)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check password complexity\n            if ($passwordPolicy.ComplexityEnabled -eq $false) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Complexity Not Enforced' -Severity 'High' `\n                    -Description 'Password complexity requirements are not enforced.' `\n                    -Impact 'Simple passwords increase risk of brute force and dictionary attacks.' `\n                    -Recommendation 'Enable password complexity requirements. NB: Exception applies if password policies are propagated via Azure AD - Azure AD and on-premises AD complexity requirements may conflict with password writeback enabled, especially with name-based character restrictions.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Password Complexity Properly Enforced' `\n                    -Description 'Password complexity requirements are enabled and enforced.' `\n                    -Evidence \"Complexity enabled: $($passwordPolicy.ComplexityEnabled)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check maximum password age\n            if ($passwordPolicy.MaxPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Never Expires Policy' -Severity 'High' `\n                    -Description \"Maximum password age is set to 0 days (passwords never expire).\" `\n                    -Impact 'Passwords that never expire pose significant security risk as compromised credentials remain valid indefinitely.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -lt 30) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Too Short' -Severity 'Medium' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Very short password aging may lead to user frustration and weaker password choices.' `\n                    -Recommendation 'Set maximum password age between 30-150 days for optimal security balance.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.MaxPasswordAge.Days -gt 150) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Password Age Policy Requires Review' -Severity 'Low' `\n                    -Description \"Maximum password age is set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Impact 'Extended password aging may increase risk of compromised credentials remaining valid longer.' `\n                    -Recommendation 'Review and consider reducing maximum password age to 150 days or less for enhanced security.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Password Age Policy' `\n                    -Description \"Maximum password age is appropriately set to $($passwordPolicy.MaxPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MaxPasswordAge.Days) days (within recommended 30-150 day range)\" `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check minimum password age\n            if ($passwordPolicy.MinPasswordAge.Days -eq 0) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Minimum Password Age Not Set' -Severity 'High' `\n                    -Description \"Minimum password age is set to 0 days (users can change passwords immediately).\" `\n                    -Impact 'Users can bypass password history restrictions by changing passwords multiple times in succession.' `\n                    -Recommendation 'Set minimum password age to 1 day or more to prevent password history bypass.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            } else {\n                Add-PositiveFinding -Category 'Password Policy' -Title 'Appropriate Minimum Password Age Policy' `\n                    -Description \"Minimum password age is appropriately set to $($passwordPolicy.MinPasswordAge.Days) days.\" `\n                    -Evidence \"Current setting: $($passwordPolicy.MinPasswordAge.Days) days (prevents password history bypass)\" `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check password history\n            if ($passwordPolicy.PasswordHistoryCount -lt 12) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Insufficient Password History' -Severity 'Medium' `\n                    -Description \"Password history is set to remember only $($passwordPolicy.PasswordHistoryCount) passwords.\" `\n                    -Impact 'Insufficient password history allows users to reuse recent passwords.' `\n                    -Recommendation 'Set password history to remember at least 12 previous passwords.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check account lockout policy\n            if ($passwordPolicy.LockoutThreshold -eq 0) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Policy Not Configured' -Severity 'High' `\n                    -Description 'Account lockout policy is not configured (lockout threshold is 0).' `\n                    -Impact 'No protection against brute force password attacks.' `\n                    -Recommendation 'Configure account lockout policy with threshold of 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            } elseif ($passwordPolicy.LockoutThreshold -gt 10) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Threshold Too High' -Severity 'Medium' `\n                    -Description \"Account lockout threshold is set to $($passwordPolicy.LockoutThreshold) attempts.\" `\n                    -Impact 'High lockout threshold provides insufficient protection against brute force attacks.' `\n                    -Recommendation 'Set account lockout threshold to 5-10 failed attempts.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check lockout duration\n            if ($passwordPolicy.LockoutDuration.TotalMinutes -lt 15) {\n                Add-AuditFinding -Category 'Account Lockout Policy' -Title 'Account Lockout Duration Too Short' -Severity 'Medium' `\n                    -Description \"Account lockout duration is set to $($passwordPolicy.LockoutDuration.TotalMinutes) minutes.\" `\n                    -Impact 'Short lockout duration may not effectively deter brute force attacks.' `\n                    -Recommendation 'Set account lockout duration to at least 15 minutes.' `\n                    -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check reversible encryption\n            if ($passwordPolicy.ReversibleEncryptionEnabled -eq $true) {\n                Add-AuditFinding -Category 'Password Policy' -Title 'Reversible Encryption Enabled' -Severity 'Critical' `\n                    -Description 'Reversible encryption for passwords is enabled.' `\n                    -Impact 'Passwords stored with reversible encryption are equivalent to plaintext.' `\n                    -Recommendation 'Disable reversible encryption immediately unless required for specific legacy applications.' `\n                    -Type 'Security' -ComplianceFramework 'NIST'\n            }\n        }\n        \n        # Check for accounts with PasswordNotRequired or PasswordNeverExpires\n        Write-AuditLog 'Checking for accounts with problematic password settings...' -Level Info\n        \n        try {\n            # Check for accounts with PasswordNotRequired\n            $passwordNotRequiredAccounts = Get-ADUser -Filter {PasswordNotRequired -eq $true -and Enabled -eq $true} -Properties PasswordNotRequired, LastLogonDate, Created\n            if ($passwordNotRequiredAccounts.Count -gt 0) {\n                $passwordNotRequiredEvidence = $passwordNotRequiredAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Password Not Required' -Severity 'High' `\n                    -Description \"Found $($passwordNotRequiredAccounts.Count) enabled accounts with 'Password Not Required' setting.\" `\n                    -Impact 'Accounts without password requirements pose significant security risk.' `\n                    -Recommendation 'Review and disable Password Not Required setting for all accounts unless absolutely necessary.' `\n                    -Evidence $passwordNotRequiredEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n            # Check for accounts with PasswordNeverExpires (excluding service accounts)\n            $passwordNeverExpiresAccounts = Get-ADUser -Filter {PasswordNeverExpires -eq $true -and Enabled -eq $true} -Properties PasswordNeverExpires, LastLogonDate, Created, ServicePrincipalName\n            # Filter out service accounts (those with SPNs or service account naming patterns)\n            $nonServiceAccounts = $passwordNeverExpiresAccounts | Where-Object { \n                -not $_.ServicePrincipalName -and \n                $_.SamAccountName -notmatch '^(svc|service|sql|iis|app)' -and\n                $_.SamAccountName -notmatch '^\\$' \n            }\n            \n            if ($nonServiceAccounts.Count -gt 0) {\n                $passwordNeverExpiresEvidence = $nonServiceAccounts | Select-Object Name, SamAccountName, LastLogonDate, Created | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Non-Service Accounts with Password Never Expires' -Severity 'High' `\n                    -Description \"Found $($nonServiceAccounts.Count) enabled non-service accounts with 'Password Never Expires' setting.\" `\n                    -Impact 'Accounts with non-expiring passwords increase security risk if compromised.' `\n                    -Recommendation 'Review and disable Password Never Expires for non-service accounts.' `\n                    -Evidence $passwordNeverExpiresEvidence -Type 'Security' -ComplianceFramework 'NIST'\n            }\n            \n            # Check for accounts with expired passwords\n            $expiredPasswordAccounts = Get-ADUser -Filter {Enabled -eq $true -and PasswordExpired -eq $true} -Properties PasswordExpired, LastLogonDate, PasswordLastSet\n            if ($expiredPasswordAccounts.Count -gt 0) {\n                $expiredPasswordEvidence = $expiredPasswordAccounts | Select-Object Name, SamAccountName, LastLogonDate, PasswordLastSet | Out-String\n                Add-AuditFinding -Category 'Account Security' -Title 'Accounts with Expired Passwords' -Severity 'Medium' `\n                    -Description \"Found $($expiredPasswordAccounts.Count) enabled accounts with expired passwords.\" `\n                    -Impact 'Accounts with expired passwords may indicate inactive accounts or password policy issues.' `\n                    -Recommendation 'Review expired password accounts and either reset passwords or disable unused accounts.' `\n                    -Evidence $expiredPasswordEvidence -Type 'Security' -ComplianceFramework 'CIS'\n            }\n            \n        } catch {\n            Write-AuditLog \"Error checking account password settings: $($_.Exception.Message)\" -Level Warning\n        }\n        \n        # Check for privileged account analysis - Extended sensitive groups\n        $privilegedGroups = @('Domain Admins', 'Enterprise Admins', 'Schema Admins', 'Administrators')\n        $sensitiveGroups = @('Backup Operators', 'Server Operators', 'Print Operators', 'Account Operators', 'Replicator', 'Network Configuration Operators', 'Hyper-V Administrators', 'Remote Desktop Users')\n        \n        Write-AuditLog 'Analyzing privileged and sensitive group memberships...' -Level Info\n        \n        # Check core privileged groups\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop\n                if ($members.Count -gt 5) {\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Excessive Privileged Group Membership: $group\" -Severity 'Medium' `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact 'Large privileged groups increase attack surface and compliance risk.' `\n                        -Recommendation 'Review privileged group membership and remove unnecessary accounts.' `\n                        -Evidence ($members | Select-Object Name, ObjectClass | Out-String) -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group\" -Level Warning\n            }\n        }\n        \n        # Check for inactive privileged accounts\n        $inactiveThreshold = (Get-Date).AddDays(-90)\n        foreach ($group in $privilegedGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction Stop | Where-Object { $_.objectClass -eq 'user' }\n                foreach ($member in $members) {\n                    $user = Get-ADUser -Identity $member.SamAccountName -Properties LastLogonDate -ErrorAction Stop\n                    if ($user.LastLogonDate -and $user.LastLogonDate -lt $inactiveThreshold) {\n                        Add-AuditFinding -Category 'Privileged Access' -Title \"Inactive Privileged Account: $($user.SamAccountName)\" -Severity 'High' `\n                            -Description \"Privileged account $($user.SamAccountName) has not logged in for over 90 days.\" `\n                            -Impact 'Inactive privileged accounts create security risk and compliance violations.' `\n                            -Recommendation 'Disable or remove inactive privileged accounts after proper verification.' `\n                            -Evidence \"Last logon: $($user.LastLogonDate)\" -Type 'Security' -ComplianceFramework 'ISO27001'\n                    }\n                }\n            } catch {\n                Write-AuditLog \"Could not check inactive accounts for $group\" -Level Warning\n            }\n        }\n        \n        # Check sensitive groups for unexpected membership\n        foreach ($group in $sensitiveGroups) {\n            try {\n                $members = Get-ADGroupMember -Identity $group -ErrorAction SilentlyContinue\n                if ($members -and $members.Count -gt 0) {\n                    $memberEvidence = $members | Select-Object Name, ObjectClass | Out-String\n                    $severity = switch ($group) {\n                        'Backup Operators' { 'High' }\n                        'Server Operators' { 'High' }\n                        'Account Operators' { 'High' }\n                        default { 'Medium' }\n                    }\n                    Add-AuditFinding -Category 'Privileged Access' -Title \"Sensitive Group Has Members: $group\" -Severity $severity `\n                        -Description \"$group has $($members.Count) members.\" `\n                        -Impact \"Members of $group have elevated privileges that could be misused.\" `\n                        -Recommendation \"Review membership of $group and remove unnecessary accounts.\" `\n                        -Evidence $memberEvidence -Type 'Security' -ComplianceFramework 'CIS'\n                }\n            } catch {\n                Write-AuditLog \"Could not check group membership for $group (may not exist)\" -Level Info\n            }\n        }\n        \n        # Check for disabled user accounts that should be cleaned up\n        Write-AuditLog 'Checking for disabled user accounts...' -Level Info\n        try {\n            $disabledUsers = Get-ADUser -Filter {Enabled -eq $false} -Properties LastLogonDate, WhenChanged\n            $oldDisabledUsers = $disabledUsers | Where-Object { $_.WhenChanged -lt (Get-Date).AddDays(-90) }\n            \n            if ($oldDisabledUsers.Count -gt 0) {\n                $disabledUsersEvidence = $oldDisabledUsers | Select-Object Name, SamAccountName, LastLogonDate, WhenChanged | Sort-Object WhenChanged | Out-String\n                Add-AuditFinding -Category 'Account Hygiene' -Title 'Old Disabled User Accounts' -Severity 'Medium' `\n                    -Description \"Found $($oldDisabledUsers.Count) user accounts that have been disabled for more than 90 days.\" `\n                    -Impact 'Old disabled accounts consume resources and may indicate incomplete cleanup processes.' `\n                    -Recommendation 'Review old disabled accounts and remove them if no longer needed for auditing purposes.' `\n                    -Evidence $disabledUsersEvidence -Type 'Compliance' -ComplianceFramework 'CIS'\n            }\n        } catch {\n            Write-AuditLog \"Error checking disabled user accounts: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing AD security configuration: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Test-CertificateServices {\n    Write-AuditLog 'Analyzing Certificate Services Infrastructure...' -Level Info\n    \n    try {\n        # Check Certificate Authority service - improved detection\n        $caService = Get-Service -Name 'CertSvc' -ErrorAction SilentlyContinue\n        if ($caService) {\n            if ($caService.Status -ne 'Running') {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificate Authority Service Not Running' -Severity 'High' `\n                    -Description 'Certificate Authority service is not running.' `\n                    -Impact 'PKI services unavailable, affecting certificate enrollment and validation.' `\n                    -Recommendation 'Start Certificate Authority service and investigate startup issues.' `\n                    -Type 'Availability' -ComplianceFramework 'Microsoft'\n            }\n        } else {\n            Write-AuditLog 'Certificate Services not installed on this system' -Level Info\n        }\n        \n        # Check for expiring certificates in local machine store (regardless of CA installation)\n        try {\n            $expiringCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date).AddDays(30) -and $_.NotAfter -gt (Get-Date) }\n            \n            if ($expiringCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Certificates Expiring Soon' -Severity 'Medium' `\n                    -Description \"$($expiringCerts.Count) certificates will expire within 30 days.\" `\n                    -Impact 'Certificate expiration can cause service disruptions and authentication failures.' `\n                    -Recommendation 'Review expiring certificates and plan for renewal.' `\n                    -Evidence ($expiringCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n            \n            # Check for already expired certificates\n            $expiredCerts = Get-ChildItem Cert:\\LocalMachine\\My -ErrorAction Stop | \n                Where-Object { $_.NotAfter -lt (Get-Date) }\n            \n            if ($expiredCerts.Count -gt 0) {\n                Add-AuditFinding -Category 'Certificate Services' -Title 'Expired Certificates Found' -Severity 'Medium' `\n                    -Description \"$($expiredCerts.Count) expired certificates found in local machine store.\" `\n                    -Impact 'Expired certificates should be removed to maintain clean certificate store.' `\n                    -Recommendation 'Remove expired certificates that are no longer needed.' `\n                    -Evidence ($expiredCerts | Select-Object Subject, NotAfter | Out-String) -Type 'Configuration'\n            }\n        } catch {\n            Write-AuditLog \"Could not check certificate store: $($_.Exception.Message)\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"Error analyzing Certificate Services: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\n# ==============================================================================\n# SERVER INFRASTRUCTURE AUDIT\n# ==============================================================================\n\nfunction Start-ServerInfrastructureAudit {\n    Write-AuditLog 'Starting Server Infrastructure Audit' -Level Header\n    \n    try {\n        # Discover server list\n        $serverList = Get-ServerInventory\n        \n        if ($serverList.Count -eq 0) {\n            Write-AuditLog \"No servers found for auditing\" -Level Warning\n            return\n        }\n        \n        Write-AuditLog \"Found $($serverList.Count) servers to audit\" -Level Success\n        \n        # Get credentials for server access\n        $credential = Get-AuditCredentials\n        if (-not $credential) {\n            Write-AuditLog \"No credentials provided for server audit\" -Level Warning\n            return\n        }\n        \n        # Audit servers in parallel\n        Start-ParallelServerAudit -ServerList $serverList -Credential $credential\n        \n    } catch {\n        Write-AuditLog \"Error during server infrastructure audit: $($_.Exception.Message)\" -Level Error\n        Add-AuditFinding -Category 'Server Audit' -Title 'Server Infrastructure Audit Failed' -Severity 'High' `\n            -Description 'Unable to complete server infrastructure assessment.' `\n            -Impact 'Cannot verify server security and configuration compliance.' `\n            -Recommendation 'Investigate server audit failures and retry with proper credentials.' `\n            -Evidence $_.Exception.Message -Type 'Availability'\n    }\n}\n\nfunction Get-ServerInventory {\n    Write-AuditLog 'Discovering server inventory...' -Level Info\n    \n    try {\n        if ($ServerListPath -and (Test-Path $ServerListPath)) {\n            # Load from CSV file\n            Write-AuditLog \"Loading server list from: $ServerListPath\" -Level Info\n            $serverList = Import-Csv -Path $ServerListPath\n            return $serverList | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.ServerName\n                    Description = if ($_.Description) { $_.Description } else { 'Imported from CSV' }\n                    Environment = if ($_.Environment) { $_.Environment } else { 'Unknown' }\n                }\n            }\n        } else {\n            # Auto-discover from Active Directory\n            Write-AuditLog \"Auto-discovering servers from Active Directory\" -Level Info\n            $adServers = Get-ADComputer -Filter {OperatingSystem -like \"*Server*\" -and Enabled -eq $true} -Properties Name, OperatingSystem, Description\n            \n            return $adServers | ForEach-Object {\n                [PSCustomObject]@{\n                    ServerName = $_.Name\n                    Description = if ($_.Description) { $_.Description } else { $_.OperatingSystem }\n                    Environment = 'Production' # Default assumption\n                }\n            }\n        }\n    } catch {\n        Write-AuditLog \"Error discovering server inventory: $($_.Exception.Message)\" -Level Error\n        return @()\n    }\n}\n\nfunction Get-AuditCredentials {\n    if ($CredentialPath -and (Test-Path $CredentialPath)) {\n        try {\n            Write-AuditLog \"Loading credentials from: $CredentialPath\" -Level Info\n            return Import-Clixml -Path $CredentialPath\n        } catch {\n            Write-AuditLog \"Failed to load credentials from file, prompting user\" -Level Warning\n        }\n    }\n    \n    Write-Host \"`nPlease provide credentials for server access:\" -ForegroundColor Yellow\n    return Get-Credential -Message \"Enter credentials for server auditing (Domain Admin or equivalent)\"\n}\n\nfunction Start-ParallelServerAudit {\n    param(\n        [Parameter(Mandatory=$true)]\n        [array]$ServerList,\n        \n        [Parameter(Mandatory=$true)]\n        [PSCredential]$Credential\n    )\n    \n    Write-AuditLog \"Starting parallel audit of $($ServerList.Count) servers with max $MaxConcurrentJobs concurrent jobs\" -Level Info\n    Write-AuditLog \"Using credentials for user: $($Credential.UserName)\" -Level Info\n    Write-AuditLog \"Server list: $($ServerList | ForEach-Object { $_.ServerName } | Join-String -Separator ', ')\" -Level Info\n    \n    $jobs = @()\n    $completedServers = 0\n    \n    # Start initial batch of jobs\n    foreach ($server in $ServerList) {\n        if ($jobs.Count -lt $MaxConcurrentJobs) {\n            Write-AuditLog \"Starting audit job for server: $($server.ServerName)\" -Level Info\n            $job = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $server, $Credential\n            $jobs += [PSCustomObject]@{ Job = $job; Server = $server; StartTime = Get-Date }\n            Write-AuditLog \"Job started for $($server.ServerName) - Job ID: $($job.Id)\" -Level Info\n        } else {\n            break\n        }\n    }\n    \n    $remainingServers = $ServerList[$jobs.Count..($ServerList.Count-1)]\n    \n    # Monitor jobs and start new ones as they complete\n    $loopCount = 0\n    $maxLoops = 1800  # 1 hour maximum (3600 seconds / 2 second sleep)\n    while (($jobs.Count -gt 0 -or $remainingServers.Count -gt 0) -and $loopCount -lt $maxLoops) {\n        Start-Sleep -Seconds 2\n        $loopCount++\n        \n        # Enhanced logging every 30 seconds (15 loops)\n        if ($loopCount % 15 -eq 0) {\n            Write-AuditLog \"Job monitoring status: $($jobs.Count) active jobs, $($remainingServers.Count) servers remaining\" -Level Info\n            foreach ($job in $jobs) {\n                $runtime = [math]::Round(((Get-Date) - $job.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"  - Server: $($job.Server.ServerName), State: $($job.Job.State), Runtime: ${runtime} minutes\" -Level Info\n            }\n        }\n        \n        $finishedJobs = $jobs | Where-Object { $_.Job.State -in @('Completed', 'Failed', 'Stopped') }\n        \n        foreach ($finishedJob in $finishedJobs) {\n            try {\n                $runtime = [math]::Round(((Get-Date) - $finishedJob.StartTime).TotalMinutes, 1)\n                Write-AuditLog \"Processing completed job for server: $($finishedJob.Server.ServerName) (Runtime: ${runtime} minutes, State: $($finishedJob.Job.State))\" -Level Info\n                \n                $result = Receive-Job -Job $finishedJob.Job\n                $script:ServerResults += $result\n                $completedServers++\n                \n                Write-AuditLog \"Server audit completed for $($finishedJob.Server.ServerName). Connection Status: $($result.ConnectionStatus), Risk Score: $($result.RiskScore)\" -Level Success\n                \n                # Update separate progress for server audit\n                $serverPercent = [math]::Min([math]::Round(($completedServers / $ServerList.Count) * 100, 1), 100)\n                Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Status \"Completed $($finishedJob.Server.ServerName)\" -PercentComplete $serverPercent -CurrentOperation \"Auditing $completedServers of $($ServerList.Count) servers\"\n                \n                Remove-Job -Job $finishedJob.Job\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n                \n                # Start next job if servers remain\n                if ($remainingServers.Count -gt 0) {\n                    $nextServer = $remainingServers[0]\n                    $remainingServers = $remainingServers[1..($remainingServers.Count-1)]\n                    \n                    Write-AuditLog \"Starting new audit job for server: $($nextServer.ServerName)\" -Level Info\n                    $newJob = Start-Job -ScriptBlock $script:ServerAuditScriptBlock -ArgumentList $nextServer, $Credential\n                    $jobs += [PSCustomObject]@{ Job = $newJob; Server = $nextServer; StartTime = Get-Date }\n                    Write-AuditLog \"New job started for $($nextServer.ServerName) - Job ID: $($newJob.Id)\" -Level Info\n                }\n                \n            } catch {\n                Write-AuditLog \"Error processing job result for $($finishedJob.Server.ServerName): $($_.Exception.Message)\" -Level Error\n                Remove-Job -Job $finishedJob.Job -ErrorAction Stop\n                $jobs = $jobs | Where-Object { $_.Job.Id -ne $finishedJob.Job.Id }\n            }\n        }\n        \n        # Check for hung jobs (running longer than 5 minutes)\n        $hungJobs = $jobs | Where-Object { ((Get-Date) - $_.StartTime).TotalMinutes -gt 5 }\n        foreach ($hungJob in $hungJobs) {\n            $runtime = [math]::Round(((Get-Date) - $hungJob.StartTime).TotalMinutes, 1)\n            Write-AuditLog \"Stopping hung job for server $($hungJob.Server.ServerName) - Runtime: ${runtime} minutes, State: $($hungJob.Job.State)\" -Level Warning\n            \n            # Try to get any partial results\n            try {\n                $partialResult = Receive-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n                if ($partialResult) {\n                    Write-AuditLog \"Retrieved partial results from hung job for $($hungJob.Server.ServerName)\" -Level Info\n                    $script:ServerResults += $partialResult\n                }\n            } catch {\n                Write-AuditLog \"Could not retrieve results from hung job for $($hungJob.Server.ServerName): $($_.Exception.Message)\" -Level Warning\n            }\n            \n            Stop-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $hungJob.Job -ErrorAction SilentlyContinue\n            $jobs = $jobs | Where-Object { $_.Job.Id -ne $hungJob.Job.Id }\n            $completedServers++ # Count as completed even if hung\n            \n            # Add failure finding\n            Add-AuditFinding -Category 'Server Audit' -Title \"Server Audit Timeout: $($hungJob.Server.ServerName)\" -Severity 'Medium' `\n                -Description \"Server audit job exceeded 5-minute timeout limit (Runtime: ${runtime} minutes).\" `\n                -Impact 'Unable to complete comprehensive assessment of server.' `\n                -Recommendation 'Investigate server connectivity and performance issues. Check WinRM, firewall, and authentication settings.' `\n                -Type 'Availability'\n        }\n    }\n    \n    # Check if we exceeded maximum loop count\n    if ($loopCount -ge $maxLoops) {\n        Write-AuditLog \"Server audit monitoring exceeded maximum time limit (1 hour). Forcing completion.\" -Level Warning\n        # Clean up any remaining jobs\n        foreach ($job in $jobs) {\n            Write-AuditLog \"Force stopping job for server: $($job.Server.ServerName)\" -Level Warning\n            Stop-Job -Job $job.Job -ErrorAction SilentlyContinue\n            Remove-Job -Job $job.Job -ErrorAction SilentlyContinue\n        }\n    }\n    \n    Write-Progress -Id 1 -Activity \"Server Infrastructure Audit\" -Completed\n    Write-AuditLog \"Server infrastructure audit completed. Processed $completedServers of $($ServerList.Count) servers\" -Level Success\n}\n\n# Define the script block for server auditing\n$script:ServerAuditScriptBlock = {\n    param($ServerInfo, $Credential)\n    \n    $serverName = $ServerInfo.ServerName\n    $auditResult = [PSCustomObject]@{\n        ServerName = $serverName\n        Description = $ServerInfo.Description\n        Environment = $ServerInfo.Environment\n        PingStatus = 'Unknown'\n        ConnectionStatus = 'Unknown'\n        OperatingSystem = ''\n        OSVersion = ''\n        Architecture = ''\n        Manufacturer = ''\n        Model = ''\n        SerialNumber = ''\n        TotalMemoryGB = 0\n        ProcessorInfo = ''\n        ProcessorCores = 0\n        CPUUtilization = 0\n        MemoryUtilization = 0\n        DiskInfo = @()\n        NetworkAdapters = @()\n        CriticalServices = @()\n        InstalledRoles = @()\n        LocalAdministrators = @()\n        InstalledSoftware = @()\n        ScheduledTasks = @()\n        NetworkShares = @()\n        RecentUpdates = @()\n        SecurityChecks = @{}\n        PendingUpdates = 0\n        LastBootTime = $null\n        UptimeDays = 0\n        SecurityIssues = @()\n        PerformanceIssues = @()\n        Recommendations = @()\n        RiskScore = 0\n        AuditTimestamp = Get-Date\n        ErrorMessages = @()\n    }\n    \n    try {\n        # Test connectivity\n        $pingResult = Test-Connection -ComputerName $serverName -Count 2 -Quiet -ErrorAction Stop\n        $auditResult.PingStatus = if ($pingResult) { 'Online' } else { 'Offline' }\n        \n        if (-not $pingResult) {\n            $auditResult.ConnectionStatus = 'Failed - No Response'\n            $auditResult.ErrorMessages += 'Server not responding to ping'\n            return $auditResult\n        }\n        \n        # Establish remote session with enhanced error handling\n        try {\n            $sessionOption = New-PSSessionOption -OpenTimeout 30000 -OperationTimeout 300000\n            $session = New-PSSession -ComputerName $serverName -Credential $Credential -SessionOption $sessionOption -ErrorAction Stop\n            $auditResult.ConnectionStatus = 'Connected'\n        } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n            $auditResult.ConnectionStatus = 'Failed - WinRM/Remoting Issue'\n            $auditResult.ErrorMessages += \"PowerShell remoting failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.Management.Automation.RuntimeException] {\n            $auditResult.ConnectionStatus = 'Failed - Authentication Issue'\n            $auditResult.ErrorMessages += \"Authentication failed: $($_.Exception.Message)\"\n            return $auditResult\n        } catch [System.TimeoutException] {\n            $auditResult.ConnectionStatus = 'Failed - Timeout'\n            $auditResult.ErrorMessages += \"Connection timeout: $($_.Exception.Message)\"\n            return $auditResult\n        } catch {\n            $auditResult.ConnectionStatus = 'Failed - Unknown Error'\n            $auditResult.ErrorMessages += \"Unexpected connection error: $($_.Exception.Message)\"\n            return $auditResult\n        }\n        \n        # Execute comprehensive remote audit\n        $remoteData = Invoke-Command -Session $session -ScriptBlock {\n            $results = @{\n                Errors = @()\n            }\n            \n            try {\n                # System information\n                $results.OS = Get-CimInstance Win32_OperatingSystem -ErrorAction Stop\n                $results.ComputerSystem = Get-CimInstance Win32_ComputerSystem -ErrorAction Stop\n                $results.BIOS = Get-CimInstance Win32_BIOS -ErrorAction Stop\n                $results.Processor = Get-CimInstance Win32_Processor -ErrorAction Stop\n                \n                # Performance metrics\n                try {\n                    $cpuCounter = Get-Counter \"\\Processor(_Total)\\% Processor Time\" -MaxSamples 3 -ErrorAction Stop\n                    if ($cpuCounter) {\n                        $results.CPUUtilization = [math]::Round(($cpuCounter.CounterSamples | Measure-Object CookedValue -Average).Average, 2)\n                    }\n                } catch {\n                    $results.CPUUtilization = -1\n                }\n                \n                if ($results.ComputerSystem -and $results.OS) {\n                    $memTotal = $results.ComputerSystem.TotalPhysicalMemory\n                    $memAvailable = $results.OS.FreePhysicalMemory * 1KB\n                    $results.MemoryUtilization = [math]::Round((($memTotal - $memAvailable) / $memTotal) * 100, 2)\n                }\n                \n                # Disk information\n                $results.Disks = Get-CimInstance Win32_LogicalDisk -Filter \"DriveType=3\" -ErrorAction Stop\n                \n                # Network adapters\n                $results.NetworkAdapters = Get-CimInstance Win32_NetworkAdapterConfiguration -ErrorAction Stop\n                    Where-Object { $_.IPEnabled -eq $true }\n                \n                # Critical services\n                $criticalServices = @('DHCP', 'DNS', 'W32Time', 'EventLog', 'RpcSs', 'LanmanServer', 'Spooler')\n                $results.Services = Get-Service -Name $criticalServices -ErrorAction Stop | \n                    Select-Object Name, Status, StartType\n                \n                # Windows features/roles\n                try {\n                    $results.WindowsFeatures = Get-WindowsFeature -ErrorAction Stop | \n                        Where-Object { $_.Installed -eq $true } | \n                        Select-Object -ExpandProperty Name\n                } catch {\n                    $results.WindowsFeatures = @()\n                }\n                \n                # Local administrators\n                try {\n                    $results.LocalAdmins = Get-LocalGroupMember -Group \"Administrators\" -ErrorAction Stop | \n                        Select-Object Name, ObjectClass, PrincipalSource\n                } catch {\n                    $results.LocalAdmins = @()\n                }\n                \n                # Windows updates\n                try {\n                    $updateSession = New-Object -ComObject Microsoft.Update.Session -ErrorAction Stop\n                    if ($updateSession) {\n                        $updateSearcher = $updateSession.CreateUpdateSearcher()\n                        $searchResult = $updateSearcher.Search(\"IsInstalled=0\")\n                        $results.PendingUpdates = $searchResult.Updates.Count\n                    } else {\n                        $results.PendingUpdates = -1\n                    }\n                } catch {\n                    $results.PendingUpdates = -1\n                }\n                \n                # System uptime\n                if ($results.OS) {\n                    $results.LastBoot = $results.OS.LastBootUpTime\n                    $results.UptimeDays = [math]::Round(((Get-Date) - $results.LastBoot).TotalDays, 1)\n                }\n                \n                # Event log errors (last 24 hours)\n                try {\n                    $results.RecentErrors = Get-WinEvent -FilterHashtable @{\n                        LogName='System','Application'\n                        Level=1,2  # Critical and Error\n                        StartTime=(Get-Date).AddDays(-1)\n                    } -MaxEvents 10 -ErrorAction Stop\n                } catch {\n                    $results.RecentErrors = @()\n                }\n                \n                # Security configuration checks\n                $results.SecurityChecks = @{}\n                \n                # Windows Defender status\n                try {\n                    $results.SecurityChecks.DefenderStatus = Get-MpComputerStatus -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.DefenderStatus = $null\n                }\n                \n                # Firewall status\n                try {\n                    $results.SecurityChecks.FirewallProfiles = Get-NetFirewallProfile -ErrorAction Stop\n                } catch {\n                    $results.SecurityChecks.FirewallProfiles = @()\n                }\n                \n                # Installed software audit\n                try {\n                    $results.InstalledSoftware = Get-ItemProperty \"HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*\" -ErrorAction Stop | \n                        Where-Object { $_.DisplayName -and $_.DisplayName -ne \"\" } |\n                        Select-Object DisplayName, DisplayVersion, Publisher, InstallDate |\n                        Sort-Object DisplayName\n                } catch {\n                    $results.InstalledSoftware = @()\n                    $results.Errors += \"Failed to retrieve installed software\"\n                }\n                \n                # Scheduled tasks audit\n                try {\n                    $results.ScheduledTasks = Get-ScheduledTask -ErrorAction Stop | \n                        Where-Object { $_.State -eq 'Ready' -and $_.TaskPath -notlike '\\Microsoft\\*' } |\n                        Select-Object TaskName, TaskPath, State, @{N='NextRun';E={$_.NextRunTime}}, @{N='LastRun';E={$_.LastRunTime}}\n                } catch {\n                    $results.ScheduledTasks = @()\n                    $results.Errors += \"Failed to retrieve scheduled tasks\"\n                }\n                \n                # SMBv1 status check\n                try {\n                    $results.SecurityChecks.SMBv1Status = @{}\n                    # Check if SMBv1 feature is installed\n                    $smb1Feature = Get-WindowsOptionalFeature -Online -FeatureName SMB1Protocol -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.FeatureInstalled = ($smb1Feature.State -eq 'Enabled')\n                    \n                    # Check registry settings\n                    $smb1RegPath = \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters\"\n                    $smb1RegValue = Get-ItemProperty -Path $smb1RegPath -Name \"SMB1\" -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.SMBv1Status.RegistryEnabled = ($smb1RegValue.SMB1 -eq 1)\n                } catch {\n                    $results.SecurityChecks.SMBv1Status = @{FeatureInstalled = $null; RegistryEnabled = $null}\n                    $results.Errors += \"Failed to check SMBv1 status\"\n                }\n                \n                # Network shares audit\n                try {\n                    $results.NetworkShares = Get-SmbShare -ErrorAction Stop | \n                        Where-Object { $_.Name -notin @('ADMIN$', 'C$', 'IPC$', 'print$') } |\n                        Select-Object Name, Path, Description, ShareType, @{N='AccessRight';E={\n                            try {\n                                $acl = Get-SmbShareAccess -Name $_.Name -ErrorAction SilentlyContinue\n                                ($acl | ForEach-Object { \"$($_.AccountName):$($_.AccessRight)\" }) -join '; '\n                            } catch {\n                                'Unable to retrieve'\n                            }\n                        }}\n                } catch {\n                    $results.NetworkShares = @()\n                    $results.Errors += \"Failed to retrieve network shares\"\n                }\n                \n                # Enhanced antivirus detection\n                try {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                    \n                    # Windows Defender already checked above\n                    \n                    # Check for third-party antivirus via WMI\n                    try {\n                        $avProducts = Get-CimInstance -Namespace \"root\\SecurityCenter2\" -ClassName \"AntiVirusProduct\" -ErrorAction SilentlyContinue\n                        if ($avProducts) {\n                            $results.SecurityChecks.AntivirusProducts = $avProducts | ForEach-Object {\n                                [PSCustomObject]@{\n                                    Name = $_.displayName\n                                    State = switch ($_.productState) {\n                                        { $_ -band 0x1000 } { 'Enabled' }\n                                        default { 'Disabled' }\n                                    }\n                                    UpToDate = switch ($_.productState) {\n                                        { $_ -band 0x10 } { 'Yes' }\n                                        default { 'No' }\n                                    }\n                                }\n                            }\n                        }\n                    } catch {\n                        $results.Errors += \"Failed to query third-party antivirus products\"\n                    }\n                } catch {\n                    $results.SecurityChecks.AntivirusProducts = @()\n                }\n                \n                # PowerShell remoting configuration\n                try {\n                    $results.SecurityChecks.PSRemoting = @{}\n                    $winrm = Get-Service WinRM -ErrorAction SilentlyContinue\n                    $results.SecurityChecks.PSRemoting.ServiceStatus = $winrm.Status\n                    \n                    # Check WinRM listeners\n                    $listeners = winrm enumerate winrm/config/listener 2>$null\n                    $results.SecurityChecks.PSRemoting.HasListeners = ($listeners -ne $null)\n                } catch {\n                    $results.SecurityChecks.PSRemoting = @{ServiceStatus = 'Unknown'; HasListeners = $false}\n                    $results.Errors += \"Failed to check PowerShell remoting configuration\"\n                }\n                \n                # BitLocker encryption status\n                try {\n                    $results.SecurityChecks.BitLocker = @()\n                    $bitlockerVolumes = Get-BitLockerVolume -ErrorAction SilentlyContinue\n                    if ($bitlockerVolumes) {\n                        $results.SecurityChecks.BitLocker = $bitlockerVolumes | ForEach-Object {\n                            [PSCustomObject]@{\n                                MountPoint = $_.MountPoint\n                                EncryptionMethod = $_.EncryptionMethod\n                                VolumeStatus = $_.VolumeStatus\n                                ProtectionStatus = $_.ProtectionStatus\n                                EncryptionPercentage = $_.EncryptionPercentage\n                            }\n                        }\n                    }\n                } catch {\n                    $results.SecurityChecks.BitLocker = @()\n                    $results.Errors += \"Failed to check BitLocker status\"\n                }\n                \n                # Recent Windows updates\n                try {\n                    $results.RecentUpdates = Get-HotFix -ErrorAction Stop | \n                        Sort-Object InstalledOn -Descending | \n                        Select-Object -First 10 Description, HotFixID, InstalledBy, InstalledOn\n                } catch {\n                    $results.RecentUpdates = @()\n                    $results.Errors += \"Failed to retrieve recent updates\"\n                }\n                \n                # Time synchronization configuration\n                try {\n                    $results.SecurityChecks.TimeSync = @{}\n                    $w32time = w32tm /query /status 2>$null\n                    $results.SecurityChecks.TimeSync.W32TimeStatus = if ($w32time) { 'Configured' } else { 'Not Configured' }\n                    \n                    $ntpServer = w32tm /query /peers 2>$null | Where-Object { $_ -match \"Peer:\" }\n                    $results.SecurityChecks.TimeSync.NTPServers = if ($ntpServer) { $ntpServer -join '; ' } else { 'None configured' }\n                } catch {\n                    $results.SecurityChecks.TimeSync = @{W32TimeStatus = 'Unknown'; NTPServers = 'Unknown'}\n                    $results.Errors += \"Failed to check time synchronization\"\n                }\n                \n            } catch {\n                $results.Errors += \"General error: $($_.Exception.Message)\"\n            }\n            \n            return $results\n        }\n        \n        # Process remote data\n        if ($remoteData.OS) {\n            $auditResult.OperatingSystem = $remoteData.OS.Caption\n            $auditResult.OSVersion = $remoteData.OS.Version\n            $auditResult.Architecture = $remoteData.OS.OSArchitecture\n        }\n        \n        if ($remoteData.ComputerSystem) {\n            $auditResult.Manufacturer = $remoteData.ComputerSystem.Manufacturer\n            $auditResult.Model = $remoteData.ComputerSystem.Model\n            $auditResult.TotalMemoryGB = [math]::Round($remoteData.ComputerSystem.TotalPhysicalMemory / 1GB, 2)\n        }\n        \n        if ($remoteData.BIOS) {\n            $auditResult.SerialNumber = $remoteData.BIOS.SerialNumber\n        }\n        \n        if ($remoteData.Processor) {\n            $auditResult.ProcessorInfo = ($remoteData.Processor | Select-Object -First 1).Name\n            $auditResult.ProcessorCores = ($remoteData.Processor | Measure-Object NumberOfCores -Sum).Sum\n        }\n        \n        $auditResult.CPUUtilization = $remoteData.CPUUtilization\n        $auditResult.MemoryUtilization = $remoteData.MemoryUtilization\n        $auditResult.LastBootTime = $remoteData.LastBoot\n        $auditResult.UptimeDays = $remoteData.UptimeDays\n        $auditResult.PendingUpdates = $remoteData.PendingUpdates\n        $auditResult.CriticalServices = $remoteData.Services\n        $auditResult.InstalledRoles = $remoteData.WindowsFeatures\n        $auditResult.LocalAdministrators = $remoteData.LocalAdmins\n        $auditResult.InstalledSoftware = $remoteData.InstalledSoftware\n        $auditResult.ScheduledTasks = $remoteData.ScheduledTasks\n        $auditResult.NetworkShares = $remoteData.NetworkShares\n        $auditResult.RecentUpdates = $remoteData.RecentUpdates\n        $auditResult.SecurityChecks = $remoteData.SecurityChecks\n        \n        # Process disk information\n        if ($remoteData.Disks) {\n            $auditResult.DiskInfo = $remoteData.Disks | ForEach-Object {\n                $freePercent = if ($_.Size -gt 0) { [math]::Round(($_.FreeSpace / $_.Size) * 100, 1) } else { 0 }\n                [PSCustomObject]@{\n                    Drive = $_.DeviceID\n                    SizeGB = [math]::Round($_.Size / 1GB, 2)\n                    FreeSpaceGB = [math]::Round($_.FreeSpace / 1GB, 2)\n                    FreeSpacePercent = $freePercent\n                    FileSystem = $_.FileSystem\n                }\n            }\n        }\n        \n        # Process network adapters\n        if ($remoteData.NetworkAdapters) {\n            $auditResult.NetworkAdapters = $remoteData.NetworkAdapters | ForEach-Object {\n                [PSCustomObject]@{\n                    Description = $_.Description\n                    IPAddress = $_.IPAddress -join ', '\n                    DHCPEnabled = $_.DHCPEnabled\n                    DNSServers = $_.DNSServerSearchOrder -join ', '\n                }\n            }\n        }\n        \n        # Security and performance analysis\n        $securityIssues = @()\n        $performanceIssues = @()\n        $recommendations = @()\n        $riskScore = 0\n        \n        # High CPU utilization\n        if ($auditResult.CPUUtilization -gt 80) {\n            $performanceIssues += \"High CPU utilization: $($auditResult.CPUUtilization)%\"\n            $recommendations += \"Investigate high CPU usage and optimize workloads\"\n            $riskScore += 2\n        }\n        \n        # High memory utilization\n        if ($auditResult.MemoryUtilization -gt 85) {\n            $performanceIssues += \"High memory utilization: $($auditResult.MemoryUtilization)%\"\n            $recommendations += \"Consider memory upgrade or workload redistribution\"\n            $riskScore += 2\n        }\n        \n        # Low disk space\n        $lowDiskSpace = $auditResult.DiskInfo | Where-Object { $_.FreeSpacePercent -lt 15 }\n        if ($lowDiskSpace) {\n            $performanceIssues += \"Low disk space on drives: $($lowDiskSpace.Drive -join ', ')\"\n            $recommendations += \"Urgent: Free up disk space or expand storage\"\n            $riskScore += 3\n        }\n        \n        # Pending updates\n        if ($auditResult.PendingUpdates -gt 0) {\n            $securityIssues += \"$($auditResult.PendingUpdates) pending Windows updates\"\n            $recommendations += \"Install pending Windows updates during next maintenance window\"\n            $riskScore += 1\n        }\n        \n        # Excessive uptime\n        if ($auditResult.UptimeDays -gt 90) {\n            $securityIssues += \"Server uptime exceeds 90 days ($($auditResult.UptimeDays) days)\"\n            $recommendations += \"Schedule reboot during maintenance window to apply updates\"\n            $riskScore += 1\n        }\n        \n        # Service status issues\n        $stoppedServices = $auditResult.CriticalServices | Where-Object { $_.Status -ne 'Running' -and $_.StartType -eq 'Automatic' }\n        if ($stoppedServices) {\n            $securityIssues += \"Critical services not running: $($stoppedServices.Name -join ', ')\"\n            $recommendations += \"Investigate and start critical services\"\n            $riskScore += 3\n        }\n        \n        # Windows Defender status\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            $defender = $remoteData.SecurityChecks.DefenderStatus\n            if (-not $defender.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender or verify third-party antivirus is active\"\n                $riskScore += 3\n            }\n            if (-not $defender.RealTimeProtectionEnabled) {\n                $securityIssues += \"Real-time protection is disabled\"\n                $recommendations += \"Enable real-time protection immediately\"\n                $riskScore += 3\n            }\n        }\n        \n        # Firewall status\n        if ($remoteData.SecurityChecks.FirewallProfiles) {\n            $disabledProfiles = $remoteData.SecurityChecks.FirewallProfiles | Where-Object { -not $_.Enabled }\n            if ($disabledProfiles) {\n                $securityIssues += \"Windows Firewall disabled on profiles: $($disabledProfiles.Name -join ', ')\"\n                $recommendations += \"Enable Windows Firewall on all network profiles\"\n                $riskScore += 2\n            }\n        }\n        \n        # Excessive local administrators\n        $userAdmins = $auditResult.LocalAdministrators | Where-Object { $_.ObjectClass -eq 'User' }\n        if ($userAdmins.Count -gt 3) {\n            $securityIssues += \"Excessive local administrators: $($userAdmins.Count) user accounts\"\n            $recommendations += \"Review and reduce local administrator accounts\"\n            $riskScore += 2\n        }\n        \n        # SMBv1 security check\n        if ($remoteData.SecurityChecks.SMBv1Status) {\n            if ($remoteData.SecurityChecks.SMBv1Status.FeatureInstalled -eq $true) {\n                $securityIssues += \"SMBv1 protocol is enabled (security risk)\"\n                $recommendations += \"Disable SMBv1 protocol to prevent security vulnerabilities\"\n                $riskScore += 3\n            }\n            if ($remoteData.SecurityChecks.SMBv1Status.RegistryEnabled -eq $true) {\n                $securityIssues += \"SMBv1 enabled in registry settings\"\n                $recommendations += \"Disable SMBv1 in registry settings\"\n                $riskScore += 2\n            }\n        }\n        \n        # Network shares security review\n        if ($auditResult.NetworkShares -and $auditResult.NetworkShares.Count -gt 0) {\n            $publicShares = $auditResult.NetworkShares | Where-Object { $_.AccessRight -match \"Everyone\" }\n            if ($publicShares.Count -gt 0) {\n                $securityIssues += \"Network shares with 'Everyone' permissions found: $($publicShares.Count)\"\n                $recommendations += \"Review and restrict network share permissions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Antivirus status check\n        if ($remoteData.SecurityChecks.DefenderStatus) {\n            if (-not $remoteData.SecurityChecks.DefenderStatus.RealTimeProtectionEnabled) {\n                $securityIssues += \"Windows Defender real-time protection is disabled\"\n                $recommendations += \"Enable Windows Defender real-time protection\"\n                $riskScore += 3\n            }\n            if (-not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"Windows Defender antivirus is disabled\"\n                $recommendations += \"Enable Windows Defender antivirus protection\"\n                $riskScore += 3\n            }\n        }\n        \n        # Third-party antivirus check\n        if ($remoteData.SecurityChecks.AntivirusProducts) {\n            $enabledAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.State -eq 'Enabled' }\n            $outdatedAV = $remoteData.SecurityChecks.AntivirusProducts | Where-Object { $_.UpToDate -eq 'No' }\n            \n            if ($enabledAV.Count -eq 0 -and -not $remoteData.SecurityChecks.DefenderStatus.AntivirusEnabled) {\n                $securityIssues += \"No active antivirus protection detected\"\n                $recommendations += \"Install and enable antivirus protection\"\n                $riskScore += 4\n            }\n            \n            if ($outdatedAV.Count -gt 0) {\n                $securityIssues += \"Outdated antivirus definitions detected\"\n                $recommendations += \"Update antivirus definitions\"\n                $riskScore += 2\n            }\n        }\n        \n        # Scheduled tasks security review\n        if ($auditResult.ScheduledTasks -and $auditResult.ScheduledTasks.Count -gt 5) {\n            $securityIssues += \"Multiple custom scheduled tasks detected: $($auditResult.ScheduledTasks.Count)\"\n            $recommendations += \"Review scheduled tasks for unauthorized or suspicious activities\"\n            $riskScore += 1\n        }\n        \n        # BitLocker encryption check\n        if ($remoteData.SecurityChecks.BitLocker) {\n            $unencryptedVolumes = $remoteData.SecurityChecks.BitLocker | Where-Object { $_.VolumeStatus -ne 'FullyEncrypted' }\n            if ($unencryptedVolumes.Count -gt 0) {\n                $securityIssues += \"Unencrypted volumes detected: $($unencryptedVolumes.Count)\"\n                $recommendations += \"Enable BitLocker encryption on all system volumes\"\n                $riskScore += 2\n            }\n        } else {\n            $securityIssues += \"BitLocker status could not be determined\"\n            $recommendations += \"Verify BitLocker encryption status\"\n            $riskScore += 1\n        }\n        \n        # PowerShell remoting security\n        if ($remoteData.SecurityChecks.PSRemoting.ServiceStatus -eq 'Running' -and $remoteData.SecurityChecks.PSRemoting.HasListeners) {\n            $securityIssues += \"PowerShell remoting is enabled and listening\"\n            $recommendations += \"Review PowerShell remoting configuration and security settings\"\n            $riskScore += 1\n        }\n        \n        # Time synchronization check\n        if ($remoteData.SecurityChecks.TimeSync.W32TimeStatus -eq 'Not Configured') {\n            $securityIssues += \"Time synchronization not properly configured\"\n            $recommendations += \"Configure proper time synchronization with domain or NTP servers\"\n            $riskScore += 1\n        }\n        \n        $auditResult.SecurityIssues = $securityIssues\n        $auditResult.PerformanceIssues = $performanceIssues\n        $auditResult.Recommendations = $recommendations\n        $auditResult.RiskScore = $riskScore\n        $auditResult.ErrorMessages = $remoteData.Errors\n        \n        # Clean up session with error handling\n        try {\n            Remove-PSSession $session -ErrorAction Stop\n        } catch {\n            $auditResult.ErrorMessages += \"Session cleanup warning: $($_.Exception.Message)\"\n        }\n        \n    } catch [System.Management.Automation.Remoting.PSRemotingTransportException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Execution Error'\n        $auditResult.ErrorMessages += \"Remote command execution failed: $($_.Exception.Message)\"\n    } catch [System.TimeoutException] {\n        $auditResult.ConnectionStatus = 'Failed - Remote Command Timeout'\n        $auditResult.ErrorMessages += \"Remote command timeout: $($_.Exception.Message)\"\n    } catch [System.UnauthorizedAccessException] {\n        $auditResult.ConnectionStatus = 'Failed - Access Denied'\n        $auditResult.ErrorMessages += \"Access denied during audit: $($_.Exception.Message)\"\n    } catch {\n        $auditResult.ConnectionStatus = 'Failed - Audit Error'\n        $auditResult.ErrorMessages += \"Unexpected audit error: $($_.Exception.Message)\"\n        \n        # Include inner exception details if available\n        if ($_.Exception.InnerException) {\n            $auditResult.ErrorMessages += \"Inner exception: $($_.Exception.InnerException.Message)\"\n        }\n    } finally {\n        # Ensure session cleanup in finally block\n        if ($session) {\n            try {\n                Remove-PSSession $session -ErrorAction SilentlyContinue\n            } catch {\n                # Silently handle cleanup errors in finally block\n            }\n        }\n    }\n    \n    return $auditResult\n}\n\n# ==============================================================================\n# REPORT GENERATION FUNCTIONS\n# ==============================================================================\n\nfunction New-ComprehensiveAuditReport {\n    Write-AuditLog 'Generating comprehensive audit reports...' -Level Header\n    \n    try {\n        # Calculate overall statistics\n        $summary = Get-AuditSummaryStatistics\n        \n        # Generate reports in requested formats\n        foreach ($format in $ExportFormats) {\n            switch ($format) {\n                'HTML' { New-HTMLReport -Summary $summary }\n                'Excel' { New-ExcelReport -Summary $summary }\n                'CSV' { New-CSVReport -Summary $summary }\n                'Markdown' { New-MarkdownReport -Summary $summary }\n                'PDF' { New-PDFReport -Summary $summary }\n            }\n        }\n        \n        # Generate executive summary\n        New-ExecutiveSummary -Summary $summary\n        \n        Write-AuditLog \"All reports generated successfully in: $script:OutputDir\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating reports: $($_.Exception.Message)\" -Level Error\n    }\n}\n\nfunction Get-AuditSummaryStatistics {\n    $totalFindings = $script:AuditFindings.Count\n    $criticalFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }).Count\n    $highFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'High' }).Count\n    $mediumFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }).Count\n    $lowFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }).Count\n    $passedFindings = ($script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }).Count\n    $issuesFindings = $totalFindings - $passedFindings\n    \n    $totalServers = $script:ServerResults.Count\n    $onlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Online' }).Count\n    $offlineServers = ($script:ServerResults | Where-Object { $_.PingStatus -eq 'Offline' }).Count\n    $highRiskServers = ($script:ServerResults | Where-Object { $_.RiskScore -gt 5 }).Count\n    \n    $totalRiskScore = ($script:AuditFindings | Measure-Object -Property Score -Sum).Sum\n    $overallRisk = if ($criticalFindings -gt 0) { 'CRITICAL' }\n                  elseif ($highFindings -gt 3) { 'HIGH' }\n                  elseif ($highFindings -gt 0 -or $mediumFindings -gt 5) { 'MEDIUM' }\n                  else { 'LOW' }\n    \n    return [PSCustomObject]@{\n        CustomerName = $CustomerName\n        TechnicianName = $TechnicianName\n        AuditDate = $script:StartTime\n        AuditDuration = (Get-Date) - $script:StartTime\n        TotalFindings = $totalFindings\n        IssuesFindings = $issuesFindings\n        PassedFindings = $passedFindings\n        CriticalFindings = $criticalFindings\n        HighFindings = $highFindings\n        MediumFindings = $mediumFindings\n        LowFindings = $lowFindings\n        TotalServers = $totalServers\n        OnlineServers = $onlineServers\n        OfflineServers = $offlineServers\n        HighRiskServers = $highRiskServers\n        TotalRiskScore = $totalRiskScore\n        OverallRisk = $overallRisk\n        ComplianceFrameworks = $script:ComplianceFrameworks\n    }\n}\n\nfunction New-HTMLReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating HTML report...' -Level Info\n    \n    $htmlPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.html'\n    \n    $riskColor = switch ($Summary.OverallRisk) {\n        'CRITICAL' { '#dc3545' }\n        'HIGH' { '#fd7e14' }\n        'MEDIUM' { '#ffc107' }\n        'LOW' { '#28a745' }\n    }\n    \n    $htmlContent = @\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Infrastructure Audit Report - $CustomerName</title>\n    <style>\n        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 10px; background: #f8f9fa; line-height: 1.4; }\n        .container { max-width: 1400px; margin: 0 auto; background: white; padding: 15px; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n        .header { margin-bottom: 15px; padding: 12px; background: linear-gradient(135deg, #003366 0%, #004d99 100%); color: white; border-radius: 6px; display: flex; align-items: center; justify-content: space-between; }\n        .header-content { text-align: center; flex: 1; }\n        .header-info { text-align: right; width: 250px; }\n        .logo { max-height: 80px; max-width: 250px; }\n        .risk-banner { text-align: center; padding: 10px; margin: 10px 0; border-radius: 6px; color: white; font-size: 1.3em; font-weight: bold; background: $riskColor; }\n        .metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px; margin: 15px 0; }\n        .metric-card { background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .metric-number { font-size: 2.0em; font-weight: bold; margin: 5px 0; }\n        .critical { color: #dc3545; }\n        .high { color: #fd7e14; }\n        .medium { color: #ffc107; color: #333; }\n        .low { color: #28a745; }\n        table { width: 100%; border-collapse: collapse; margin: 10px 0; }\n        th, td { padding: 8px; text-align: left; border: 1px solid #dee2e6; }\n        th { background: #495057; color: white; }\n        tr:nth-child(even) { background: #f8f9fa; }\n        .section { margin: 20px 0; }\n        .section h2 { color: #495057; border-bottom: 2px solid #dee2e6; padding-bottom: 6px; font-size: 1.6em; margin: 10px 0; }\n        \n        /* Detailed Findings Styling */\n        .findings-container { margin: 10px 0; }\n        .finding-group { margin: 15px 0; border-radius: 6px; overflow: hidden; box-shadow: 0 1px 4px rgba(0,0,0,0.1); }\n        .finding-group-title { background: #495057; color: white; margin: 0; padding: 12px; font-size: 1.2em; font-weight: bold; }\n        .critical-section .finding-group-title { background: #dc3545; }\n        .high-section .finding-group-title { background: #fd7e14; }\n        .medium-section .finding-group-title { background: #ffc107; color: #333; }\n        .low-section .finding-group-title { background: #28a745; }\n        .passed-section .finding-group-title { background: #17a2b8; }\n        \n        .finding-item { background: white; border-bottom: 1px solid #dee2e6; padding: 15px; }\n        .finding-item:last-child { border-bottom: none; }\n        \n        /* Collapsible Findings */\n        .finding-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; padding: 10px; border-radius: 5px; margin-bottom: 8px; transition: background-color 0.3s; }\n        .finding-header:hover { background: #e9ecef; }\n        .finding-title { font-weight: bold; color: #495057; margin: 0; }\n        .finding-toggle { font-size: 1.2em; font-weight: bold; color: #6c757d; transition: transform 0.3s; }\n        .finding-content { display: none; padding: 12px; background: white; border-radius: 5px; border: 1px solid #dee2e6; }\n        .finding-content.show { display: block; }\n        .finding-toggle.open { transform: rotate(45deg); }\n        .finding-header { margin-bottom: 10px; }\n        .finding-header h4 { margin: 0 0 6px 0; font-size: 1.2em; color: #333; }\n        .finding-meta { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; }\n        .finding-id, .finding-category, .finding-type { \n            background: #e9ecef; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; color: #666; \n        }\n        .severity-badge { \n            padding: 6px 12px; border-radius: 20px; font-weight: bold; font-size: 0.85em; text-transform: uppercase; \n        }\n        .severity-badge.critical { background: #dc3545; color: white; }\n        .severity-badge.high { background: #fd7e14; color: white; }\n        .severity-badge.medium { background: #ffc107; color: #333; }\n        .severity-badge.low { background: #28a745; color: white; }\n        \n        .finding-content { margin-top: 10px; }\n        .description-section, .impact-section, .recommendation-section, .evidence-section { \n            margin: 10px 0; padding: 10px; border-radius: 5px; \n        }\n        .description-section { background: #f8f9fa; border-left: 4px solid #007bff; }\n        .impact-section { background: #fff5f5; border-left: 4px solid #dc3545; }\n        .recommendation-section { background: #f0f9ff; border-left: 4px solid #10b981; }\n        .evidence-section { background: #fffbeb; border-left: 4px solid #f59e0b; }\n        \n        .finding-content h5 { \n            margin: 0 0 6px 0; font-size: 1.0em; color: #333; font-weight: 600; \n        }\n        .finding-content p { margin: 0; color: #555; }\n        .evidence-data { \n            background: #2d3748; color: #e2e8f0; padding: 10px; border-radius: 4px; \n            font-family: 'Consolas', 'Monaco', monospace; font-size: 0.85em; margin: 6px 0 0 0;\n            white-space: pre-wrap; word-wrap: break-word; overflow-x: auto; \n        }\n        .compliance-tag { \n            background: #3b82f6; color: white; padding: 3px 8px; border-radius: 4px; \n            font-size: 0.9em; font-weight: 500; \n        }\n        .finding-footer { \n            margin-top: 20px; padding-top: 15px; border-top: 1px solid #e5e7eb; \n            font-size: 0.95em; color: #6b7280; \n        }\n        \n        /* Executive Summary Styling */\n        .executive-summary { background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; }\n        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 10px; margin-bottom: 15px; }\n        .summary-card { background: white; padding: 12px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .summary-card h3 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .summary-card ul { margin: 0; padding-left: 15px; }\n        .summary-card li { margin: 4px 0; color: #555; }\n        .risk-level { font-weight: bold; padding: 4px 8px; border-radius: 4px; }\n        .risk-level.critical { background: #dc3545; color: white; }\n        .risk-level.high { background: #fd7e14; color: white; }\n        .risk-level.medium { background: #ffc107; color: #333; }\n        .risk-level.low { background: #28a745; color: white; }\n        .key-findings { margin: 15px 0; }\n        .concern-list { margin: 10px 0; }\n        .concern-item { display: flex; align-items: flex-start; margin: 8px 0; padding: 10px; background: white; border-radius: 5px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }\n        .concern-icon { font-size: 1.1em; margin-right: 10px; flex-shrink: 0; }\n        .concern-content { flex: 1; color: #555; }\n        .concern-content strong { color: #333; }\n        .concern-content small { color: #777; }\n        .compliance-overview { margin: 25px 0; }\n        .compliance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }\n        .compliance-item { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }\n        .compliance-item h4 { margin: 0 0 8px 0; color: #333; font-size: 1.1em; }\n        .compliance-item p { margin: 0; color: #666; font-size: 0.95em; }\n        \n        .report-links { text-align: center; margin: 30px 0; }\n        .report-links a { display: inline-block; margin: 10px; padding: 12px 25px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold; }\n        .report-links a:hover { background: #0056b3; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <div class=\"logo-container\">\n                <img src=\"data:image/png;base64,$(Convert-ToBase64 \"$($script:LogoPath)\")\" alt=\"First Technology Logo\" class=\"logo\">\n            </div>\n            <div class=\"header-content\">\n                <h1>AD Domain Security & Compliance Audit Report</h1>\n                <p style=\"font-size: 1.3em; font-weight: bold;\">Customer: $CustomerName</p>\n            </div>\n            <div class=\"header-info\">\n                <p>Audit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</p>\n                <p>Auditor/Engineer: $($Summary.TechnicianName)</p>\n            </div>\n        </div>\n        \n        <div class=\"risk-banner\">\n            OVERALL SECURITY RISK: $($Summary.OverallRisk)\n        </div>\n        \n        <div class=\"metrics-grid\">\n            <div class=\"metric-card\">\n                <div class=\"metric-number critical\">$($Summary.CriticalFindings)</div>\n                <div>Critical Issues</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number high\">$($Summary.HighFindings)</div>\n                <div>High Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number medium\">$($Summary.MediumFindings)</div>\n                <div>Medium Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number low\">$($Summary.LowFindings)</div>\n                <div>Low Priority</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\" style=\"color: #17a2b8;\">$($Summary.PassedFindings)</div>\n                <div>Controls Passed</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.IssuesFindings)</div>\n                <div>Issues Found</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$($Summary.TotalFindings)</div>\n                <div>Total Checks</div>\n            </div>\n            <div class=\"metric-card\">\n                <div class=\"metric-number\">$(($script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | Group-Object ComplianceFramework).Count)</div>\n                <div>Compliance Frameworks</div>\n            </div>\n        </div>\n\n        <div class=\"report-links\">\n            <h3>Download Detailed Reports</h3>\n            <a href=\"Infrastructure-Audit-Report.xlsx\">📊 Excel Report</a>\n            <a href=\"Infrastructure-Audit-Report.csv\">📄 CSV Report</a>\n            <a href=\"Executive-Summary.txt\">📋 Executive Summary</a>\n        </div>\n        \n        <div class=\"section\">\n            <h2>📋 Detailed Security Findings</h2>\n            <div style=\"text-align: right; margin: 10px 0;\">\n                <button onclick=\"expandAll()\" style=\"margin-right: 10px; padding: 8px 15px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;\">Expand All</button>\n                <button onclick=\"collapseAll()\" style=\"padding: 8px 15px; background: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer;\">Collapse All</button>\n            </div>\n            <div class=\"findings-container\">\n$(\n    # Group findings by severity for better organization\n    $criticalFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Critical' }\n    $highFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'High' }\n    $mediumFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    $lowFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Low' }\n    $passedFindings = $script:AuditFindings | Where-Object { $_.Severity -eq 'Passed' }\n    \n    $allGroupedFindings = @()\n    if ($criticalFindings.Count -gt 0) { $allGroupedFindings += @{Title='🔴 CRITICAL FINDINGS'; Findings=$criticalFindings; Class='critical-section'} }\n    if ($highFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟠 HIGH PRIORITY FINDINGS'; Findings=$highFindings; Class='high-section'} }\n    if ($mediumFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟡 MEDIUM PRIORITY FINDINGS'; Findings=$mediumFindings; Class='medium-section'} }\n    if ($lowFindings.Count -gt 0) { $allGroupedFindings += @{Title='🟢 LOW PRIORITY FINDINGS'; Findings=$lowFindings; Class='low-section'} }\n    if ($passedFindings.Count -gt 0) { $allGroupedFindings += @{Title='✅ SECURITY CONTROLS PASSED'; Findings=$passedFindings; Class='passed-section'} }\n    \n    foreach ($group in $allGroupedFindings) {\n        $output = @\"\n                <div class=\"finding-group $($group.Class)\">\n                    <h3 class=\"finding-group-title\">$($group.Title) ($($group.Findings.Count) Issues)</h3>\n\"@\n        \n        foreach ($finding in $group.Findings) {\n            $severityIcon = switch ($finding.Severity) {\n                'Critical' { '🔴' }\n                'High' { '🟠' }\n                'Medium' { '🟡' }\n                'Low' { '🟢' }\n                'Passed' { '✅' }\n                default { '⚪' }\n            }\n            \n            $evidenceSection = if ($finding.Evidence -and $finding.Evidence.Trim() -ne '') {\n                @\"\n                        <div class=\"evidence-section\">\n                            <h5>📊 Evidence/Data:</h5>\n                            <pre class=\"evidence-data\">$($finding.Evidence)</pre>\n                        </div>\n\"@\n            } else { '' }\n            \n            $complianceSection = if ($finding.ComplianceFramework -and $finding.ComplianceFramework.Trim() -ne '') {\n                \"<p><strong>📝 Compliance Framework:</strong> <span class='compliance-tag'>$($finding.ComplianceFramework)</span></p>\"\n            } else { '' }\n            \n            $output += @\"\n                    <div class=\"finding-item $($finding.Severity.ToLower())-finding\">\n                        <div class=\"finding-header\" onclick=\"toggleFinding('$($finding.ID)')\">\n                            <div>\n                                <h4 class=\"finding-title\">$severityIcon $($finding.Title)</h4>\n                                <div class=\"finding-meta\">\n                                    <span class=\"finding-id\">ID: $($finding.ID)</span>\n                                    <span class=\"finding-category\">$($finding.Category)</span>\n                                    <span class=\"finding-type\">$($finding.Type)</span>\n                                    <span class=\"severity-badge $($finding.Severity.ToLower())\">$($finding.Severity.ToUpper())</span>\n                                </div>\n                            </div>\n                            <span class=\"finding-toggle\" id=\"toggle-$($finding.ID)\">+</span>\n                        </div>\n                        \n                        <div class=\"finding-content\" id=\"content-$($finding.ID)\">\n                            <div class=\"description-section\">\n                                <h5>📋 Description:</h5>\n                                <p>$($finding.Description)</p>\n                            </div>\n                            \n                            <div class=\"impact-section\">\n                                <h5>⚠️ Business Impact:</h5>\n                                <p>$($finding.Impact)</p>\n                            </div>\n                            \n                            <div class=\"recommendation-section\">\n                                <h5>🔧 Recommended Action:</h5>\n                                <p>$($finding.Recommendation)</p>\n                            </div>\n                            \n                            $evidenceSection\n                            \n                            <div class=\"finding-footer\">\n                                $complianceSection\n                                <p><strong>⏰ Discovered:</strong> $($finding.Timestamp.ToString('yyyy-MM-dd HH:mm:ss'))</p>\n                            </div>\n                        </div>\n                    </div>\n\"@\n        }\n        \n        $output += @\"\n                </div>\n\"@\n        $output\n    }\n)\n            </div>\n        </div>\n        \n\n\n        <div class=\"section\">\n            <h2>📊 Executive Summary & Risk Analysis</h2>\n            <div class=\"executive-summary\">\n                <div class=\"summary-grid\">\n                    <div class=\"summary-card\">\n                        <h3>🔍 Audit Scope</h3>\n                        <ul>\n                            <li><strong>Customer:</strong> $CustomerName</li>\n                            <li><strong>Audit Date:</strong> $($Summary.AuditDate.ToString('MMMM dd, yyyy'))</li>\n                            <li><strong>Engineer/Auditor:</strong> $($Summary.TechnicianName)</li>\n                            <li><strong>Systems Assessed:</strong> Active Directory Infrastructure</li>\n                            <li><strong>Note:</strong> Server infrastructure audit temporarily disabled</li>\n                        </ul>\n                    </div>\n                    \n                    <div class=\"summary-card\">\n                        <h3>⚠️ Risk Assessment</h3>\n                        <div class=\"risk-summary\">\n                            <p><strong>Overall Risk Level:</strong> <span class=\"risk-level $($Summary.OverallRisk.ToLower())\">$($Summary.OverallRisk)</span></p>\n                            <p><strong>Priority Actions:</strong> $($Summary.CriticalFindings + $Summary.HighFindings) immediate items</p>\n                            <p><strong>Total Findings:</strong> $($Summary.TotalFindings) security issues identified</p>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"key-findings\">\n                    <h3>🎯 Key Security Concerns</h3>\n                    <div class=\"concern-list\">\n$(\n    $topConcerns = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Sort-Object @{Expression={if($_.Severity -eq 'Critical'){1}else{2}}}, Title | Select-Object -First 5\n    if ($topConcerns.Count -gt 0) {\n        foreach ($concern in $topConcerns) {\n            $icon = if ($concern.Severity -eq 'Critical') { '🔴' } else { '🟠' }\n            @\"\n                        <div class=\"concern-item\">\n                            <span class=\"concern-icon\">$icon</span>\n                            <div class=\"concern-content\">\n                                <strong>$($concern.Category):</strong> $($concern.Title)\n                                <br><small>$($concern.Impact)</small>\n                            </div>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"concern-item\"><span class=\"concern-icon\">✅</span><div class=\"concern-content\">No critical security concerns identified</div></div>'\n    }\n)\n                    </div>\n                </div>\n                \n                <div class=\"compliance-overview\">\n                    <h3>📋 Compliance Framework Analysis</h3>\n                    <div class=\"compliance-grid\">\n$(\n    $complianceStats = $script:AuditFindings | Where-Object { $_.ComplianceFramework -and $_.ComplianceFramework.Trim() -ne '' } | \n        Group-Object ComplianceFramework | Sort-Object Count -Descending\n    \n    if ($complianceStats.Count -gt 0) {\n        foreach ($framework in $complianceStats) {\n            $criticalCount = ($framework.Group | Where-Object { $_.Severity -eq 'Critical' }).Count\n            $highCount = ($framework.Group | Where-Object { $_.Severity -eq 'High' }).Count\n            @\"\n                        <div class=\"compliance-item\">\n                            <h4>$($framework.Name)</h4>\n                            <p>$($framework.Count) findings ($criticalCount critical, $highCount high priority)</p>\n                        </div>\n\"@\n        }\n    } else {\n        '<div class=\"compliance-item\"><h4>General Security</h4><p>Compliance framework mapping in progress</p></div>'\n    }\n)\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        $(if ($script:DomainControllerHealthData) { @\"\n        <div class=\"section\">\n            <h2>🏥 Domain Controller Health Dashboard</h2>\n            <div style=\"background: #f8f9fa; padding: 15px; border-radius: 6px; margin: 10px 0; overflow-x: auto;\">\n                <table style=\"width: 100%; border-collapse: collapse; font-size: 9pt; min-width: 1200px;\">\n                    <thead>\n                        <tr>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Server</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Site</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Ping</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Uptime (hrs)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (%)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Disk (GB)</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Time Sync</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">DNS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NTDS Svc</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">NetLogon</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Connectivity</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Replication</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Services</th>\n                            <th style=\"padding: 8px; background: #495057; color: white; text-align: center; border: 1px solid #dee2e6;\">Health Status</th>\n                        </tr>\n                    </thead>\n                    <tbody>\n$(foreach ($dc in $script:DomainControllerHealthData) {\n    $fsmoDisplay = if ($dc.FSMORoles -and $dc.FSMORoles.Count -gt 0) { ($dc.FSMORoles -join '<br>') } else { 'None' }\n    @\"\n                        <tr>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; font-weight: bold;\">$($dc.Server)<br><small style=\"color: #666;\">$fsmoDisplay</small></td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center;\">$($dc.Site)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSTest -eq 'Success') { '#6BBF59' } elseif ($dc.DNSTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.DNSTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.PingTest -eq 'Success') { '#6BBF59' } elseif ($dc.PingTest -eq 'Fail') { '#D9534F; color: white' } else { '#FFD966' });\">$($dc.PingTest)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.UptimeHours -eq 'Fail' -or $dc.UptimeHours -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.UptimeHours -lt 24) { '#FFD966' } else { '#6BBF59' });\">$($dc.UptimeHours)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpacePercent -eq 'Fail' -or $dc.OSFreeSpacePercent -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpacePercent -le 15) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpacePercent)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.OSFreeSpaceGB -eq 'Fail' -or $dc.OSFreeSpaceGB -eq 'CIM Failure') { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 5) { '#D9534F; color: white' } elseif ($dc.OSFreeSpaceGB -lt 10) { '#FFD966' } else { '#6BBF59' });\">$($dc.OSFreeSpaceGB)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.TimeOffset -eq 'Fail') { '#D9534F; color: white' } elseif ([Math]::Abs($dc.TimeOffset) -gt 5) { '#D9534F; color: white' } else { '#6BBF59' });\">$($dc.TimeOffset)s</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DNSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DNSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NTDSService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NTDSService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.NetLogonService -eq 'Success') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.NetLogonService)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagConnectivity -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagConnectivity)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagReplications -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagReplications)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; background: $(if ($dc.DCDiagServices -eq 'Passed') { '#6BBF59' } else { '#D9534F; color: white' });\">$($dc.DCDiagServices)</td>\n                            <td style=\"padding: 6px; border: 1px solid #dee2e6; text-align: center; font-weight: bold; background: $(if ($dc.OverallHealth -eq 'Healthy') { '#6BBF59' } elseif ($dc.OverallHealth -eq 'Warning') { '#FFD966' } else { '#D9534F; color: white' });\">$($dc.OverallHealth)</td>\n                        </tr>\n\"@\n})\n                    </tbody>\n                </table>\n                <div style=\"margin-top: 10px; font-size: 9pt; color: #666;\">\n                    <strong>Legend:</strong> \n                    <span style=\"background: #6BBF59; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Pass</span>\n                    <span style=\"background: #FFD966; padding: 2px 6px; border-radius: 3px; margin-right: 10px;\">Warning</span>\n                    <span style=\"background: #D9534F; color: white; padding: 2px 6px; border-radius: 3px;\">Fail</span>\n                </div>\n            </div>\n        </div>\n\"@ })\n        \n        <div style=\"text-align: center; margin-top: 40px; padding: 20px; background: #f8f9fa; border-radius: 10px;\">\n            <p><strong>Audit Summary</strong></p>\n            <p>This comprehensive audit assessed $($Summary.TotalFindings) security and compliance findings across the Active Directory infrastructure.</p>\n        </div>\n    </div>\n\n    <script>\n        // Collapsible findings functionality\n        function toggleFinding(findingId) {\n            const content = document.getElementById('content-' + findingId);\n            const toggle = document.getElementById('toggle-' + findingId);\n            \n            if (content.classList.contains('show')) {\n                content.classList.remove('show');\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            } else {\n                content.classList.add('show');\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            }\n        }\n        \n        // Expand/Collapse all functions\n        function expandAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.add('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '−';\n                toggle.classList.add('open');\n            });\n        }\n        \n        function collapseAll() {\n            document.querySelectorAll('.finding-content').forEach(content => {\n                content.classList.remove('show');\n            });\n            document.querySelectorAll('.finding-toggle').forEach(toggle => {\n                toggle.textContent = '+';\n                toggle.classList.remove('open');\n            });\n        }\n        \n        console.log('Infrastructure Audit Report loaded successfully');\n        console.log('Total findings: $($Summary.TotalFindings)');\n        console.log('Risk level: $($Summary.OverallRisk)');\n        \n        // Initialize all findings as collapsed by default\n        document.addEventListener('DOMContentLoaded', function() {\n            collapseAll();\n        });\n    </script>\n</body>\n</html>\n\"@\n    \n    $htmlContent | Out-File -FilePath $htmlPath -Encoding UTF8\n    Write-AuditLog \"HTML report saved: $htmlPath\" -Level Success\n}\n\nfunction New-ExcelReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Excel report...' -Level Info\n    \n    try {\n        $excelPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.xlsx'\n        \n        # Check if ImportExcel module is available\n        if (-not (Get-Module -ListAvailable -Name ImportExcel)) {\n            Write-AuditLog \"ImportExcel module not available, skipping Excel export\" -Level Warning\n            return\n        }\n        \n        Import-Module ImportExcel -SkipEditionCheck -ErrorAction SilentlyContinue\n        \n        # Summary sheet\n        $summaryData = [PSCustomObject]@{\n            'Metric' = 'Customer Name'; 'Value' = $Summary.CustomerName\n        }, [PSCustomObject]@{\n            'Metric' = 'Audit Date'; 'Value' = $Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss')\n        }, [PSCustomObject]@{\n            'Metric' = 'Technician'; 'Value' = $Summary.TechnicianName\n        }, [PSCustomObject]@{\n            'Metric' = 'Overall Risk Level'; 'Value' = $Summary.OverallRisk\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Findings'; 'Value' = $Summary.TotalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Critical Findings'; 'Value' = $Summary.CriticalFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'High Findings'; 'Value' = $Summary.HighFindings\n        }, [PSCustomObject]@{\n            'Metric' = 'Total Servers'; 'Value' = $Summary.TotalServers\n        }, [PSCustomObject]@{\n            'Metric' = 'Online Servers'; 'Value' = $Summary.OnlineServers\n        }, [PSCustomObject]@{\n            'Metric' = 'High Risk Servers'; 'Value' = $Summary.HighRiskServers\n        }\n        \n        $summaryData | Export-Excel -Path $excelPath -WorksheetName 'Summary' -AutoSize -BoldTopRow\n        \n        # Findings sheet\n        $script:AuditFindings | Export-Excel -Path $excelPath -WorksheetName 'Security Findings' -AutoSize -BoldTopRow\n        \n        # Server results sheet\n        $script:ServerResults | Export-Excel -Path $excelPath -WorksheetName 'Server Status' -AutoSize -BoldTopRow\n        \n        Write-AuditLog \"Excel report saved: $excelPath\" -Level Success\n        \n    } catch {\n        Write-AuditLog \"Error generating Excel report: $($_.Exception.Message)\" -Level Warning\n    }\n}\n\nfunction New-CSVReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating CSV reports...' -Level Info\n    \n    # Findings CSV\n    $findingsPath = Join-Path $script:OutputDir 'Audit-Findings.csv'\n    $script:AuditFindings | Export-Csv -Path $findingsPath -NoTypeInformation\n    \n    # Server status CSV\n    $serversPath = Join-Path $script:OutputDir 'Server-Status.csv'\n    $script:ServerResults | Export-Csv -Path $serversPath -NoTypeInformation\n    \n    Write-AuditLog \"CSV reports saved: $findingsPath, $serversPath\" -Level Success\n}\n\nfunction New-MarkdownReport {\n    param($Summary)\n    \n    Write-AuditLog 'Generating Markdown report...' -Level Info\n    \n    $markdownPath = Join-Path $script:OutputDir 'Infrastructure-Audit-Report.md'\n    \n    $markdownContent = @\"\n# Infrastructure Security Audit Report\n\n**Customer:** $CustomerName  \n**Audit Date:** $($Summary.AuditDate.ToString('yyyy-MM-dd HH:mm:ss'))  \n**Technician:** $($Summary.TechnicianName)  \n**Overall Risk Level:** **$($Summary.OverallRisk)**\n\n## Executive Summary\n\nThis infrastructure audit assessed $($Summary.TotalServers) servers and identified $($Summary.TotalFindings) security and configuration findings.\n\n### Key Metrics\n\n| Metric | Count |\n|--------|-------|\n| Critical Findings | $($Summary.CriticalFindings) |\n| High Priority Findings | $($Summary.HighFindings) |\n| Medium Priority Findings | $($Summary.MediumFindings) |\n| Low Priority Findings | $($Summary.LowFindings) |\n| Total Servers Audited | $($Summary.TotalServers) |\n| Online Servers | $($Summary.OnlineServers) |\n| High Risk Servers | $($Summary.HighRiskServers) |\n\n## Security Findings\n\n$(\n    $script:AuditFindings | ForEach-Object {\n        @\"\n### $($_.Title) [$($_.Severity)]\n\n**Category:** $($_.Category)  \n**Type:** $($_.Type)  \n**Compliance Framework:** $($_.ComplianceFramework)\n\n**Description:** $($_.Description)\n\n**Impact:** $($_.Impact)\n\n**Recommendation:** $($_.Recommendation)\n\n$(if ($_.Evidence) { \"**Evidence:**`n``````n$($_.Evidence)`n``````n\" })\n\n---\n\"@\n    }\n)\n\n## Server Infrastructure Status\n\n| Server Name | Status | Operating System | Risk Score | Security Issues | Performance Issues |\n|-------------|--------|------------------|------------|-----------------|-------------------|\n$(\n    $script:ServerResults | ForEach-Object {\n        \"| $($_.ServerName) | $($_.PingStatus) | $($_.OperatingSystem) | $($_.RiskScore) | $($_.SecurityIssues.Count) | $($_.PerformanceIssues.Count) |\"\n    }\n)\n\n## Recommendations Summary\n\n### Immediate Actions Required (Critical/High)\n$(\n    $criticalAndHigh = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') }\n    if ($criticalAndHigh.Count -gt 0) {\n        $criticalAndHigh | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\n### Short-term Improvements (Medium)\n$(\n    $medium = $script:AuditFindings | Where-Object { $_.Severity -eq 'Medium' }\n    if ($medium.Count -gt 0) {\n        $medium | ForEach-Object { \"- **$($_.Category):** $($_.Recommendation)\" }\n    } else {\n        \"- No medium priority items identified\"\n    }\n)\n\n---\n\n*Report generated by Master Infrastructure Audit Script v$($script:Version)*  \n*Audit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes*\n\"@\n    \n    $markdownContent | Out-File -FilePath $markdownPath -Encoding UTF8\n    Write-AuditLog \"Markdown report saved: $markdownPath\" -Level Success\n}\n\nfunction New-ExecutiveSummary {\n    param($Summary)\n    \n    Write-AuditLog 'Generating executive summary...' -Level Info\n    \n    $execSummaryPath = Join-Path $script:OutputDir 'Executive-Summary.txt'\n    \n    $execSummary = @\"\nINFRASTRUCTURE SECURITY AUDIT - EXECUTIVE SUMMARY\n================================================================\n\nCustomer: $CustomerName\nAudit Date: $($Summary.AuditDate.ToString('MMMM dd, yyyy'))\nEngineer/Auditor: $($Summary.TechnicianName)\nAudit Duration: $([math]::Round($Summary.AuditDuration.TotalMinutes, 2)) minutes\n\nOVERALL RISK ASSESSMENT: $($Summary.OverallRisk)\n\nFINDINGS SUMMARY:\n- Critical Issues: $($Summary.CriticalFindings)\n- High Priority: $($Summary.HighFindings)  \n- Medium Priority: $($Summary.MediumFindings)\n- Low Priority: $($Summary.LowFindings)\n- Total Findings: $($Summary.TotalFindings)\n\nINFRASTRUCTURE SUMMARY:\n- Total Servers: $($Summary.TotalServers)\n- Online Servers: $($Summary.OnlineServers)\n- Offline Servers: $($Summary.OfflineServers)\n- High Risk Servers: $($Summary.HighRiskServers)\n\nIMMEDIATE ACTIONS REQUIRED:\n$(\n    $immediateActions = $script:AuditFindings | Where-Object { $_.Severity -in @('Critical', 'High') } | Select-Object -First 5\n    if ($immediateActions.Count -gt 0) {\n        $immediateActions | ForEach-Object { \"- $($_.Category): $($_.Title)\" }\n    } else {\n        \"- No immediate critical actions required\"\n    }\n)\n\nCOMPLIANCE ASSESSMENT:\n$(\n    $frameworks = $script:AuditFindings | Group-Object ComplianceFramework | Where-Object { $_.Name -ne '' }\n    if ($frameworks.Count -gt 0) {\n        $frameworks | ForEach-Object { \"- $($_.Name): $($_.Count) findings\" }\n    } else {\n        \"- Compliance frameworks assessment pending\"\n    }\n)\n\nThis executive summary provides a high-level overview of the infrastructure \nsecurity assessment. Detailed findings, recommendations, and remediation \nprocedures are available in the comprehensive audit reports.\n\n================================================================\n\"@\n    \n    $execSummary | Out-File -FilePath $execSummaryPath -Encoding UTF8\n    Write-AuditLog \"Executive summary saved: $execSummaryPath\" -Level Success\n}\n\n# ==============================================================================\n# MAIN EXECUTION LOGIC\n# ==============================================================================\n\nfunction Start-MasterInfrastructureAudit {\n    # Display banner\n    Write-Host \"\"\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"MASTER INFRASTRUCTURE AUDIT SCRIPT v$($script:Version)\" -ForegroundColor Cyan\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"Customer: $CustomerName\" -ForegroundColor White\n    Write-Host \"Technician: $TechnicianName\" -ForegroundColor White\n    Write-Host \"Start Time: $($script:StartTime.ToString('yyyy-MM-dd HH:mm:ss'))\" -ForegroundColor White\n    Write-Host \"Output Directory: $script:OutputDir\" -ForegroundColor White\n    Write-Host \"=\" * 80 -ForegroundColor Cyan\n    Write-Host \"\"\n    \n    Write-AuditLog \"Starting Master Infrastructure Audit for $CustomerName\" -Level Header\n    Write-AuditLog \"Technician: $TechnicianName\" -Level Info\n    Write-AuditLog \"Output Directory: $script:OutputDir\" -Level Info\n    Write-AuditLog \"Export Formats: $($ExportFormats -join ', ')\" -Level Info\n    \n    try {\n        # Initialize logo path for reports\n        $script:LogoPath = Initialize-LogoPath\n        Write-AuditLog \"Logo path initialized: $($script:LogoPath)\" -Level Info\n        \n        # Initialize task counting\n        $script:TotalTasks = 1 # Report Generation is always done\n        if (-not $SkipADHealthChecks) { $script:TotalTasks++ }\n        if (-not $SkipServerAudit) { $script:TotalTasks++ }\n        \n        # Active Directory Health Assessment\n        if (-not $SkipADHealthChecks) {\n            Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Starting Active Directory assessment...\"\n            $adSuccess = Test-ADInfrastructureHealth\n            $script:CompletedTasks++\n            \n            if (-not $adSuccess) {\n                Write-AuditLog \"Active Directory assessment failed or incomplete\" -Level Warning\n            }\n        } else {\n            Write-AuditLog \"Skipping Active Directory health checks as requested\" -Level Info\n        }\n        \n        # Server Infrastructure Audit - Currently disabled due to hanging issues\n        if (-not $SkipServerAudit) {\n            Write-AuditLog \"Server infrastructure audit temporarily disabled due to connectivity issues\" -Level Warning\n            Write-AuditLog \"Focus on Active Directory findings - server audit can be run separately if needed\" -Level Info\n            $script:CompletedTasks++\n        } else {\n            Write-AuditLog \"Skipping server infrastructure audit as requested\" -Level Info\n        }\n        \n        # Generate Reports\n        Update-AuditProgress -Activity \"Master Infrastructure Audit\" -Status \"Generating comprehensive reports...\"\n        New-ComprehensiveAuditReport\n        $script:CompletedTasks++\n        \n        # Display final summary\n        $executionTime = (Get-Date) - $script:StartTime\n        \n        Write-Host \"\"\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"AUDIT COMPLETED SUCCESSFULLY\" -ForegroundColor Green\n        Write-Host \"=\" * 80 -ForegroundColor Green\n        Write-Host \"\"\n        \n        $summary = Get-AuditSummaryStatistics\n        \n        Write-Host \"AUDIT SUMMARY:\" -ForegroundColor Cyan\n        Write-Host \"  Customer: $CustomerName\" -ForegroundColor White\n        Write-Host \"  Overall Risk Level: \" -NoNewline -ForegroundColor White\n        \n        switch ($summary.OverallRisk) {\n            'CRITICAL' { Write-Host $summary.OverallRisk -ForegroundColor Red }\n            'HIGH' { Write-Host $summary.OverallRisk -ForegroundColor DarkRed }\n            'MEDIUM' { Write-Host $summary.OverallRisk -ForegroundColor Yellow }\n            'LOW' { Write-Host $summary.OverallRisk -ForegroundColor Green }\n        }\n        \n        Write-Host \"\"\n        Write-Host \"FINDINGS:\" -ForegroundColor Cyan\n        Write-Host \"  Critical: \" -NoNewline -ForegroundColor White\n        Write-Host $summary.CriticalFindings -ForegroundColor $(if ($summary.CriticalFindings -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High:     \" -NoNewline -ForegroundColor White\n        Write-Host $summary.HighFindings -ForegroundColor $(if ($summary.HighFindings -gt 0) { 'DarkRed' } else { 'Green' })\n        Write-Host \"  Medium:   \" -NoNewline -ForegroundColor White\n        Write-Host $summary.MediumFindings -ForegroundColor $(if ($summary.MediumFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Low:      \" -NoNewline -ForegroundColor White\n        Write-Host $summary.LowFindings -ForegroundColor $(if ($summary.LowFindings -gt 0) { 'Yellow' } else { 'Green' })\n        Write-Host \"  Total:    \" -NoNewline -ForegroundColor White\n        Write-Host $summary.TotalFindings -ForegroundColor Cyan\n        \n        Write-Host \"\"\n        Write-Host \"INFRASTRUCTURE:\" -ForegroundColor Cyan\n        Write-Host \"  Total Servers:    $($summary.TotalServers)\" -ForegroundColor White\n        Write-Host \"  Online Servers:   $($summary.OnlineServers)\" -ForegroundColor Green\n        Write-Host \"  Offline Servers:  $($summary.OfflineServers)\" -ForegroundColor $(if ($summary.OfflineServers -gt 0) { 'Red' } else { 'Green' })\n        Write-Host \"  High Risk Servers: $($summary.HighRiskServers)\" -ForegroundColor $(if ($summary.HighRiskServers -gt 0) { 'Red' } else { 'Green' })\n        \n        Write-Host \"\"\n        Write-Host \"EXECUTION DETAILS:\" -ForegroundColor Cyan\n        Write-Host \"  Duration: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -ForegroundColor White\n        Write-Host \"  Reports Location: $script:OutputDir\" -ForegroundColor White\n        \n        if ($summary.CriticalFindings -gt 0 -or $summary.HighFindings -gt 0) {\n            Write-Host \"\"\n            Write-Host \"⚠️  URGENT ACTION REQUIRED ⚠️\" -ForegroundColor Red -BackgroundColor Yellow\n            Write-Host \"Critical and High priority issues require immediate attention!\" -ForegroundColor Red\n        }\n        \n        Write-AuditLog \"Master Infrastructure Audit completed successfully\" -Level Success\n        Write-AuditLog \"Total execution time: $([math]::Round($executionTime.TotalMinutes, 2)) minutes\" -Level Info\n        \n        # Open output directory\n        try {\n            Start-Process $script:OutputDir\n        } catch {\n            Write-AuditLog \"Could not open output directory automatically\" -Level Warning\n        }\n        \n    } catch {\n        Write-AuditLog \"FATAL ERROR during audit execution: $($_.Exception.Message)\" -Level Error\n        Write-AuditLog \"Stack Trace: $($_.ScriptStackTrace)\" -Level Error\n        throw\n    } finally {\n        Write-Progress -Activity \"Master Infrastructure Audit\" -Completed\n    }\n}\n\n# ==============================================================================\n# SCRIPT EXECUTION\n# ==============================================================================\n\n# Check required modules before starting\nif (-not (Test-RequiredModules)) {\n    Write-Host \"`nScript cannot continue without required modules. Please install missing modules and try again.\" -ForegroundColor Red\n    exit 1\n}\n\n# Parameter validation\nif (-not $CustomerName -or -not $TechnicianName) {\n    Write-Error \"CustomerName and TechnicianName parameters are required\"\n    exit 1\n}\n\n# Execute the main audit function\ntry {\n    Start-MasterInfrastructureAudit\n} catch {\n    Write-Host \"`nSCRIPT EXECUTION FAILED:\" -ForegroundColor Red\n    Write-Host $_.Exception.Message -ForegroundColor Red\n    Write-Host \"`nFor support, check the audit log in: $script:OutputDir\" -ForegroundColor Yellow\n    exit 1\n}\n\nWrite-Host \"`n✅ Master Infrastructure Audit completed successfully!\" -ForegroundColor Green\nWrite-Host \"📁 All reports and logs saved to: $script:OutputDir\" -ForegroundColor Cyan",
    "language": "powershell",
    "category": "backup-recovery",
    "tags": [
      "audit",
      "backup",
      "monitoring",
      "export",
      "import",
      "system",
      "infrastructure",
      "performance",
      "security"
    ],
    "lastModified": "2025-07-08T15:51:51.338Z",
    "version": "5.1",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": [
      {
        "name": "true",
        "type": "string",
        "required": false,
        "description": "Parameter true"
      }
    ]
  },
  {
    "id": "imported-1759100564758-qiysq4tnv",
    "name": "!/usr/bin/env pwsh",
    "description": "Imported script - description to be added",
    "content": "#!/usr/bin/env pwsh\n<#\n.SYNOPSIS\n    HTML Source Code Protection Script\n    \n.DESCRIPTION\n    This script encrypts HTML source code with password protection to prevent unauthorized \n    modification while maintaining browser functionality for authorized users.\n    \n.PARAMETER FilePath\n    Path to the HTML file to protect\n    \n.PARAMETER Password\n    Password to encrypt the HTML source code (default: Nlf263nish25!)\n    \n.PARAMETER BackupOriginal\n    Create a backup of the original file before protection\n    \n.EXAMPLE\n    .\\Protect-HtmlFiles.ps1 -FilePath \"report.html\"\n    \n.EXAMPLE\n    .\\Protect-HtmlFiles.ps1 -FilePath \"tool.html\" -Password \"MySecurePassword!\" -BackupOriginal\n    \n.NOTES\n    Author: First Technology Security Framework\n    Version: 1.0\n    Created: July 2025\n#>\n\nparam(\n    [Parameter(Mandatory = $true)]\n    [string]$FilePath,\n    \n    [Parameter(Mandatory = $false)]\n    [string]$Password = \"Nlf263nish25!\",\n    \n    [Parameter(Mandatory = $false)]\n    [switch]$BackupOriginal\n)\n\nfunction Protect-HtmlSource {\n    [CmdletBinding()]\n    param(\n        [Parameter(Mandatory = $true)]\n        [string]$HtmlContent,\n        \n        [Parameter(Mandatory = $true)]\n        [string]$Password,\n        \n        [Parameter(Mandatory = $false)]\n        [string]$Title = \"Protected HTML Tool\"\n    )\n    \n    # Convert HTML to Base64\n    $bytes = [System.Text.Encoding]::UTF8.GetBytes($HtmlContent)\n    $base64Html = [System.Convert]::ToBase64String($bytes)\n    \n    # Create password hash for validation\n    $passwordHash = [System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($Password))\n    $passwordHashString = [System.BitConverter]::ToString($passwordHash).Replace('-', '').ToLower()\n    \n    # Create protected HTML wrapper\n    $protectedHtml = @\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>🔒 $Title</title>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        body { \n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; \n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \n            margin: 0; \n            padding: 20px; \n            min-height: 100vh;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .container { \n            max-width: 500px; \n            width: 100%;\n            background: white; \n            padding: 40px; \n            border-radius: 15px; \n            box-shadow: 0 10px 30px rgba(0,0,0,0.2); \n            text-align: center; \n        }\n        h1 { \n            color: #333; \n            margin-bottom: 10px; \n            font-size: 2em;\n        }\n        .subtitle {\n            color: #666;\n            margin-bottom: 30px;\n            font-size: 1.1em;\n        }\n        input { \n            width: 100%; \n            padding: 15px; \n            margin: 15px 0; \n            border: 2px solid #ddd; \n            border-radius: 8px; \n            font-size: 16px; \n            transition: border-color 0.3s;\n            box-sizing: border-box;\n        }\n        input:focus {\n            outline: none;\n            border-color: #667eea;\n        }\n        button { \n            width: 100%; \n            padding: 15px; \n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \n            color: white; \n            border: none; \n            border-radius: 8px; \n            font-size: 16px; \n            cursor: pointer; \n            font-weight: bold;\n            transition: transform 0.2s;\n        }\n        button:hover { \n            transform: translateY(-2px);\n        }\n        .error { \n            color: #dc3545; \n            margin-top: 15px; \n            display: none; \n            font-weight: bold;\n        }\n        .footer { \n            margin-top: 30px; \n            padding-top: 20px; \n            border-top: 1px solid #eee; \n            color: #666; \n            font-size: 12px; \n        }\n        .security-badge {\n            background: #28a745;\n            color: white;\n            padding: 5px 12px;\n            border-radius: 20px;\n            font-size: 11px;\n            font-weight: bold;\n            margin-top: 10px;\n            display: inline-block;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>🔒 Secure Access</h1>\n        <p class=\"subtitle\">This content is protected by advanced encryption</p>\n        <input type=\"password\" id=\"passwordInput\" placeholder=\"Enter decryption password\" />\n        <button onclick=\"decryptContent()\">Decrypt & Access</button>\n        <div class=\"error\" id=\"errorMsg\">Invalid password. Access denied.</div>\n        <div class=\"footer\">\n            <div class=\"security-badge\">SOURCE CODE PROTECTION: ACTIVE</div><br><br>\n            First Technology Security Framework<br>\n            <strong>Creator:</strong> Nishen Harichunder L4 Engineering : RMS<br>\n            Unauthorized access prohibited<br>\n            HTML Source Code Encryption v1.0\n        </div>\n    </div>\n\n    <script>\n        const encryptedContent = '$base64Html';\n        const validHash = '$passwordHashString';\n        \n        async function decryptContent() {\n            const password = document.getElementById('passwordInput').value;\n            \n            if (!password) {\n                document.getElementById('errorMsg').style.display = 'block';\n                return;\n            }\n            \n            try {\n                const inputHash = await sha256(password);\n                \n                if (inputHash === validHash) {\n                    const decodedContent = atob(encryptedContent);\n                    document.open();\n                    document.write(decodedContent);\n                    document.close();\n                } else {\n                    showError();\n                }\n            } catch (e) {\n                showError();\n            }\n        }\n        \n        function showError() {\n            document.getElementById('errorMsg').style.display = 'block';\n            document.getElementById('passwordInput').value = '';\n            document.getElementById('passwordInput').focus();\n        }\n        \n        // SHA256 implementation for client-side validation\n        async function sha256(str) {\n            const utf8 = new TextEncoder().encode(str);\n            const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        // Enter key support\n        document.getElementById('passwordInput').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                decryptContent();\n            }\n        });\n        \n        // Focus on load\n        document.addEventListener('DOMContentLoaded', function() {\n            document.getElementById('passwordInput').focus();\n        });\n        \n        // Security measures\n        document.addEventListener('contextmenu', function(e) {\n            e.preventDefault();\n            return false;\n        });\n        \n        document.addEventListener('keydown', function(e) {\n            if (e.key === 'F12' || \n                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) || \n                (e.ctrlKey && e.key === 'U')) {\n                e.preventDefault();\n                return false;\n            }\n        });\n    </script>\n</body>\n</html>\n\"@\n    \n    return $protectedHtml\n}\n\n# Main execution\ntry {\n    # Validate file exists\n    if (-not (Test-Path $FilePath)) {\n        throw \"File not found: $FilePath\"\n    }\n    \n    # Get file info\n    $fileInfo = Get-Item $FilePath\n    $fileName = $fileInfo.Name\n    $fileDir = $fileInfo.Directory.FullName\n    \n    Write-Host \"🔒 Protecting HTML file: $fileName\" -ForegroundColor Cyan\n    \n    # Create backup if requested\n    if ($BackupOriginal) {\n        $backupPath = Join-Path $fileDir \"$($fileInfo.BaseName).original$($fileInfo.Extension)\"\n        Copy-Item $FilePath $backupPath -Force\n        Write-Host \"📋 Backup created: $backupPath\" -ForegroundColor Green\n    }\n    \n    # Read original HTML content\n    $originalContent = Get-Content $FilePath -Raw -Encoding UTF8\n    \n    # Extract title from original HTML if possible\n    $titleMatch = [regex]::Match($originalContent, '<title>(.*?)</title>', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)\n    $title = if ($titleMatch.Success) { $titleMatch.Groups[1].Value } else { \"Protected HTML Content\" }\n    \n    # Protect the HTML source code\n    $protectedContent = Protect-HtmlSource -HtmlContent $originalContent -Password $Password -Title $title\n    \n    # Write protected content back to file\n    $protectedContent | Out-File -FilePath $FilePath -Encoding UTF8 -Force\n    \n    Write-Host \"✅ HTML source code protection applied successfully!\" -ForegroundColor Green\n    Write-Host \"🔑 Password: $Password\" -ForegroundColor Yellow\n    Write-Host \"📄 File: $FilePath\" -ForegroundColor White\n    Write-Host \"\"\n    Write-Host \"🛡️ Security Features Applied:\" -ForegroundColor Cyan\n    Write-Host \"   • Source code encrypted with Base64 + SHA256\" -ForegroundColor White\n    Write-Host \"   • Password protection prevents unauthorized editing\" -ForegroundColor White\n    Write-Host \"   • Browser functionality maintained for authorized users\" -ForegroundColor White\n    Write-Host \"   • Developer tools and right-click disabled\" -ForegroundColor White\n    Write-Host \"\"\n    Write-Host \"⚠️ Important: Save the password securely - it cannot be recovered!\" -ForegroundColor Red\n    \n} catch {\n    Write-Error \"Failed to protect HTML file: $_\"\n    exit 1\n}",
    "language": "powershell",
    "category": "backup-recovery",
    "tags": [
      "backup",
      "import",
      "system",
      "security"
    ],
    "lastModified": "2025-07-14T11:41:16.851Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": [
      {
        "name": "true",
        "type": "string",
        "required": false,
        "description": "Parameter true"
      }
    ]
  },
  {
    "id": "imported-1759100564770-n4x6tf188",
    "name": "!/bin/bash",
    "description": "Safe backup creation script for Nishen's AI Workspace",
    "content": "#!/bin/bash\n\n# Safe backup creation script for Nishen's AI Workspace\n# This script creates backups OUTSIDE the project directory to prevent build issues\n\n# Get current timestamp\nTIMESTAMP=$(date +%Y%m%d_%H%M%S)\n\n# Create backup directory outside project root\nBACKUP_DIR=\"../workspace-backups/${TIMESTAMP}_$(basename \"$1\" | sed 's/ /_/g')\"\nmkdir -p \"$BACKUP_DIR\"\n\necho \"Creating backup: $BACKUP_DIR\"\n\n# Copy source files to backup\nif [ -d \"src/components/workspace\" ]; then\n    cp -r src/components/workspace/*.tsx \"$BACKUP_DIR/\"\n    echo \"✅ Copied workspace components\"\nfi\n\nif [ -f \"CLAUDE.md\" ]; then\n    cp CLAUDE.md \"$BACKUP_DIR/\"\n    echo \"✅ Copied CLAUDE.md\"\nfi\n\nif [ -f \"package.json\" ]; then\n    cp package.json \"$BACKUP_DIR/\"\n    echo \"✅ Copied package.json\"\nfi\n\nif [ -f \"next.config.js\" ]; then\n    cp next.config.js \"$BACKUP_DIR/\"\n    echo \"✅ Copied next.config.js\"\nfi\n\necho \"✅ Backup created successfully at: $BACKUP_DIR\"\necho \"⚠️  Backup is stored OUTSIDE project directory to prevent build issues\"\n\n# Create restore instructions\ncat > \"$BACKUP_DIR/RESTORE.md\" << EOF\n# Restore Instructions\n\nThis backup was created on: $(date)\n\n## To restore files:\n\\`\\`\\`bash\n# Copy files back to project (run from project root)\ncp ../workspace-backups/${TIMESTAMP}_*/\\*.tsx src/components/workspace/\ncp ../workspace-backups/${TIMESTAMP}_*/CLAUDE.md .\ncp ../workspace-backups/${TIMESTAMP}_*/package.json .\ncp ../workspace-backups/${TIMESTAMP}_*/next.config.js .\n\\`\\`\\`\n\n## Backup contains:\n$(ls -la \"$BACKUP_DIR\")\nEOF\n\necho \"📄 Restore instructions created at: $BACKUP_DIR/RESTORE.md\"",
    "language": "bash",
    "category": "backup-recovery",
    "tags": [
      "backup"
    ],
    "lastModified": "2025-07-13T12:29:31.369Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  },
  {
    "id": "imported-1759100564781-t3o3kqhlm",
    "name": "!/usr/bin/env node",
    "description": "Read the original HTML file",
    "content": "#!/usr/bin/env node\n\nconst fs = require('fs');\nconst crypto = require('crypto');\nconst path = require('path');\n\nfunction protectHtmlFile(filePath, password = 'Nlf263nish25!') {\n    try {\n        // Read the original HTML file\n        const originalContent = fs.readFileSync(filePath, 'utf8');\n        \n        // Convert HTML to Base64\n        const base64Html = Buffer.from(originalContent).toString('base64');\n        \n        // Create password hash\n        const passwordHash = crypto.createHash('sha256').update(password).digest('hex');\n        \n        // Extract title from original HTML if possible\n        const titleMatch = originalContent.match(/<title>(.*?)<\\/title>/i);\n        const title = titleMatch ? titleMatch[1] : 'Protected HTML Content';\n        \n        // Create protected HTML wrapper\n        const protectedHtml = `<!DOCTYPE html>\n<html>\n<head>\n    <title>🔒 ${title}</title>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        body { \n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; \n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \n            margin: 0; \n            padding: 20px; \n            min-height: 100vh;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .container { \n            max-width: 500px; \n            width: 100%;\n            background: white; \n            padding: 40px; \n            border-radius: 15px; \n            box-shadow: 0 10px 30px rgba(0,0,0,0.2); \n            text-align: center; \n        }\n        h1 { \n            color: #333; \n            margin-bottom: 10px; \n            font-size: 2em;\n        }\n        .subtitle {\n            color: #666;\n            margin-bottom: 30px;\n            font-size: 1.1em;\n        }\n        input { \n            width: 100%; \n            padding: 15px; \n            margin: 15px 0; \n            border: 2px solid #ddd; \n            border-radius: 8px; \n            font-size: 16px; \n            transition: border-color 0.3s;\n            box-sizing: border-box;\n        }\n        input:focus {\n            outline: none;\n            border-color: #667eea;\n        }\n        button { \n            width: 100%; \n            padding: 15px; \n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); \n            color: white; \n            border: none; \n            border-radius: 8px; \n            font-size: 16px; \n            cursor: pointer; \n            font-weight: bold;\n            transition: transform 0.2s;\n        }\n        button:hover { \n            transform: translateY(-2px);\n        }\n        .error { \n            color: #dc3545; \n            margin-top: 15px; \n            display: none; \n            font-weight: bold;\n        }\n        .footer { \n            margin-top: 30px; \n            padding-top: 20px; \n            border-top: 1px solid #eee; \n            color: #666; \n            font-size: 12px; \n        }\n        .security-badge {\n            background: #28a745;\n            color: white;\n            padding: 5px 12px;\n            border-radius: 20px;\n            font-size: 11px;\n            font-weight: bold;\n            margin-top: 10px;\n            display: inline-block;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <h1>🔒 Secure Access</h1>\n        <p class=\"subtitle\">This content is protected by advanced encryption</p>\n        <input type=\"password\" id=\"passwordInput\" placeholder=\"Enter decryption password\" />\n        <button onclick=\"decryptContent()\">Decrypt & Access</button>\n        <div class=\"error\" id=\"errorMsg\">Invalid password. Access denied.</div>\n        <div class=\"footer\">\n            <div class=\"security-badge\">SOURCE CODE PROTECTION: ACTIVE</div><br><br>\n            First Technology Security Framework<br>\n            <strong>Creator:</strong> Nishen Harichunder L4 Engineering : RMS<br>\n            Unauthorized access prohibited<br>\n            HTML Source Code Encryption v1.0\n        </div>\n    </div>\n\n    <script>\n        const encryptedContent = '${base64Html}';\n        const validHash = '${passwordHash}';\n        \n        async function decryptContent() {\n            const password = document.getElementById('passwordInput').value;\n            \n            if (!password) {\n                document.getElementById('errorMsg').style.display = 'block';\n                return;\n            }\n            \n            try {\n                const inputHash = await sha256(password);\n                \n                if (inputHash === validHash) {\n                    const decodedContent = atob(encryptedContent);\n                    document.open();\n                    document.write(decodedContent);\n                    document.close();\n                } else {\n                    showError();\n                }\n            } catch (e) {\n                showError();\n            }\n        }\n        \n        function showError() {\n            document.getElementById('errorMsg').style.display = 'block';\n            document.getElementById('passwordInput').value = '';\n            document.getElementById('passwordInput').focus();\n        }\n        \n        // SHA256 implementation for client-side validation\n        async function sha256(str) {\n            const utf8 = new TextEncoder().encode(str);\n            const hashBuffer = await crypto.subtle.digest('SHA-256', utf8);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n        }\n        \n        // Enter key support\n        document.getElementById('passwordInput').addEventListener('keypress', function(e) {\n            if (e.key === 'Enter') {\n                decryptContent();\n            }\n        });\n        \n        // Focus on load\n        document.addEventListener('DOMContentLoaded', function() {\n            document.getElementById('passwordInput').focus();\n        });\n        \n        // Security measures\n        document.addEventListener('contextmenu', function(e) {\n            e.preventDefault();\n            return false;\n        });\n        \n        document.addEventListener('keydown', function(e) {\n            if (e.key === 'F12' || \n                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) || \n                (e.ctrlKey && e.key === 'U')) {\n                e.preventDefault();\n                return false;\n            }\n        });\n    </script>\n</body>\n</html>`;\n        \n        // Create backup\n        const backupPath = filePath.replace(/\\.html$/, '.original.html');\n        fs.copyFileSync(filePath, backupPath);\n        \n        // Write protected content\n        fs.writeFileSync(filePath, protectedHtml, 'utf8');\n        \n        console.log(`✅ HTML source code protection applied successfully!`);\n        console.log(`🔑 Password: ${password}`);\n        console.log(`📄 File: ${filePath}`);\n        console.log(`📋 Backup: ${backupPath}`);\n        \n        return true;\n    } catch (error) {\n        console.error(`❌ Error protecting HTML file: ${error.message}`);\n        return false;\n    }\n}\n\n// Check if file path is provided\nif (process.argv.length < 3) {\n    console.log('Usage: node create-protected-html.js <file-path> [password]');\n    process.exit(1);\n}\n\nconst filePath = process.argv[2];\nconst password = process.argv[3] || 'Nlf263nish25!';\n\nprotectHtmlFile(filePath, password);",
    "language": "javascript",
    "category": "backup-recovery",
    "tags": [
      "backup",
      "security"
    ],
    "lastModified": "2025-07-14T11:41:00.073Z",
    "version": "1.0.0",
    "isFavorite": false,
    "usageCount": 0,
    "parameters": []
  }
]